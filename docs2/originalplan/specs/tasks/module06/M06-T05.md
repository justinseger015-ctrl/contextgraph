# M06-T05: Implement RocksDB MemoryStore

```yaml
metadata:
  id: "M06-T05"
  title: "Implement RocksDB MemoryStore"
  module: "module-06"
  module_name: "Stub Elimination"
  layer: "logic"
  priority: "high"
  estimated_hours: 8
  created: "2026-01-04"
  status: "blocked"
  dependencies:
    - "M06-T03"  # PersistentMemoryStore interface
  spec_refs:
    - "constitution.yaml:30"   # db: dev sqlite, prod postgres
    - "contextprd.md:106-111"  # KnowledgeNode schema
```

## Problem Statement

Replace `InMemoryStore` (which loses data on restart and returns fake 0.5 similarity) with a persistent RocksDB-based implementation.

## Context

RocksDB provides:
- Persistent key-value storage
- High-performance reads/writes
- Compaction and compression
- Suitable for development and medium-scale production

## Input Context Files

```
crates/context-graph-core/src/traits/memory_store.rs      # Enhanced trait from M06-T03
crates/context-graph-core/src/stubs/memory_store_stub.rs  # InMemoryStore reference
crates/context-graph-core/src/graph/memory_node.rs        # MemoryNode schema
```

## Prerequisites

- [ ] M06-T03 complete (enhanced MemoryStore trait)
- [ ] RocksDB dependency added to Cargo.toml

## Scope

### In Scope

- Implement `RocksDbMemoryStore` in new storage module
- Serialize `MemoryNode` to bytes efficiently
- Implement all trait methods including persistence
- Compute real cosine similarity in search
- Support concurrent access with appropriate locking

### Out of Scope

- Vector indexing (handled by GraphIndex in M06-T06)
- PostgreSQL backend (future work)
- Sharding/replication

## Definition of Done

### Signatures

```rust
// File: crates/context-graph-core/src/storage/rocksdb_store.rs
use rocksdb::{DB, Options, WriteBatch};
use crate::traits::{MemoryStore, SearchResult, StorageConfig, StorageBackend};
use crate::graph::MemoryNode;

/// RocksDB-backed persistent memory store
pub struct RocksDbMemoryStore {
    db: DB,
    config: RocksDbConfig,
}

#[derive(Debug, Clone)]
pub struct RocksDbConfig {
    pub path: PathBuf,
    pub cache_size_mb: usize,
    pub max_open_files: i32,
    pub compression: bool,
}

impl RocksDbMemoryStore {
    pub fn new(config: RocksDbConfig) -> Result<Self, StorageError>;
    pub fn open(path: impl AsRef<Path>) -> Result<Self, StorageError>;
    pub fn destroy(path: impl AsRef<Path>) -> Result<(), StorageError>;
}

#[async_trait]
impl MemoryStore for RocksDbMemoryStore {
    async fn store(&self, node: MemoryNode) -> CoreResult<()>;
    async fn get(&self, id: &Uuid) -> CoreResult<Option<MemoryNode>>;
    async fn search(&self, query_embedding: &[f32], top_k: usize) -> CoreResult<Vec<SearchResult>>;
    async fn delete(&self, id: &Uuid) -> CoreResult<bool>;
    async fn update(&self, node: MemoryNode) -> CoreResult<()>;
    async fn list_all(&self) -> CoreResult<Vec<MemoryNode>>;
    async fn flush(&self) -> CoreResult<()>;
    async fn compact(&self) -> CoreResult<()>;
    async fn checkpoint(&self) -> CoreResult<PathBuf>;
    async fn restore(&self, checkpoint: &Path) -> CoreResult<()>;
    fn node_count(&self) -> usize;
    fn storage_size_bytes(&self) -> usize;
    fn backend_type(&self) -> StorageBackend;
}
```

### Constraints

- MUST persist data across restarts
- MUST compute real cosine similarity (NOT hardcoded)
- `search()` MUST return results sorted by similarity
- MUST handle concurrent reads safely
- Writes should be batched when possible
- MUST NOT block async runtime (use spawn_blocking for RocksDB ops)

### Verification

```bash
# 1. Compile check
cargo build -p context-graph-core --features rocksdb

# 2. Unit tests
cargo test -p context-graph-core rocksdb_store

# 3. Persistence test
cargo test -p context-graph-core test_rocksdb_persists_across_restart

# 4. Search correctness
cargo test -p context-graph-core test_rocksdb_search_real_similarity
```

## Pseudo Code

```
RocksDbMemoryStore:

  new(config):
    opts = Options::default()
    opts.create_if_missing(true)
    opts.set_max_open_files(config.max_open_files)
    if config.compression:
      opts.set_compression_type(Lz4)
    db = DB::open(&opts, config.path)?
    return Self { db, config }

  async store(node):
    # Serialize to bytes
    key = node.id.as_bytes()
    value = bincode::serialize(&node)?

    # Run RocksDB op in blocking thread
    spawn_blocking(move || {
      db.put(key, value)
    }).await

  async get(id):
    key = id.as_bytes()
    spawn_blocking(move || {
      match db.get(key)? {
        Some(bytes) => Ok(Some(bincode::deserialize(&bytes)?))
        None => Ok(None)
      }
    }).await

  async search(query_embedding, top_k):
    # Load all nodes (for now - will be replaced by FAISS in M06-T06)
    nodes = self.list_all().await?

    # Compute real similarities
    results = []
    for node in nodes:
      sim = cosine_similarity(query_embedding, &node.embedding)
      results.push(SearchResult { node, similarity: sim })

    # Sort descending by similarity
    results.sort_by(|a, b| b.similarity.partial_cmp(&a.similarity))

    # Take top_k
    return results.into_iter().take(top_k).collect()

  async flush():
    spawn_blocking(|| db.flush()).await

  async compact():
    spawn_blocking(|| db.compact_range(None::<&[u8]>, None::<&[u8]>)).await

  fn node_count():
    # Count keys (may be slow for large DBs)
    db.iterator().count()

  fn storage_size_bytes():
    # Get approximate size
    db.property_int_value("rocksdb.estimate-live-data-size").unwrap_or(0) as usize
```

## Files to Create

| File | Description |
|------|-------------|
| `crates/context-graph-core/src/storage/mod.rs` | Storage module |
| `crates/context-graph-core/src/storage/rocksdb_store.rs` | RocksDB implementation |

## Files to Modify

| File | Change |
|------|--------|
| `crates/context-graph-core/src/lib.rs` | Add `pub mod storage;` |
| `crates/context-graph-core/Cargo.toml` | Add `rocksdb` dependency with feature flag |

## Validation Criteria

- [ ] Data persists across store restart
- [ ] Search computes real cosine similarity
- [ ] Results sorted by similarity (descending)
- [ ] Concurrent reads don't block
- [ ] `flush()` and `compact()` work
- [ ] `checkpoint()` creates recoverable snapshot
- [ ] No data loss on crash (within RocksDB guarantees)

## Test Commands

```bash
# Run with rocksdb feature
cargo test -p context-graph-core --features rocksdb storage

# Persistence test
cargo test -p context-graph-core test_rocksdb_persistence

# Concurrent access test
cargo test -p context-graph-core test_rocksdb_concurrent_access
```

---

*Task created: 2026-01-04*
*Module: 06 - Stub Elimination*
*Layer: Logic*
*Priority: HIGH*
