# M06-T10: Wire MCP Server to Real Implementations

```yaml
metadata:
  id: "M06-T10"
  title: "Wire MCP Server to Real Implementations"
  module: "module-06"
  module_name: "Stub Elimination"
  layer: "surface"
  priority: "critical"
  estimated_hours: 8
  created: "2026-01-04"
  status: "blocked"
  dependencies:
    - "M06-T01"  # UtlProcessor adapter
    - "M06-T04"  # CandleEmbeddingProvider
    - "M06-T05"  # RocksDB MemoryStore
    - "M06-T06"  # FAISS GraphIndex
    - "M06-T08"  # Nervous layers
    - "M06-T09"  # Fail-fast error handling
  spec_refs:
    - "constitution.yaml:73"   # AP-007: No stub data in prod
```

## Problem Statement

The MCP server (`server.rs`) directly instantiates stub implementations:

```rust
// server.rs:33-34 - BROKEN
let memory_store: Arc<dyn MemoryStore> = Arc::new(InMemoryStore::new());
let utl_processor: Arc<dyn UtlProcessor> = Arc::new(StubUtlProcessor::new());
```

This task wires real implementations and removes fake embeddings from handlers.

## Context

After M06-T01 through M06-T09 are complete, we have:
- `UtlProcessorAdapter` (wraps real UTL)
- `CandleEmbeddingProvider` (real embeddings)
- `RocksDbMemoryStore` (persistent storage)
- `FaissGraphIndex` (fast vector search)
- Real nervous layers (L1-L5)

Now we need to:
1. Update server initialization
2. Inject dependencies into handlers
3. Remove all `vec![0.1; 1536]` fake embeddings
4. Add configuration for backend selection

## Input Context Files

```
crates/context-graph-mcp/src/server.rs           # Server setup
crates/context-graph-mcp/src/handlers/mod.rs     # Handler struct
crates/context-graph-mcp/src/handlers/tools.rs   # Tool handlers (fake embeddings)
crates/context-graph-mcp/src/handlers/memory.rs  # Memory handlers (fake embeddings)
```

## Prerequisites

- [ ] M06-T01 complete (UtlProcessorAdapter)
- [ ] M06-T04 complete (CandleEmbeddingProvider)
- [ ] M06-T05 complete (RocksDbMemoryStore)
- [ ] M06-T06 complete (FaissGraphIndex)
- [ ] M06-T08 complete (Real layers)
- [ ] M06-T09 complete (Fail-fast errors)

## Scope

### In Scope

- Update `Handlers` struct to hold all real providers
- Update `server.rs` to instantiate real implementations
- Add `ServerConfig` for runtime configuration
- Remove ALL fake embeddings from handlers
- Add feature flags for stub vs real

### Out of Scope

- New MCP tools (handled in other modules)
- Metrics/monitoring (future work)
- Hot-reloading of configuration

## Definition of Done

### Signatures

```rust
// File: crates/context-graph-mcp/src/config.rs
#[derive(Debug, Clone, Deserialize)]
pub struct ServerConfig {
    pub storage: StorageConfig,
    pub embedding: EmbeddingConfig,
    pub utl: UtlConfig,
    pub index: IndexConfig,
}

#[derive(Debug, Clone, Deserialize)]
pub struct StorageConfig {
    pub backend: StorageBackend,
    pub path: PathBuf,
}

#[derive(Debug, Clone, Deserialize)]
pub struct EmbeddingConfig {
    pub provider: EmbeddingProviderType,
    pub model_id: String,
    pub device: DeviceConfig,
}

#[derive(Debug, Clone, Deserialize)]
pub enum EmbeddingProviderType {
    Stub,
    Candle,
    OpenAI,  // Future
}

// File: crates/context-graph-mcp/src/handlers/mod.rs (UPDATED)
pub struct Handlers {
    pub(crate) memory_store: Arc<dyn MemoryStore>,
    pub(crate) utl_processor: Arc<dyn UtlProcessor>,
    pub(crate) embedding_provider: Arc<dyn EmbeddingProvider>,  // NEW
    pub(crate) graph_index: Arc<dyn GraphIndex>,                 // NEW
    pub(crate) nervous_pipeline: Arc<NervousPipeline>,           // NEW
}

impl Handlers {
    pub fn new(
        memory_store: Arc<dyn MemoryStore>,
        utl_processor: Arc<dyn UtlProcessor>,
        embedding_provider: Arc<dyn EmbeddingProvider>,
        graph_index: Arc<dyn GraphIndex>,
        nervous_pipeline: Arc<NervousPipeline>,
    ) -> Self;

    /// Create with default production configuration
    pub async fn with_config(config: ServerConfig) -> CoreResult<Self>;
}
```

### Constraints

- MUST NOT break MCP protocol compatibility
- MUST support both stub (testing) and real (production) modes
- Feature flag `#[cfg(feature = "stub")]` for stub code
- Production build MUST NOT compile with stub implementations
- All embeddings MUST come from `embedding_provider`, never hardcoded

### Verification

```bash
# 1. No fake embeddings in handlers
grep -r "vec!\[0\.1" crates/context-graph-mcp/src/handlers/*.rs
# Expected: 0 results

# 2. No StubUtlProcessor in server.rs
grep "StubUtlProcessor" crates/context-graph-mcp/src/server.rs
# Expected: 0 results (unless behind #[cfg(feature = "stub")])

# 3. Build with real implementations
cargo build -p context-graph-mcp --features real

# 4. Integration tests pass
cargo test -p context-graph-mcp --features real
```

## Pseudo Code

```
ServerConfig (crates/context-graph-mcp/src/config.rs):

  impl Default {
    fn default() -> Self {
      Self {
        storage: StorageConfig {
          backend: StorageBackend::RocksDB,
          path: PathBuf::from("./data/context-graph"),
        },
        embedding: EmbeddingConfig {
          provider: EmbeddingProviderType::Candle,
          model_id: "sentence-transformers/all-MiniLM-L6-v2".into(),
          device: DeviceConfig::Auto,
        },
        utl: UtlConfig::default(),
        index: IndexConfig {
          backend: IndexBackend::Faiss,
          dimensions: 384,  // MiniLM
        },
      }
    }
  }


Handlers::with_config (crates/context-graph-mcp/src/handlers/mod.rs):

  async fn with_config(config: ServerConfig) -> Result<Self> {
    // Create embedding provider
    let embedding_provider: Arc<dyn EmbeddingProvider> = match config.embedding.provider {
      EmbeddingProviderType::Candle => {
        Arc::new(CandleEmbeddingProvider::new(config.embedding.into()).await?)
      }
      #[cfg(feature = "stub")]
      EmbeddingProviderType::Stub => {
        Arc::new(StubEmbeddingProvider::with_dimensions(384))
      }
      _ => return Err(CoreError::UnsupportedProvider(...)),
    };

    // Create storage
    let memory_store: Arc<dyn MemoryStore> = match config.storage.backend {
      StorageBackend::RocksDB => {
        Arc::new(RocksDbMemoryStore::open(&config.storage.path)?)
      }
      #[cfg(feature = "stub")]
      StorageBackend::InMemory => {
        Arc::new(InMemoryStore::new())
      }
      _ => return Err(...),
    };

    // Create index
    let graph_index: Arc<dyn GraphIndex> = match config.index.backend {
      IndexBackend::Faiss => {
        Arc::new(FaissGraphIndex::new(config.index.into())?)
      }
      #[cfg(feature = "stub")]
      IndexBackend::InMemory => {
        Arc::new(InMemoryGraphIndex::new())
      }
      _ => return Err(...),
    };

    // Create UTL processor
    let utl_processor: Arc<dyn UtlProcessor> = {
      Arc::new(UtlProcessorAdapter::new(config.utl.into()))
    };

    // Create nervous pipeline
    let nervous_pipeline = Arc::new(NervousPipeline::new(
      SensingLayer::new(embedding_provider.clone(), ...),
      ReflexLayer::new(...),
      MemoryLayer::new(memory_store.clone(), graph_index.clone(), ...),
      LearningLayer::new(utl_processor.clone(), ...),
      CoherenceLayer::new(...),
    ));

    Ok(Self {
      memory_store,
      utl_processor,
      embedding_provider,
      graph_index,
      nervous_pipeline,
    })
  }


tools.rs - REMOVE FAKE EMBEDDINGS:

  // BEFORE (WRONG)
  let embedding = vec![0.1; 1536];

  // AFTER (CORRECT)
  let embedding_result = self.embedding_provider.embed(&content).await
      .map_err(|e| {
          tracing::error!("Embedding generation failed: {}", e);
          e
      })?;
  let embedding = embedding_result.vector;


server.rs - USE REAL CONFIG:

  pub async fn run() -> Result<()> {
    // Load config from file or environment
    let config = ServerConfig::from_env_or_default()?;

    // Create handlers with real implementations
    let handlers = Handlers::with_config(config).await?;

    // Start MCP server
    let server = McpServer::new(handlers);
    server.run().await
  }
```

## Files to Create

| File | Description |
|------|-------------|
| `crates/context-graph-mcp/src/config.rs` | Server configuration |

## Files to Modify

| File | Change |
|------|--------|
| `crates/context-graph-mcp/src/handlers/mod.rs` | Add new providers, update constructor |
| `crates/context-graph-mcp/src/handlers/tools.rs` | Use embedding_provider |
| `crates/context-graph-mcp/src/handlers/memory.rs` | Use embedding_provider |
| `crates/context-graph-mcp/src/server.rs` | Use ServerConfig, real implementations |
| `crates/context-graph-mcp/src/lib.rs` | Export config module |
| `crates/context-graph-mcp/Cargo.toml` | Add feature flags |

## Feature Flags

```toml
# Cargo.toml
[features]
default = ["real"]
real = ["candle", "rocksdb", "faiss"]
stub = []  # For testing only

candle = ["context-graph-embeddings/candle"]
rocksdb = ["context-graph-core/rocksdb"]
faiss = ["context-graph-core/faiss"]
```

## Validation Criteria

- [ ] `cargo build -p context-graph-mcp --features real` succeeds
- [ ] No `vec![0.1; 1536]` in non-test code
- [ ] No stub types in production code path
- [ ] MCP protocol tests pass
- [ ] Real embeddings generated for all content
- [ ] Persistent storage works across restarts

## Test Commands

```bash
# Build with real features
cargo build -p context-graph-mcp --features real --release

# Run tests with real features
cargo test -p context-graph-mcp --features real

# Verify no fake embeddings
grep -r "vec!\[0\.1" crates/context-graph-mcp/src/ --include="*.rs" | grep -v test
# Expected: 0 results

# Verify stub feature isolation
cargo build -p context-graph-mcp --features stub 2>&1 | grep -i "warning\|error"
```

---

*Task created: 2026-01-04*
*Module: 06 - Stub Elimination*
*Layer: Surface*
*Priority: CRITICAL*
