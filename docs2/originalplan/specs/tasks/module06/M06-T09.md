# M06-T09: Replace Silent Fallbacks with Fail-Fast Error Handling

```yaml
metadata:
  id: "M06-T09"
  title: "Replace Silent Fallbacks with Fail-Fast Error Handling"
  module: "module-06"
  module_name: "Stub Elimination"
  layer: "logic"
  priority: "high"
  estimated_hours: 6
  created: "2026-01-04"
  status: "ready"
  dependencies: []
  spec_refs:
    - "constitution.yaml:73-89"   # Anti-patterns and coding rules
    - "constitution.yaml:62"      # "Never unwrap() in prod; use expect()"
```

## Problem Statement

The codebase has 100+ instances of `.unwrap_or()`, `.unwrap_or_else()`, and similar patterns that silently return default values instead of surfacing errors. This masks failures and produces incorrect results.

### Examples of Problematic Code

```rust
// Silent fallback - ERROR IS HIDDEN
let entropy = status.get("entropy")
    .and_then(|v| v.as_f64())
    .unwrap_or(0.5);  // If parsing fails, pretend entropy is 0.5

// Silent default - FAILURE NOT REPORTED
let embedding = generate_embedding(content).unwrap_or(vec![0.1; 1536]);

// Health check always passes
fn health_check() -> bool {
    true  // Never actually checks anything
}
```

### Desired Pattern

```rust
// Fail-fast - ERROR IS SURFACED
let entropy = status.get("entropy")
    .and_then(|v| v.as_f64())
    .ok_or_else(|| CoreError::MissingField("entropy"))?;

// Fail-fast - CALLER HANDLES ERROR
let embedding = generate_embedding(content)?;

// Real health check
fn health_check(&self) -> CoreResult<HealthStatus> {
    let store_ok = self.store.ping().await?;
    let index_ok = self.index.ping().await?;
    Ok(HealthStatus { store_ok, index_ok })
}
```

## Context

Silent fallbacks were introduced during rapid prototyping but violate the constitution's coding rules. They cause:
1. Incorrect search results (0.5 similarity for all)
2. Meaningless UTL metrics (all zeros)
3. False positive health checks
4. Debugging nightmares (errors never reported)

## Input Context Files

```
crates/context-graph-mcp/src/handlers/*.rs       # Main handlers
crates/context-graph-mcp/src/server.rs           # Server setup
crates/context-graph-core/src/stubs/*.rs         # Stub implementations
```

## Prerequisites

- [ ] None - this task can start immediately

## Scope

### In Scope

- Audit all `.unwrap_or()` patterns in handlers/
- Replace with proper `?` propagation or explicit errors
- Add `CoreError` variants for common failure cases
- Implement real health checks
- Add error logging for all failure paths

### Out of Scope

- Test code can keep `.unwrap()` for assertions
- Configuration defaults are acceptable (documented)

## Definition of Done

### Error Types to Add

```rust
// File: crates/context-graph-core/src/error.rs (additions)
#[derive(Debug, thiserror::Error)]
pub enum CoreError {
    // Existing errors...

    // NEW: Field access errors
    #[error("Missing required field: {0}")]
    MissingField(String),

    #[error("Invalid field type for {field}: expected {expected}, got {actual}")]
    InvalidFieldType {
        field: String,
        expected: String,
        actual: String,
    },

    // NEW: Component health errors
    #[error("Component unhealthy: {component}: {reason}")]
    ComponentUnhealthy {
        component: String,
        reason: String,
    },

    // NEW: Initialization errors
    #[error("Failed to initialize {component}: {reason}")]
    InitializationFailed {
        component: String,
        reason: String,
    },
}
```

### Constraints

- MUST NOT break existing API contracts
- Errors MUST be informative (include context)
- MUST log errors before returning
- Health checks MUST verify real functionality
- Migration can be incremental (per file)

### Verification

```bash
# 1. Count remaining unwrap_or patterns
grep -r "unwrap_or" crates/context-graph-mcp/src/*.rs --include="*.rs" | grep -v test | wc -l
# Target: < 10 (down from 100+)

# 2. Verify no silent defaults in handlers
grep -r "unwrap_or(0\." crates/context-graph-mcp/src/handlers/*.rs
# Target: 0 results

# 3. Run tests - some may fail initially (that's expected!)
cargo test -p context-graph-mcp
```

## Audit Checklist

### handlers/tools.rs

| Line | Pattern | Action |
|------|---------|--------|
| Various | `.unwrap_or(0.5)` for UTL values | Replace with `?` propagation |
| Various | `.unwrap_or("unknown")` for strings | Replace with explicit error |
| ~230, ~273 | `vec![0.1; 1536]` fallback | REMOVE - handled by M06-T10 |

### handlers/memory.rs

| Line | Pattern | Action |
|------|---------|--------|
| Various | Silent embedding fallback | Remove, propagate error |

### server.rs

| Line | Pattern | Action |
|------|---------|--------|
| ~100+ | Health check always true | Implement real checks |

### stubs/*.rs

| File | Pattern | Action |
|------|---------|--------|
| All stubs | Silent defaults | Add #[cfg(feature = "stub")] gate |

## Pseudo Code

```
Before (WRONG):
  let entropy = status.get("entropy")
      .and_then(|v| v.as_f64())
      .unwrap_or(0.5);

After (CORRECT):
  let entropy = status.get("entropy")
      .ok_or_else(|| CoreError::MissingField("entropy".into()))?
      .as_f64()
      .ok_or_else(|| CoreError::InvalidFieldType {
          field: "entropy".into(),
          expected: "f64".into(),
          actual: format!("{:?}", status.get("entropy")),
      })?;

  # Or with helper:
  let entropy = extract_f64(&status, "entropy")?;


Helper function:
  fn extract_f64(obj: &serde_json::Value, field: &str) -> CoreResult<f64> {
      obj.get(field)
          .ok_or_else(|| CoreError::MissingField(field.into()))?
          .as_f64()
          .ok_or_else(|| CoreError::InvalidFieldType {
              field: field.into(),
              expected: "f64".into(),
              actual: "non-numeric".into(),
          })
  }


Real health check:
  impl Handlers {
      pub async fn health_check(&self) -> CoreResult<HealthStatus> {
          // Actually verify components
          let store_ping = timeout(Duration::from_secs(1), async {
              self.memory_store.node_count()
          }).await.map_err(|_| CoreError::ComponentUnhealthy {
              component: "memory_store".into(),
              reason: "ping timeout".into(),
          })?;

          let utl_ping = {
              let status = self.utl_processor.get_status();
              status.get("lifecycle_phase").is_some()
          };

          if !utl_ping {
              return Err(CoreError::ComponentUnhealthy {
                  component: "utl_processor".into(),
                  reason: "get_status() returned invalid response".into(),
              });
          }

          Ok(HealthStatus {
              store_nodes: store_ping,
              utl_ready: utl_ping,
              timestamp: Utc::now(),
          })
      }
  }
```

## Files to Modify

| File | Change |
|------|--------|
| `crates/context-graph-core/src/error.rs` | Add new error variants |
| `crates/context-graph-mcp/src/handlers/tools.rs` | Replace unwrap_or patterns |
| `crates/context-graph-mcp/src/handlers/memory.rs` | Replace unwrap_or patterns |
| `crates/context-graph-mcp/src/server.rs` | Real health checks |
| `crates/context-graph-core/src/lib.rs` | Add helper extraction functions |

## Files to Create

| File | Description |
|------|-------------|
| `crates/context-graph-core/src/utils/extract.rs` | Safe field extraction helpers |

## Validation Criteria

- [ ] `grep -c "unwrap_or" src/handlers/` returns < 10
- [ ] No `.unwrap_or(0.` patterns remain in handlers
- [ ] Health check actually verifies components
- [ ] All error paths log before returning
- [ ] Tests updated to expect errors where appropriate

## Test Commands

```bash
# Audit unwrap_or usage
grep -r "unwrap_or" crates/context-graph-mcp/src/ --include="*.rs" | grep -v test | wc -l

# Run tests (some may need updating)
cargo test -p context-graph-mcp 2>&1 | head -50

# Verify error types exist
grep -n "MissingField\|InvalidFieldType" crates/context-graph-core/src/error.rs
```

---

*Task created: 2026-01-04*
*Module: 06 - Stub Elimination*
*Layer: Logic*
*Priority: HIGH*
