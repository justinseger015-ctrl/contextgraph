# M06-T11: Create Integration Tests with Real Data

```yaml
metadata:
  id: "M06-T11"
  title: "Create Integration Tests with Real Data"
  module: "module-06"
  module_name: "Stub Elimination"
  layer: "surface"
  priority: "high"
  estimated_hours: 8
  created: "2026-01-04"
  status: "blocked"
  dependencies:
    - "M06-T10"  # MCP server wiring
  spec_refs:
    - "constitution.yaml:134-146"  # Testing requirements
```

## Problem Statement

All existing tests use `StubUtlProcessor` and `InMemoryStore`. We need integration tests that verify the system works with real implementations.

## Context

Integration tests should verify:
1. Real embeddings are generated (not `vec![0.1; 1536]`)
2. Real similarity search works (not always 0.5)
3. Real UTL metrics are computed (not hash-based)
4. Persistent storage survives restarts
5. Full MCP protocol works end-to-end

## Input Context Files

```
crates/context-graph-mcp/src/handlers/tests/   # Existing tests (use stubs)
tests/                                          # Integration test directory
```

## Prerequisites

- [ ] M06-T10 complete (real implementations wired)

## Scope

### In Scope

- Create integration test suite in `tests/integration/`
- Test real embedding generation
- Test real similarity search
- Test real UTL computation
- Test persistence across restarts
- End-to-end MCP protocol tests

### Out of Scope

- Performance benchmarks (separate task)
- Chaos testing (separate task)
- Load testing (separate task)

## Definition of Done

### Test Cases

```rust
// File: tests/integration/real_implementations.rs

#[tokio::test]
#[ignore = "requires real model weights"]
async fn test_real_embedding_generation() {
    let config = ServerConfig::test_real();
    let handlers = Handlers::with_config(config).await.unwrap();

    // Embed two different texts
    let result1 = embed_via_mcp(&handlers, "The quick brown fox").await;
    let result2 = embed_via_mcp(&handlers, "A lazy dog sleeps").await;

    // Verify embeddings are different
    assert_ne!(result1.vector, result2.vector);

    // Verify embeddings are normalized
    let magnitude: f32 = result1.vector.iter().map(|x| x * x).sum::<f32>().sqrt();
    assert!((magnitude - 1.0).abs() < 0.01);

    // Verify NOT the fake embedding
    assert_ne!(result1.vector, vec![0.1; 1536]);
    assert_ne!(result1.vector, vec![0.1; 384]);
}

#[tokio::test]
#[ignore = "requires rocksdb"]
async fn test_real_similarity_search() {
    let config = ServerConfig::test_real();
    let handlers = Handlers::with_config(config).await.unwrap();

    // Store nodes with real embeddings
    store_memory(&handlers, "Rust programming language").await;
    store_memory(&handlers, "Python programming language").await;
    store_memory(&handlers, "Recipe for chocolate cake").await;

    // Search for programming
    let results = search_graph(&handlers, "coding languages", 3).await;

    // Programming results should be more similar than cake recipe
    assert!(results[0].similarity > results[2].similarity);
    assert!(results[0].node.content.contains("programming"));

    // Similarity should NOT be hardcoded 0.5
    assert_ne!(results[0].similarity, 0.5);
    assert_ne!(results[1].similarity, 0.5);
}

#[tokio::test]
#[ignore = "requires full stack"]
async fn test_real_utl_computation() {
    let config = ServerConfig::test_real();
    let handlers = Handlers::with_config(config).await.unwrap();

    // Get status with real UTL processor
    let status = get_memetic_status(&handlers).await;

    // Verify values are in valid ranges
    assert!((0.0..=1.0).contains(&status.entropy));
    assert!((0.0..=1.0).contains(&status.coherence));
    assert!((0.0..=1.0).contains(&status.learning_score));

    // Verify NOT hardcoded zeros (from stub)
    // Note: real processor may legitimately return 0, so we test multiple calls
    store_memory(&handlers, "New information for UTL").await;
    let status2 = get_memetic_status(&handlers).await;

    // After storing new info, entropy should change
    // (This is a weak test but catches obvious stub behavior)
}

#[tokio::test]
#[ignore = "requires persistent storage"]
async fn test_persistence_across_restart() {
    let temp_dir = tempfile::tempdir().unwrap();
    let config = ServerConfig::test_real_with_path(temp_dir.path());

    // First session: store data
    {
        let handlers = Handlers::with_config(config.clone()).await.unwrap();
        store_memory(&handlers, "Persistent test content").await;
        assert_eq!(handlers.memory_store.node_count(), 1);
    }

    // Second session: data should still be there
    {
        let handlers = Handlers::with_config(config.clone()).await.unwrap();
        assert_eq!(handlers.memory_store.node_count(), 1);

        let results = search_graph(&handlers, "persistent", 1).await;
        assert!(!results.is_empty());
        assert!(results[0].node.content.contains("Persistent test content"));
    }
}

#[tokio::test]
#[ignore = "requires full stack"]
async fn test_mcp_protocol_end_to_end() {
    let config = ServerConfig::test_real();
    let handlers = Handlers::with_config(config).await.unwrap();

    // Full MCP request/response cycle
    let request = json!({
        "jsonrpc": "2.0",
        "id": 1,
        "method": "tools/call",
        "params": {
            "name": "store_memory",
            "arguments": {"content": "E2E test content"}
        }
    });

    let response = handlers.dispatch(request).await;
    assert!(response.result.is_some());
    assert!(response.error.is_none());

    // Verify cognitive pulse is included
    let result = response.result.unwrap();
    assert!(result.get("_cognitive_pulse").is_some());

    // Verify content was actually stored
    let search_request = json!({
        "jsonrpc": "2.0",
        "id": 2,
        "method": "tools/call",
        "params": {
            "name": "search_graph",
            "arguments": {"query": "E2E test"}
        }
    });

    let search_response = handlers.dispatch(search_request).await;
    let search_result = search_response.result.unwrap();
    // Should find our stored content
}
```

### Constraints

- Integration tests MUST be marked `#[ignore]` by default (require resources)
- Tests MUST clean up after themselves (temp directories)
- Tests MUST NOT depend on external services (API keys)
- Tests MUST document resource requirements

### Verification

```bash
# Run integration tests (requires resources)
cargo test -p context-graph-mcp --features real --test integration -- --ignored

# Run quick unit tests (no resources needed)
cargo test -p context-graph-mcp
```

## Pseudo Code

```
Helper functions for integration tests:

  async fn store_memory(handlers: &Handlers, content: &str) -> Uuid {
    let request = make_request("tools/call", json!({
      "name": "store_memory",
      "arguments": {"content": content}
    }));
    let response = handlers.dispatch(request).await;
    let result = response.result.unwrap();
    result["id"].as_str().unwrap().parse().unwrap()
  }

  async fn search_graph(handlers: &Handlers, query: &str, top_k: usize) -> Vec<SearchResult> {
    let request = make_request("tools/call", json!({
      "name": "search_graph",
      "arguments": {"query": query, "top_k": top_k}
    }));
    let response = handlers.dispatch(request).await;
    let result = response.result.unwrap();
    parse_search_results(result)
  }

  async fn get_memetic_status(handlers: &Handlers) -> MemeticStatus {
    let request = make_request("tools/call", json!({
      "name": "get_memetic_status",
      "arguments": {}
    }));
    let response = handlers.dispatch(request).await;
    parse_memetic_status(response.result.unwrap())
  }

  impl ServerConfig {
    fn test_real() -> Self {
      Self {
        storage: StorageConfig {
          backend: StorageBackend::RocksDB,
          path: tempfile::tempdir().unwrap().path().into(),
        },
        embedding: EmbeddingConfig {
          provider: EmbeddingProviderType::Candle,
          model_id: "sentence-transformers/all-MiniLM-L6-v2".into(),
          device: DeviceConfig::Cpu,  // CPU for tests
        },
        ..Default::default()
      }
    }
  }
```

## Files to Create

| File | Description |
|------|-------------|
| `tests/integration/mod.rs` | Integration test module |
| `tests/integration/real_implementations.rs` | Real implementation tests |
| `tests/integration/persistence.rs` | Persistence tests |
| `tests/integration/helpers.rs` | Test helper functions |

## Files to Modify

| File | Change |
|------|--------|
| `Cargo.toml` (workspace) | Add integration test config |

## Validation Criteria

- [ ] All integration tests pass with `--ignored` flag
- [ ] Tests verify real (not stub) behavior
- [ ] Tests clean up temp files/directories
- [ ] Tests document resource requirements
- [ ] CI can run tests with appropriate resources

## Test Commands

```bash
# Run all integration tests
cargo test --test integration -- --ignored

# Run specific test
cargo test --test integration test_real_embedding_generation -- --ignored

# Run with verbose output
cargo test --test integration -- --ignored --nocapture
```

---

*Task created: 2026-01-04*
*Module: 06 - Stub Elimination*
*Layer: Surface*
*Priority: HIGH*
