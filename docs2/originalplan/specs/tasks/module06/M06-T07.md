# M06-T07: Implement Real SensingLayer (L1)

```yaml
metadata:
  id: "M06-T07"
  title: "Implement Real SensingLayer (L1)"
  module: "module-06"
  module_name: "Stub Elimination"
  layer: "logic"
  priority: "high"
  estimated_hours: 6
  created: "2026-01-04"
  status: "blocked"
  dependencies:
    - "M06-T04"  # CandleEmbeddingProvider (for embedding generation)
  spec_refs:
    - "constitution.yaml:190"   # L1_Sensing specs
    - "contextprd.md:68"        # L1 Sensing/tokenize
```

## Problem Statement

The `StubSensingLayer` returns fake data. L1 is critical as the entry point for all input processing.

### Current State (BROKEN)

```rust
// stubs/layers_stub.rs
impl NervousLayer for StubSensingLayer {
    async fn process(&self, input: LayerInput) -> CoreResult<LayerOutput> {
        // Returns fake processed data
        Ok(LayerOutput {
            data: input.data,  // Just passes through
            metrics: LayerMetrics::default(),  // Zeros
        })
    }
}
```

## Context

L1 Sensing Layer responsibilities (from constitution):
- 12-model embedding generation
- PII scrubbing
- Adversarial detection
- UTL Î”S (entropy) measurement
- Latency target: <5ms

## Input Context Files

```
crates/context-graph-core/src/traits/nervous_layer.rs   # Layer trait
crates/context-graph-core/src/stubs/layers_stub.rs      # Stub reference
crates/context-graph-core/src/traits/embedding_provider.rs # From M06-T02
```

## Prerequisites

- [ ] M06-T04 complete (CandleEmbeddingProvider)
- [ ] `NervousLayer` trait defined
- [ ] PII patterns defined

## Scope

### In Scope

- Implement `SensingLayer` with real embedding generation
- PII detection and redaction (regex-based patterns)
- Basic adversarial pattern detection
- Entropy measurement for UTL
- Performance metrics collection

### Out of Scope

- Full 12-model fusion (future module)
- ML-based NER for PII (future)
- Advanced adversarial defense (future)

## Definition of Done

### Signatures

```rust
// File: crates/context-graph-core/src/layers/sensing.rs
use crate::traits::{NervousLayer, LayerInput, LayerOutput, LayerMetrics};
use crate::traits::EmbeddingProvider;
use std::sync::Arc;

/// L1 Sensing Layer - Input processing and embedding
pub struct SensingLayer {
    embedding_provider: Arc<dyn EmbeddingProvider>,
    pii_scrubber: PiiScrubber,
    adversarial_detector: AdversarialDetector,
    config: SensingConfig,
}

#[derive(Debug, Clone)]
pub struct SensingConfig {
    pub scrub_pii: bool,
    pub detect_adversarial: bool,
    pub measure_entropy: bool,
    pub max_content_length: usize,
}

#[derive(Debug, Clone)]
pub struct PiiScrubber {
    patterns: Vec<(Regex, String)>,  // (pattern, replacement)
}

#[derive(Debug, Clone)]
pub struct AdversarialDetector {
    patterns: Vec<Regex>,
}

impl SensingLayer {
    pub fn new(
        embedding_provider: Arc<dyn EmbeddingProvider>,
        config: SensingConfig,
    ) -> Self;
}

#[async_trait]
impl NervousLayer for SensingLayer {
    async fn process(&self, input: LayerInput) -> CoreResult<LayerOutput>;
    fn layer_id(&self) -> &str;  // "L1_Sensing"
    fn latency_budget_ms(&self) -> f64;  // 5.0
}
```

### Constraints

- Latency budget: <5ms total
- MUST scrub PII before embedding (SEC-02)
- MUST detect adversarial patterns (SEC-04)
- Entropy calculation MUST be real (not random)
- MUST NOT block on slow embedding (timeout)

### Verification

```bash
# 1. Compile
cargo build -p context-graph-core

# 2. Unit tests
cargo test -p context-graph-core sensing_layer

# 3. PII scrubbing test
cargo test -p context-graph-core test_sensing_scrubs_pii

# 4. Latency test
cargo test -p context-graph-core test_sensing_under_5ms
```

## Pseudo Code

```
SensingLayer:

  new(embedding_provider, config):
    pii_scrubber = PiiScrubber::with_default_patterns()
    adversarial_detector = AdversarialDetector::with_default_patterns()
    return Self { embedding_provider, pii_scrubber, adversarial_detector, config }

  async process(input):
    start = Instant::now()
    content = input.content

    # Step 1: PII Scrubbing (<1ms)
    if self.config.scrub_pii:
      content = self.pii_scrubber.scrub(content)

    # Step 2: Adversarial Detection (<0.5ms)
    if self.config.detect_adversarial:
      if self.adversarial_detector.detect(content):
        return Err(AdversarialInputDetected)

    # Step 3: Truncate if needed
    if content.len() > self.config.max_content_length:
      content = content[..self.config.max_content_length]

    # Step 4: Generate Embedding (<3ms target)
    embedding_result = self.embedding_provider.embed(&content).await?

    # Step 5: Measure Entropy
    entropy = compute_embedding_entropy(&embedding_result.vector)

    return LayerOutput {
      data: ProcessedData {
        original_content: input.content,
        processed_content: content,
        embedding: embedding_result.vector,
        pii_redacted: content != input.content,
      },
      metrics: LayerMetrics {
        latency_ms: start.elapsed().as_secs_f64() * 1000.0,
        entropy,
        success: true,
      },
    }

PiiScrubber:

  with_default_patterns():
    patterns = [
      (r"[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}", "[EMAIL_REDACTED]"),
      (r"\b\d{3}-\d{2}-\d{4}\b", "[SSN_REDACTED]"),
      (r"\b\d{4}[- ]?\d{4}[- ]?\d{4}[- ]?\d{4}\b", "[CARD_REDACTED]"),
      (r"\b(password|api_key|secret|token)\s*[:=]\s*\S+", "[CREDENTIAL_REDACTED]"),
      (r"Bearer\s+[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+", "[JWT_REDACTED]"),
    ]
    return Self { patterns: patterns.into_iter().map(compile).collect() }

  scrub(content):
    result = content
    for (pattern, replacement) in self.patterns:
      result = pattern.replace_all(&result, replacement)
    return result

AdversarialDetector:

  with_default_patterns():
    # From SEC-04 in constitution
    patterns = [
      r"(?i)ignore\s+(previous|all|prior)",
      r"(?i)disregard\s+(system|instructions)",
      r"(?i)you\s+are\s+now",
      r"(?i)new\s+instructions:",
      r"(?i)override:",
    ]
    return Self { patterns: patterns.into_iter().map(compile).collect() }

  detect(content):
    for pattern in self.patterns:
      if pattern.is_match(content):
        return true
    return false
```

## Files to Create

| File | Description |
|------|-------------|
| `crates/context-graph-core/src/layers/mod.rs` | Layers module |
| `crates/context-graph-core/src/layers/sensing.rs` | L1 SensingLayer |
| `crates/context-graph-core/src/layers/pii.rs` | PII scrubbing utilities |
| `crates/context-graph-core/src/layers/adversarial.rs` | Adversarial detection |

## Files to Modify

| File | Change |
|------|--------|
| `crates/context-graph-core/src/lib.rs` | Add `pub mod layers;` |

## Validation Criteria

- [ ] Generates real embeddings via provider
- [ ] Scrubs PII patterns (email, SSN, credit card)
- [ ] Detects adversarial patterns
- [ ] Computes real entropy
- [ ] Latency <5ms average
- [ ] Thread-safe for concurrent use

## Test Commands

```bash
# Run layer tests
cargo test -p context-graph-core layers::sensing

# PII test
cargo test -p context-graph-core test_pii_scrubbing

# Adversarial test
cargo test -p context-graph-core test_adversarial_detection

# Latency benchmark
cargo bench -p context-graph-core sensing_latency
```

---

*Task created: 2026-01-04*
*Module: 06 - Stub Elimination*
*Layer: Logic*
*Priority: HIGH*
