# M05-T38: Integrate UTL Computation into inject_context MCP Tool

```yaml
task_id: "M05-T38"
title: "Integrate UTL Computation into inject_context MCP Tool"
module: "module-05"
layer: "integration"
priority: "critical"
estimated_hours: 4
status: "pending"
created: "2026-01-04"
updated: "2026-01-04"
```

---

## Description

Integrate UTL computation into the primary inject_context MCP tool. inject_context is the PRIMARY retrieval mechanism per PRD Section 3.1.

Algorithm:
1. Before retrieval, compute current UTL state (delta_s, delta_c from context)
2. Use Johari quadrant to adjust retrieval strategy (search depth, k)
3. Include UTL metrics in response (utl_metrics field)
4. Add conflict_alert field for semantic conflict detection
5. Add tool_gating_warning when entropy > 0.8

Response schema: `{ context, utl_metrics, conflict_alert, tool_gating_warning }`

Performance target: UTL overhead <5ms on top of base retrieval.

---

## File Paths

| Type | Path |
|------|------|
| Implementation | `crates/context-graph-mcp/src/tools/inject_context.rs` |
| Test | `crates/context-graph-mcp/tests/inject_context_utl_tests.rs` |

---

## Dependencies

| Task ID | Title | Status |
|---------|-------|--------|
| M05-T22 | UtlProcessor Main Orchestrator | pending |
| M05-T26 | utl_status MCP Tool | pending |
| M05-T18 | JohariClassifier with Retrieval Strategies | pending |

---

## Acceptance Criteria

- [ ] inject_context computes UTL state before retrieval
- [ ] Retrieval strategy varies by Johari quadrant
- [ ] Response includes utl_metrics with entropy/coherence/learning_score
- [ ] tool_gating_warning present when entropy > 0.8
- [ ] conflict_alert populated when contradictions detected
- [ ] UTL computation overhead <5ms
- [ ] Backward compatible with existing inject_context clients

---

## Specification References

- PRD Section 3.1 (inject_context)
- constitution.yaml mcp section
- SPEC-UTL-005 Section 10

---

## Technical Notes

### inject_context is PRIMARY

Per PRD Section 3.1, `inject_context` is the primary tool for memory retrieval. All other retrieval tools are secondary. This task makes inject_context UTL-aware to provide:
- Adaptive retrieval depth based on cognitive state
- Early warning for high-entropy situations
- Conflict detection for semantic contradictions

### Enhanced Response Schema

```rust
#[derive(Debug, Serialize, Deserialize)]
pub struct InjectContextResponse {
    /// The retrieved context (existing field)
    pub context: Vec<ContextItem>,

    /// UTL metrics for the current cognitive state (NEW)
    pub utl_metrics: UtlMetrics,

    /// Alert when semantic conflicts detected (NEW)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub conflict_alert: Option<ConflictAlert>,

    /// Warning when entropy is critically high (NEW)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tool_gating_warning: Option<ToolGatingWarning>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct UtlMetrics {
    /// Current entropy (surprise) level [0, 1]
    pub entropy: f32,
    /// Current coherence level [0, 1]
    pub coherence: f32,
    /// Computed learning score [0, 1]
    pub learning_score: f32,
    /// Current Johari quadrant
    pub quadrant: JohariQuadrant,
    /// Suggested action based on state
    pub suggested_action: SuggestedAction,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ConflictAlert {
    /// Conflicting node IDs
    pub conflicting_nodes: Vec<Uuid>,
    /// Description of the conflict
    pub description: String,
    /// Confidence of conflict detection [0, 1]
    pub confidence: f32,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ToolGatingWarning {
    /// Current entropy level
    pub entropy: f32,
    /// Threshold that was exceeded
    pub threshold: f32,
    /// Recommended action
    pub recommendation: String,
}
```

### Quadrant-Based Retrieval Strategy

| Quadrant | Search Depth | Max Results | Strategy Notes |
|----------|-------------|-------------|----------------|
| Open | 1 | 5 | Shallow search, high confidence |
| Hidden | 2 | 10 | Include recent temporal context |
| Blind | 2 | 15 | Broader semantic search |
| Unknown | 4 | 30 | Deep exploration, include causal paths |

```rust
fn get_retrieval_strategy(quadrant: JohariQuadrant) -> RetrievalStrategy {
    match quadrant {
        JohariQuadrant::Open => RetrievalStrategy {
            search_depth: 1,
            max_results: 5,
            include_neighbors: false,
            confidence_threshold: 0.8,
        },
        JohariQuadrant::Hidden => RetrievalStrategy {
            search_depth: 2,
            max_results: 10,
            include_neighbors: true,
            confidence_threshold: 0.6,
        },
        JohariQuadrant::Blind => RetrievalStrategy {
            search_depth: 2,
            max_results: 15,
            include_neighbors: true,
            confidence_threshold: 0.5,
        },
        JohariQuadrant::Unknown => RetrievalStrategy {
            search_depth: 4,
            max_results: 30,
            include_neighbors: true,
            confidence_threshold: 0.3,
        },
    }
}
```

### Implementation Flow

```rust
pub async fn inject_context(
    request: InjectContextRequest,
    utl_processor: &UtlProcessor,
    graph: &KnowledgeGraph,
) -> Result<InjectContextResponse, McpError> {
    let start = Instant::now();

    // 1. Compute current UTL state BEFORE retrieval
    let embedding = embed_query(&request.query).await?;
    let context_embeddings = get_session_context_embeddings(&request.session_id)?;
    let learning_signal = utl_processor.compute_learning(
        &request.query,
        &embedding,
        &context_embeddings,
    )?;

    // 2. Get retrieval strategy based on Johari quadrant
    let strategy = get_retrieval_strategy(learning_signal.quadrant);

    // 3. Execute retrieval with adaptive strategy
    let context = graph.search_with_strategy(
        &embedding,
        &strategy,
    ).await?;

    // 4. Check for conflicts
    let conflict_alert = detect_conflicts(&context, &embedding, graph)?;

    // 5. Check entropy threshold for tool gating
    let tool_gating_warning = if learning_signal.delta_s > 0.8 {
        Some(ToolGatingWarning {
            entropy: learning_signal.delta_s,
            threshold: 0.8,
            recommendation: "High uncertainty detected. Consider clarifying query or processing curation tasks.".to_string(),
        })
    } else {
        None
    };

    // 6. Build response with UTL metrics
    let utl_overhead_us = start.elapsed().as_micros() as u64;
    assert!(utl_overhead_us < 5000, "UTL overhead exceeded 5ms target");

    Ok(InjectContextResponse {
        context,
        utl_metrics: UtlMetrics {
            entropy: learning_signal.delta_s,
            coherence: learning_signal.delta_c,
            learning_score: learning_signal.magnitude,
            quadrant: learning_signal.quadrant,
            suggested_action: learning_signal.suggested_action,
        },
        conflict_alert,
        tool_gating_warning,
    })
}
```

### Backward Compatibility

Existing clients that don't expect the new fields should still work:
- `utl_metrics`, `conflict_alert`, `tool_gating_warning` are new fields
- Old clients will ignore them (JSON parsers typically skip unknown fields)
- The `context` field remains in the same position and format
- Consider adding a `version` field or API versioning if needed

### Performance Budget

Total inject_context latency budget: ~50ms

| Component | Target | Notes |
|-----------|--------|-------|
| Embedding generation | 15ms | Existing |
| Graph search | 25ms | Existing |
| UTL computation | 5ms | NEW - strict limit |
| Response formatting | 2ms | Existing |

---

## Implementation Checklist

1. [ ] Review existing inject_context implementation
2. [ ] Add UtlProcessor dependency to inject_context handler
3. [ ] Implement UTL state computation before retrieval
4. [ ] Implement quadrant-based retrieval strategy selection
5. [ ] Add UtlMetrics struct and population
6. [ ] Implement conflict detection and ConflictAlert
7. [ ] Implement tool_gating_warning for high entropy
8. [ ] Add performance instrumentation (tracing spans)
9. [ ] Verify backward compatibility with existing clients
10. [ ] Benchmark UTL overhead (< 5ms target)
11. [ ] Write integration tests for new fields
12. [ ] Write tests for each Johari quadrant behavior
13. [ ] Write tests for conflict alert generation
14. [ ] Write tests for tool gating warning

---

## Test Cases

### Unit Tests

```rust
#[tokio::test]
async fn test_inject_context_includes_utl_metrics() {
    let response = inject_context(request, &utl_processor, &graph).await.unwrap();

    assert!(response.utl_metrics.entropy >= 0.0 && response.utl_metrics.entropy <= 1.0);
    assert!(response.utl_metrics.coherence >= 0.0 && response.utl_metrics.coherence <= 1.0);
}

#[tokio::test]
async fn test_open_quadrant_shallow_search() {
    // Setup: UTL in Open quadrant (low entropy, high coherence)
    let response = inject_context(request, &utl_processor, &graph).await.unwrap();

    // Should return fewer results with shallow search
    assert!(response.context.len() <= 5);
}

#[tokio::test]
async fn test_unknown_quadrant_deep_search() {
    // Setup: UTL in Unknown quadrant (high entropy, high coherence)
    let response = inject_context(request, &utl_processor, &graph).await.unwrap();

    // Should return more results with deep search
    assert!(response.context.len() <= 30);
    assert!(response.context.len() > 5);
}

#[tokio::test]
async fn test_tool_gating_warning_high_entropy() {
    // Setup: Force high entropy state (> 0.8)
    let response = inject_context(request, &utl_processor, &graph).await.unwrap();

    assert!(response.tool_gating_warning.is_some());
    let warning = response.tool_gating_warning.unwrap();
    assert!(warning.entropy > 0.8);
}

#[tokio::test]
async fn test_conflict_alert_on_contradiction() {
    // Setup: Graph with contradicting nodes
    let response = inject_context(request, &utl_processor, &graph).await.unwrap();

    assert!(response.conflict_alert.is_some());
    let alert = response.conflict_alert.unwrap();
    assert!(!alert.conflicting_nodes.is_empty());
}

#[tokio::test]
async fn test_utl_overhead_under_5ms() {
    let start = Instant::now();
    let _ = inject_context(request, &utl_processor, &graph).await.unwrap();
    let elapsed = start.elapsed();

    // UTL portion should be < 5ms of total
    // (This is approximate; actual measurement in implementation)
    assert!(elapsed.as_millis() < 60); // Total with some margin
}

#[tokio::test]
async fn test_backward_compatibility() {
    let response = inject_context(request, &utl_processor, &graph).await.unwrap();

    // Old clients only care about context field
    assert!(!response.context.is_empty());

    // JSON serialization should work
    let json = serde_json::to_string(&response).unwrap();
    assert!(json.contains("context"));
}
```

---

*Module: 05 - UTL Integration*
*Task: 38 of 57*
*Layer: Integration*
*Priority: CRITICAL*
