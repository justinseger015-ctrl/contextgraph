# M05-T53: Implement UTL-Aware search_graph Integration

## Task Metadata
- **ID**: M05-T53
- **Title**: Implement UTL-Aware search_graph Integration
- **Module**: 05 - UTL Integration
- **Layer**: completion
- **Priority**: medium
- **Estimated Hours**: 2.5

## Description

Integrate UTL state into search_graph MCP tool per PRD Section 4.2.
search_graph should use Johari quadrant-based strategies:
- Open quadrant: Standard top-k search, shallow depth
- Blind quadrant: Broader search, include distant neighbors
- Hidden quadrant: Focus on recent/temporal results
- Unknown quadrant: Deep search, include causal paths

Add search_hints parameter based on current UTL state.
Include utl_context in search results for transparency.

## File Path

`crates/context-graph-mcp/src/tools/search_graph.rs`

## Dependencies

| Task ID | Task Title | Status |
|---------|------------|--------|
| M05-T18 | JohariClassifier | pending |
| M05-T22 | UtlProcessor Orchestrator | pending |

## Acceptance Criteria

- [ ] search_graph uses Johari quadrant for strategy
- [ ] Search depth varies by quadrant
- [ ] Results include utl_context field
- [ ] Backward compatible with existing queries
- [ ] Performance impact < 2ms

## Test File

`crates/context-graph-mcp/tests/search_graph_utl_tests.rs`

## Specification References

- PRD Section 4.2 (search_graph)
- SPEC-UTL-005 Section 7

## Implementation Notes

### Johari-Based Search Strategies

```rust
use context_graph_utl::JohariQuadrant;

/// Search strategy derived from Johari quadrant classification.
#[derive(Debug, Clone)]
pub struct JohariSearchStrategy {
    /// Maximum search depth
    pub max_depth: usize,
    /// Number of results to return
    pub top_k: usize,
    /// Include temporal weighting
    pub temporal_weight: f32,
    /// Include causal path exploration
    pub explore_causal: bool,
    /// Similarity threshold for inclusion
    pub similarity_threshold: f32,
    /// Search strategy description for transparency
    pub strategy_description: String,
}

impl JohariSearchStrategy {
    /// Derive search strategy from Johari quadrant.
    pub fn from_quadrant(quadrant: JohariQuadrant) -> Self {
        match quadrant {
            JohariQuadrant::Open => Self {
                // High confidence: standard efficient search
                max_depth: 2,
                top_k: 10,
                temporal_weight: 0.0,
                explore_causal: false,
                similarity_threshold: 0.7,
                strategy_description: "Standard top-k search (high confidence)".into(),
            },
            JohariQuadrant::Blind => Self {
                // Uncertain: broader exploration
                max_depth: 4,
                top_k: 20,
                temporal_weight: 0.2,
                explore_causal: false,
                similarity_threshold: 0.5,
                strategy_description: "Broad search with distant neighbors (uncertain state)".into(),
            },
            JohariQuadrant::Hidden => Self {
                // Stale knowledge: focus on recent
                max_depth: 2,
                top_k: 15,
                temporal_weight: 0.8,
                explore_causal: false,
                similarity_threshold: 0.6,
                strategy_description: "Temporal-weighted search (stale knowledge refresh)".into(),
            },
            JohariQuadrant::Unknown => Self {
                // Novel context: deep exploration
                max_depth: 6,
                top_k: 25,
                temporal_weight: 0.3,
                explore_causal: true,
                similarity_threshold: 0.4,
                strategy_description: "Deep search with causal paths (novel context)".into(),
            },
        }
    }
}
```

### UTL Context in Results

```rust
/// UTL context included in search results for transparency.
#[derive(Debug, Clone, serde::Serialize)]
pub struct UtlSearchContext {
    /// Current Johari quadrant that influenced search
    pub quadrant: JohariQuadrant,
    /// Search strategy used
    pub strategy: String,
    /// Current learning magnitude
    pub learning_magnitude: f32,
    /// Current coherence level
    pub coherence: f32,
    /// Whether UTL influenced this search
    pub utl_influenced: bool,
}

/// Extended search result with UTL context.
#[derive(Debug, Clone, serde::Serialize)]
pub struct UtlAwareSearchResult {
    /// Standard search results
    pub results: Vec<SearchResult>,
    /// UTL context for transparency
    pub utl_context: UtlSearchContext,
    /// Search latency in milliseconds
    pub latency_ms: f32,
}
```

### search_graph Tool Enhancement

```rust
use context_graph_utl::{UtlProcessor, JohariClassifier};

/// Enhanced search_graph with UTL awareness.
pub async fn search_graph(
    request: SearchGraphRequest,
    graph: &KnowledgeGraph,
    utl_processor: Option<&UtlProcessor>,
) -> Result<UtlAwareSearchResult, SearchError> {
    let start = std::time::Instant::now();

    // Get UTL-derived search strategy if processor available
    let (strategy, utl_context) = if let Some(processor) = utl_processor {
        let utl_state = processor.get_current_state();
        let quadrant = JohariClassifier::classify(
            utl_state.confidence,
            utl_state.freshness,
        );
        let strategy = JohariSearchStrategy::from_quadrant(quadrant);

        let context = UtlSearchContext {
            quadrant,
            strategy: strategy.strategy_description.clone(),
            learning_magnitude: utl_state.learning_magnitude,
            coherence: utl_state.coherence,
            utl_influenced: true,
        };

        (strategy, context)
    } else {
        // Fallback: default search without UTL influence
        let strategy = JohariSearchStrategy::from_quadrant(JohariQuadrant::Open);
        let context = UtlSearchContext {
            quadrant: JohariQuadrant::Open,
            strategy: "Default search (UTL not available)".into(),
            learning_magnitude: 0.0,
            coherence: 1.0,
            utl_influenced: false,
        };
        (strategy, context)
    };

    // Apply strategy to search parameters
    let effective_top_k = request.top_k.unwrap_or(strategy.top_k);
    let effective_depth = request.max_depth.unwrap_or(strategy.max_depth);

    // Execute search with derived parameters
    let mut results = graph.search(
        &request.query,
        effective_top_k,
        effective_depth,
        strategy.similarity_threshold,
    ).await?;

    // Apply temporal weighting if specified
    if strategy.temporal_weight > 0.0 {
        apply_temporal_weighting(&mut results, strategy.temporal_weight);
    }

    // Explore causal paths if specified (Unknown quadrant)
    if strategy.explore_causal {
        let causal_results = explore_causal_paths(graph, &results).await?;
        results.extend(causal_results);
        results.sort_by(|a, b| b.score.partial_cmp(&a.score).unwrap());
        results.truncate(effective_top_k);
    }

    let latency_ms = start.elapsed().as_secs_f32() * 1000.0;

    Ok(UtlAwareSearchResult {
        results,
        utl_context,
        latency_ms,
    })
}
```

### Search Hints Parameter

```rust
/// Optional hints derived from UTL state to guide search behavior.
#[derive(Debug, Clone, serde::Deserialize)]
pub struct SearchHints {
    /// Preferred Johari quadrant (overrides automatic detection)
    pub preferred_quadrant: Option<JohariQuadrant>,
    /// Boost recent results
    pub temporal_boost: Option<f32>,
    /// Include causal exploration
    pub explore_causal: Option<bool>,
    /// Custom depth override
    pub depth_override: Option<usize>,
}

/// Extended request with UTL hints.
#[derive(Debug, Clone, serde::Deserialize)]
pub struct SearchGraphRequest {
    /// Query string
    pub query: String,
    /// Number of results
    pub top_k: Option<usize>,
    /// Maximum search depth
    pub max_depth: Option<usize>,
    /// UTL-derived search hints
    pub search_hints: Option<SearchHints>,
}
```

### Backward Compatibility

```rust
impl SearchGraphRequest {
    /// Ensure backward compatibility with existing queries.
    /// Old requests without UTL fields work unchanged.
    pub fn is_legacy_request(&self) -> bool {
        self.search_hints.is_none()
    }
}

// Legacy response can be extracted from UTL-aware response
impl From<UtlAwareSearchResult> for LegacySearchResult {
    fn from(utl_result: UtlAwareSearchResult) -> Self {
        LegacySearchResult {
            results: utl_result.results,
            // Omit UTL context for legacy consumers
        }
    }
}
```

### Performance Optimization

```rust
impl JohariSearchStrategy {
    /// Estimate search cost for performance budgeting.
    pub fn estimated_cost(&self) -> f32 {
        // Base cost + depth factor + top_k factor
        let base = 0.5;
        let depth_cost = self.max_depth as f32 * 0.2;
        let topk_cost = self.top_k as f32 * 0.05;
        let causal_cost = if self.explore_causal { 1.0 } else { 0.0 };

        base + depth_cost + topk_cost + causal_cost
    }

    /// Apply performance budget by reducing expensive operations.
    pub fn apply_budget(&mut self, budget_ms: f32) {
        if self.estimated_cost() > budget_ms {
            // Reduce expensive operations to fit budget
            self.explore_causal = false;
            self.max_depth = self.max_depth.min(3);
            self.top_k = self.top_k.min(15);
        }
    }
}
```

## Verification Commands

```bash
# Run search_graph UTL tests
cargo test -p context-graph-mcp search_graph_utl

# Benchmark search performance
cargo bench -p context-graph-mcp search_graph

# Verify backward compatibility
cargo test -p context-graph-mcp legacy_search_compat

# Check UTL context serialization
cargo test -p context-graph-mcp utl_search_context_serialize

# Performance test: ensure < 2ms overhead
cargo test -p context-graph-mcp search_graph_perf --release
```

---

*Generated: 2026-01-04*
*Module: 05 - UTL Integration*
*Task: M05-T53*
