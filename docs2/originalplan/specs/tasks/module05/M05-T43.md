# M05-T43: Implement UTL-Aware Distillation Mode Selection

## Task Metadata
- **ID**: M05-T43
- **Title**: Implement UTL-Aware Distillation Mode Selection
- **Module**: 05 - UTL Integration
- **Layer**: integration
- **Priority**: medium
- **Estimated Hours**: 2
- **Created**: 2026-01-04
- **Status**: pending

## Description

Implement automatic distillation mode selection based on UTL state. Per PRD Section 3.1, inject_context supports distillation modes:
- **auto**: Select based on UTL state (DEFAULT)
- **raw**: No distillation
- **narrative**: Prose summary
- **structured**: JSON/markdown
- **code_focused**: Preserve code blocks

Auto mode algorithm:
- **Open quadrant** (high confidence): raw or structured
- **Blind quadrant** (uncertain): narrative with explanation
- **Hidden quadrant** (stale): structured with refresh suggestion
- **Unknown quadrant** (novel): code_focused if code detected, else narrative

Include distillation_hint in LearningSignal for downstream use.

## File Paths

### Implementation
- `crates/context-graph-mcp/src/distillation/utl_selector.rs`

### Tests
- `crates/context-graph-mcp/tests/distillation_utl_tests.rs`

## Dependencies

| Task ID | Title | Status |
|---------|-------|--------|
| M05-T18 | Implement JohariClassifier | pending |
| M05-T38 | Implement inject_context UTL Integration | pending |

## Acceptance Criteria

- [ ] Auto distillation mode uses UTL state
- [ ] Quadrant-to-mode mapping as specified
- [ ] distillation_hint included in LearningSignal
- [ ] Code detection for code_focused selection
- [ ] Manual mode override preserved
- [ ] Distillation latency target <50ms

## Specification References

- `PRD Section 3.1 (inject_context)`
- `constitution.yaml perf.latency.distillation`

## Implementation Notes

### Distillation Modes

```rust
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum DistillationMode {
    /// Automatic selection based on UTL state
    Auto,
    /// No distillation, raw content
    Raw,
    /// Prose summary format
    Narrative,
    /// JSON/markdown structured format
    Structured,
    /// Preserve code blocks priority
    CodeFocused,
}
```

### UTL-Based Mode Selector

```rust
pub struct UtlDistillationSelector {
    /// Code detection patterns
    code_patterns: Vec<Regex>,
}

impl UtlDistillationSelector {
    /// Select distillation mode based on UTL state
    ///
    /// # Arguments
    /// * `utl_state` - Current UTL state with Johari quadrant
    /// * `content` - Content to be distilled (for code detection)
    ///
    /// # Returns
    /// Selected distillation mode
    ///
    /// Constraint: <5ms for mode selection
    pub fn select_mode(
        &self,
        utl_state: &UtlState,
        content: &str,
    ) -> DistillationMode {
        match utl_state.johari_quadrant {
            JohariQuadrant::Open => {
                // High confidence - minimal processing
                if utl_state.surprise < 0.3 {
                    DistillationMode::Raw
                } else {
                    DistillationMode::Structured
                }
            }
            JohariQuadrant::Blind => {
                // Uncertain - need explanation
                DistillationMode::Narrative
            }
            JohariQuadrant::Hidden => {
                // Stale - structured with refresh hints
                DistillationMode::Structured
            }
            JohariQuadrant::Unknown => {
                // Novel - code detection
                if self.contains_code(content) {
                    DistillationMode::CodeFocused
                } else {
                    DistillationMode::Narrative
                }
            }
        }
    }

    /// Detect if content contains code blocks
    fn contains_code(&self, content: &str) -> bool {
        // Check for markdown code blocks
        // Check for language-specific patterns
        // Check for indentation patterns
    }
}
```

### Quadrant-to-Mode Mapping Table

| Johari Quadrant | Primary Mode | Rationale |
|-----------------|--------------|-----------|
| Open | Raw/Structured | High confidence, minimal processing needed |
| Blind | Narrative | Uncertainty requires explanation and context |
| Hidden | Structured | Stale data benefits from clear organization |
| Unknown | CodeFocused/Narrative | Novel content - preserve code or explain |

### Distillation Hint in LearningSignal

```rust
#[derive(Debug, Clone)]
pub struct DistillationHint {
    /// Recommended mode based on UTL state
    pub recommended_mode: DistillationMode,

    /// Confidence in recommendation (0.0 - 1.0)
    pub confidence: f32,

    /// Whether content contains code
    pub has_code: bool,

    /// Suggested refresh if Hidden quadrant
    pub suggest_refresh: bool,
}

impl LearningSignal {
    /// Add distillation hint for downstream use
    pub fn with_distillation_hint(
        mut self,
        hint: DistillationHint,
    ) -> Self {
        self.distillation_hint = Some(hint);
        self
    }
}
```

### Code Detection Patterns

```rust
const CODE_PATTERNS: &[&str] = &[
    r"```\w*\n",           // Markdown code blocks
    r"^\s{4,}\S",          // Indented code (4+ spaces)
    r"fn\s+\w+\s*\(",      // Rust function
    r"def\s+\w+\s*\(",     // Python function
    r"function\s+\w+\s*\(", // JavaScript function
    r"class\s+\w+",        // Class definition
    r"import\s+\w+",       // Import statement
    r"#include\s*<",       // C/C++ include
];
```

### Performance Target

```rust
// Constitution.yaml: perf.latency.distillation < 50ms
// Mode selection target: <5ms (subset of full distillation)

#[cfg(test)]
mod performance_tests {
    #[test]
    fn test_mode_selection_latency() {
        let selector = UtlDistillationSelector::new();
        let start = Instant::now();

        for _ in 0..1000 {
            selector.select_mode(&utl_state, &content);
        }

        let elapsed = start.elapsed();
        assert!(elapsed.as_micros() / 1000 < 5000); // <5ms avg
    }
}
```

### Manual Override Handling

```rust
pub fn resolve_distillation_mode(
    requested: DistillationMode,
    utl_state: &UtlState,
    content: &str,
    selector: &UtlDistillationSelector,
) -> DistillationMode {
    match requested {
        DistillationMode::Auto => {
            selector.select_mode(utl_state, content)
        }
        // Manual modes always respected
        mode => mode,
    }
}
```

## Testing Requirements

1. **Unit Tests**
   - Test mode selection for each quadrant
   - Test code detection patterns
   - Test manual override behavior
   - Test distillation hint creation

2. **Integration Tests**
   - Test with inject_context tool
   - Test with real content samples
   - Test mode transitions

3. **Performance Tests**
   - Mode selection < 5ms
   - Code detection < 2ms
   - Full distillation < 50ms

4. **Edge Cases**
   - Empty content handling
   - Mixed code/prose content
   - Very large content

---

*Task specification generated for Module 05 - UTL Integration*
