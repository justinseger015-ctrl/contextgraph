# M05-T39: Implement UtlState Persistence to RocksDB

```yaml
task_id: "M05-T39"
title: "Implement UtlState Persistence to RocksDB"
module: "module-05"
layer: "integration"
priority: "critical"
estimated_hours: 3
status: "pending"
created: "2026-01-04"
updated: "2026-01-04"
```

---

## Description

Implement persistent storage of UtlState to RocksDB for cross-session continuity.

Storage layer must handle:
1. UtlState serialization/deserialization (bincode or CBOR for efficiency)
2. Session-scoped UTL state (keyed by session_id)
3. Global/aggregate UTL state (lifecycle stage, interaction_count)
4. UtlState migration for existing MemoryNode data without UTL fields
5. Atomic updates for lifecycle stage transitions

Column families: "utl_session_state", "utl_global_state"

Include `restore_utl_state(session_id)` and `persist_utl_state(session_id, state)`.

---

## File Paths

| Type | Path |
|------|------|
| Implementation | `crates/context-graph-storage/src/utl_persistence.rs` |
| Module | `crates/context-graph-storage/src/lib.rs` |
| Test | `crates/context-graph-storage/tests/utl_persistence_tests.rs` |

---

## Dependencies

| Task ID | Title | Status |
|---------|-------|--------|
| M05-T21 | LearningSignal and UtlState Structs | pending |
| M05-T19 | LifecycleManager State Machine | pending |

---

## Acceptance Criteria

- [ ] UtlState persists to RocksDB on update
- [ ] Session-scoped state keyed by session_id
- [ ] Global lifecycle state survives server restart
- [ ] restore_utl_state() loads previous state correctly
- [ ] Migration handles nodes without utl_state field
- [ ] Atomic lifecycle transitions (no partial state)
- [ ] Serialization overhead <1ms

---

## Specification References

- SPEC-UTL-005 Section 11.3
- constitution.yaml dirs.crates

---

## Technical Notes

### Column Families

RocksDB column families for UTL state:

| Column Family | Key Pattern | Value | Description |
|---------------|-------------|-------|-------------|
| `utl_session_state` | `session:{uuid}` | Serialized UtlState | Per-session UTL state |
| `utl_global_state` | `lifecycle` | Serialized GlobalUtlState | Global lifecycle state |
| `utl_global_state` | `interaction_count` | u64 (LE bytes) | Total interaction count |

### Data Structures

```rust
/// Session-scoped UTL state for persistence
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PersistedUtlState {
    /// Session identifier
    pub session_id: Uuid,

    /// Current UTL computation state
    pub utl_state: UtlState,

    /// Session interaction count
    pub session_interaction_count: u64,

    /// Last update timestamp
    pub last_updated: DateTime<Utc>,

    /// Coherence window snapshot (optional, for restoration)
    pub coherence_window_snapshot: Option<Vec<CoherenceEntry>>,
}

/// Global UTL state across all sessions
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GlobalUtlState {
    /// Current lifecycle stage
    pub lifecycle_stage: LifecycleStage,

    /// Total interaction count across all sessions
    pub total_interaction_count: u64,

    /// Lambda weights for current stage
    pub lambda_weights: LifecycleLambdaWeights,

    /// Lifecycle transition timestamps
    pub stage_transitions: Vec<StageTransition>,

    /// Last update timestamp
    pub last_updated: DateTime<Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StageTransition {
    pub from_stage: LifecycleStage,
    pub to_stage: LifecycleStage,
    pub interaction_count: u64,
    pub timestamp: DateTime<Utc>,
}
```

### Serialization Format

Use **bincode** for efficiency:
- Compact binary format
- Fast serialization/deserialization
- Well-supported in Rust ecosystem

```rust
use bincode::{serialize, deserialize};

fn serialize_utl_state(state: &PersistedUtlState) -> Result<Vec<u8>, StorageError> {
    bincode::serialize(state)
        .map_err(|e| StorageError::Serialization(e.to_string()))
}

fn deserialize_utl_state(bytes: &[u8]) -> Result<PersistedUtlState, StorageError> {
    bincode::deserialize(bytes)
        .map_err(|e| StorageError::Deserialization(e.to_string()))
}
```

### Core API

```rust
/// UTL persistence layer for RocksDB
pub struct UtlPersistence {
    db: Arc<DB>,
    session_cf: String,
    global_cf: String,
}

impl UtlPersistence {
    /// Create new persistence layer with DB handle
    pub fn new(db: Arc<DB>) -> Result<Self, StorageError> {
        // Ensure column families exist
        Ok(Self {
            db,
            session_cf: "utl_session_state".to_string(),
            global_cf: "utl_global_state".to_string(),
        })
    }

    /// Persist session UTL state
    pub fn persist_utl_state(
        &self,
        session_id: Uuid,
        state: &UtlState,
        coherence_window: Option<&[CoherenceEntry]>,
    ) -> Result<(), StorageError> {
        let persisted = PersistedUtlState {
            session_id,
            utl_state: state.clone(),
            session_interaction_count: 0, // Updated by caller
            last_updated: Utc::now(),
            coherence_window_snapshot: coherence_window.map(|w| w.to_vec()),
        };

        let key = format!("session:{}", session_id);
        let value = serialize_utl_state(&persisted)?;

        let cf = self.db.cf_handle(&self.session_cf)
            .ok_or(StorageError::MissingColumnFamily)?;

        self.db.put_cf(cf, key.as_bytes(), &value)?;
        Ok(())
    }

    /// Restore session UTL state
    pub fn restore_utl_state(
        &self,
        session_id: Uuid,
    ) -> Result<Option<PersistedUtlState>, StorageError> {
        let key = format!("session:{}", session_id);
        let cf = self.db.cf_handle(&self.session_cf)
            .ok_or(StorageError::MissingColumnFamily)?;

        match self.db.get_cf(cf, key.as_bytes())? {
            Some(bytes) => {
                let state = deserialize_utl_state(&bytes)?;
                Ok(Some(state))
            }
            None => Ok(None),
        }
    }

    /// Persist global lifecycle state atomically
    pub fn persist_global_state(
        &self,
        state: &GlobalUtlState,
    ) -> Result<(), StorageError> {
        let cf = self.db.cf_handle(&self.global_cf)
            .ok_or(StorageError::MissingColumnFamily)?;

        // Use WriteBatch for atomicity
        let mut batch = WriteBatch::default();

        let lifecycle_value = bincode::serialize(state)?;
        batch.put_cf(cf, b"lifecycle", &lifecycle_value);

        let count_value = state.total_interaction_count.to_le_bytes();
        batch.put_cf(cf, b"interaction_count", &count_value);

        self.db.write(batch)?;
        Ok(())
    }

    /// Restore global lifecycle state
    pub fn restore_global_state(&self) -> Result<Option<GlobalUtlState>, StorageError> {
        let cf = self.db.cf_handle(&self.global_cf)
            .ok_or(StorageError::MissingColumnFamily)?;

        match self.db.get_cf(cf, b"lifecycle")? {
            Some(bytes) => {
                let state: GlobalUtlState = bincode::deserialize(&bytes)?;
                Ok(Some(state))
            }
            None => Ok(None),
        }
    }

    /// Atomic lifecycle stage transition
    pub fn transition_lifecycle_stage(
        &self,
        from: LifecycleStage,
        to: LifecycleStage,
        interaction_count: u64,
    ) -> Result<(), StorageError> {
        let mut state = self.restore_global_state()?
            .unwrap_or_else(GlobalUtlState::default);

        // Verify we're at expected stage
        if state.lifecycle_stage != from {
            return Err(StorageError::ConcurrentModification(
                format!("Expected stage {:?}, found {:?}", from, state.lifecycle_stage)
            ));
        }

        // Record transition
        state.stage_transitions.push(StageTransition {
            from_stage: from,
            to_stage: to,
            interaction_count,
            timestamp: Utc::now(),
        });

        state.lifecycle_stage = to;
        state.lambda_weights = to.get_lambda_weights();
        state.total_interaction_count = interaction_count;
        state.last_updated = Utc::now();

        self.persist_global_state(&state)
    }
}
```

### Migration Strategy

For existing MemoryNodes without `utl_state` field:

```rust
/// Migrate nodes without UTL state
pub fn migrate_node_utl_state(
    &self,
    node: &mut MemoryNode,
) -> Result<(), StorageError> {
    if node.utl_state.is_none() {
        // Create default UTL state for existing node
        node.utl_state = Some(UtlState {
            delta_s: 0.5, // Neutral entropy
            delta_c: 0.5, // Neutral coherence
            w_e: 1.0,     // Neutral emotional weight
            phi: 0.0,     // Start of encoding phase
            learning_magnitude: 0.5,
            quadrant: JohariQuadrant::Hidden, // Moderate uncertainty
            last_computed: node.created_at, // Use node creation time
        });
    }
    Ok(())
}
```

### Performance Considerations

- Serialization target: <1ms
- Use bincode (faster than JSON/CBOR for this use case)
- Batch writes when possible
- Cache recently accessed session states in memory
- Async write option for non-critical updates

---

## Implementation Checklist

1. [ ] Create `crates/context-graph-storage/src/utl_persistence.rs`
2. [ ] Define `PersistedUtlState` struct
3. [ ] Define `GlobalUtlState` struct
4. [ ] Implement serialization/deserialization with bincode
5. [ ] Implement `persist_utl_state()` for session state
6. [ ] Implement `restore_utl_state()` for session state
7. [ ] Implement `persist_global_state()` with atomic writes
8. [ ] Implement `restore_global_state()` for lifecycle
9. [ ] Implement `transition_lifecycle_stage()` with atomicity
10. [ ] Add column family creation on DB init
11. [ ] Implement migration for existing nodes
12. [ ] Add performance instrumentation
13. [ ] Benchmark serialization (< 1ms)
14. [ ] Write unit tests for persistence
15. [ ] Write tests for atomic transitions
16. [ ] Write tests for migration

---

## Test Cases

### Unit Tests

```rust
#[test]
fn test_persist_and_restore_session_state() {
    let db = create_test_db();
    let persistence = UtlPersistence::new(db).unwrap();

    let session_id = Uuid::new_v4();
    let state = UtlState::default();

    persistence.persist_utl_state(session_id, &state, None).unwrap();
    let restored = persistence.restore_utl_state(session_id).unwrap();

    assert!(restored.is_some());
    assert_eq!(restored.unwrap().session_id, session_id);
}

#[test]
fn test_restore_nonexistent_session() {
    let db = create_test_db();
    let persistence = UtlPersistence::new(db).unwrap();

    let restored = persistence.restore_utl_state(Uuid::new_v4()).unwrap();
    assert!(restored.is_none());
}

#[test]
fn test_persist_global_lifecycle_state() {
    let db = create_test_db();
    let persistence = UtlPersistence::new(db).unwrap();

    let state = GlobalUtlState {
        lifecycle_stage: LifecycleStage::Growth,
        total_interaction_count: 100,
        ..Default::default()
    };

    persistence.persist_global_state(&state).unwrap();
    let restored = persistence.restore_global_state().unwrap();

    assert!(restored.is_some());
    assert_eq!(restored.unwrap().lifecycle_stage, LifecycleStage::Growth);
}

#[test]
fn test_atomic_lifecycle_transition() {
    let db = create_test_db();
    let persistence = UtlPersistence::new(db).unwrap();

    // Start at Infancy
    let initial = GlobalUtlState {
        lifecycle_stage: LifecycleStage::Infancy,
        total_interaction_count: 49,
        ..Default::default()
    };
    persistence.persist_global_state(&initial).unwrap();

    // Transition to Growth at 50
    persistence.transition_lifecycle_stage(
        LifecycleStage::Infancy,
        LifecycleStage::Growth,
        50,
    ).unwrap();

    let restored = persistence.restore_global_state().unwrap().unwrap();
    assert_eq!(restored.lifecycle_stage, LifecycleStage::Growth);
    assert_eq!(restored.total_interaction_count, 50);
    assert_eq!(restored.stage_transitions.len(), 1);
}

#[test]
fn test_transition_wrong_stage_fails() {
    let db = create_test_db();
    let persistence = UtlPersistence::new(db).unwrap();

    // Start at Infancy
    let initial = GlobalUtlState {
        lifecycle_stage: LifecycleStage::Infancy,
        ..Default::default()
    };
    persistence.persist_global_state(&initial).unwrap();

    // Try to transition from Growth (wrong stage)
    let result = persistence.transition_lifecycle_stage(
        LifecycleStage::Growth, // Wrong!
        LifecycleStage::Maturity,
        500,
    );

    assert!(result.is_err());
}

#[test]
fn test_serialization_performance() {
    let state = PersistedUtlState {
        session_id: Uuid::new_v4(),
        utl_state: UtlState::default(),
        session_interaction_count: 100,
        last_updated: Utc::now(),
        coherence_window_snapshot: Some(vec![CoherenceEntry::default(); 100]),
    };

    let start = Instant::now();
    for _ in 0..1000 {
        let bytes = bincode::serialize(&state).unwrap();
        let _: PersistedUtlState = bincode::deserialize(&bytes).unwrap();
    }
    let elapsed = start.elapsed();

    // 1000 round trips should be under 100ms -> <1ms per round trip
    assert!(elapsed.as_millis() < 100, "Serialization too slow: {:?}", elapsed);
}

#[test]
fn test_migration_existing_node() {
    let db = create_test_db();
    let persistence = UtlPersistence::new(db).unwrap();

    let mut node = MemoryNode {
        id: Uuid::new_v4(),
        utl_state: None, // Old node without UTL
        ..Default::default()
    };

    persistence.migrate_node_utl_state(&mut node).unwrap();

    assert!(node.utl_state.is_some());
    assert_eq!(node.utl_state.unwrap().quadrant, JohariQuadrant::Hidden);
}

#[test]
fn test_global_state_survives_restart() {
    let db_path = tempdir().unwrap().path().to_owned();

    // First session
    {
        let db = DB::open_default(&db_path).unwrap();
        let persistence = UtlPersistence::new(Arc::new(db)).unwrap();

        let state = GlobalUtlState {
            lifecycle_stage: LifecycleStage::Growth,
            total_interaction_count: 200,
            ..Default::default()
        };
        persistence.persist_global_state(&state).unwrap();
    }

    // Simulate restart - reopen DB
    {
        let db = DB::open_default(&db_path).unwrap();
        let persistence = UtlPersistence::new(Arc::new(db)).unwrap();

        let restored = persistence.restore_global_state().unwrap().unwrap();
        assert_eq!(restored.lifecycle_stage, LifecycleStage::Growth);
        assert_eq!(restored.total_interaction_count, 200);
    }
}
```

---

*Module: 05 - UTL Integration*
*Task: 39 of 57*
*Layer: Integration*
*Priority: CRITICAL*
