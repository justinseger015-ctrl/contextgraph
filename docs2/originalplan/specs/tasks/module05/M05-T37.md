# M05-T37: Implement Johari Quadrant to Verbosity Tier Mapping

```yaml
task_id: "M05-T37"
title: "Implement Johari Quadrant to Verbosity Tier Mapping"
module: "module-05"
layer: "integration"
priority: "medium"
estimated_hours: 2
status: "pending"
created: "2026-01-04"
updated: "2026-01-04"
```

---

## Description

Implement mapping from Johari quadrant to MCP response verbosity tier. Map as per constitution.yaml response_modes:
- Open (high confidence) -> Tier 0 (RawOnly, ~100 tokens)
- Hidden/Blind -> Tier 1 (TextAndIds, ~200 tokens, DEFAULT)
- Unknown (low coherence) -> Tier 2 (FullInsights, ~800 tokens)

Implement VerbositySelector trait for quadrant-aware response formatting. Integrate with MCP response generation layer.

---

## File Paths

| Type | Path |
|------|------|
| Implementation | `crates/context-graph-mcp/src/response/verbosity.rs` |
| Module | `crates/context-graph-mcp/src/response/mod.rs` |
| Test | `crates/context-graph-mcp/tests/verbosity_tests.rs` |

---

## Dependencies

| Task ID | Title | Status |
|---------|-------|--------|
| M05-T18 | JohariClassifier with Retrieval Strategies | pending |
| M05-T28 | CognitivePulse Header for MCP Responses | pending |

---

## Acceptance Criteria

- [ ] Quadrant to verbosity tier mapping implemented
- [ ] VerbositySelector trait defined
- [ ] Open -> Tier 0, Hidden/Blind -> Tier 1, Unknown -> Tier 2
- [ ] Automatic verbosity selection in MCP responses
- [ ] Manual override capability preserved

---

## Specification References

- constitution.yaml response_modes section
- SPEC-UTL-005 Section 7

---

## Technical Notes

### Verbosity Tier Definitions

| Tier | Name | Token Budget | Description | Use Case |
|------|------|--------------|-------------|----------|
| 0 | RawOnly | ~100 | Minimal response, just the data | Open quadrant - high confidence |
| 1 | TextAndIds | ~200 | Text with node IDs for reference | Hidden/Blind - moderate uncertainty |
| 2 | FullInsights | ~800 | Complete insights and explanations | Unknown - needs clarification |

### Quadrant to Tier Mapping

```rust
/// Verbosity tier for MCP responses
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[repr(u8)]
pub enum VerbosityTier {
    /// Tier 0: Raw data only (~100 tokens)
    RawOnly = 0,

    /// Tier 1: Text with identifiers (~200 tokens) - DEFAULT
    TextAndIds = 1,

    /// Tier 2: Full insights and explanations (~800 tokens)
    FullInsights = 2,
}

impl From<JohariQuadrant> for VerbosityTier {
    fn from(quadrant: JohariQuadrant) -> Self {
        match quadrant {
            JohariQuadrant::Open => VerbosityTier::RawOnly,
            JohariQuadrant::Hidden => VerbosityTier::TextAndIds,
            JohariQuadrant::Blind => VerbosityTier::TextAndIds,
            JohariQuadrant::Unknown => VerbosityTier::FullInsights,
        }
    }
}
```

### VerbositySelector Trait

```rust
/// Trait for selecting verbosity based on UTL state
pub trait VerbositySelector {
    /// Select verbosity tier based on current state
    fn select_verbosity(&self, quadrant: JohariQuadrant) -> VerbosityTier;

    /// Get token budget for tier
    fn get_token_budget(&self, tier: VerbosityTier) -> usize;

    /// Check if manual override is active
    fn has_override(&self) -> bool;

    /// Get the override tier if set
    fn get_override(&self) -> Option<VerbosityTier>;
}
```

### VerbosityConfig

```rust
/// Configuration for verbosity selection
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VerbosityConfig {
    /// Token budget per tier
    pub tier_0_tokens: usize,  // default: 100
    pub tier_1_tokens: usize,  // default: 200
    pub tier_2_tokens: usize,  // default: 800

    /// Allow automatic tier selection
    pub auto_select: bool,     // default: true

    /// Default tier when auto-select disabled
    pub default_tier: VerbosityTier,  // default: TextAndIds
}
```

### MCP Integration

```rust
/// Middleware for automatic verbosity selection
pub struct VerbosityMiddleware {
    selector: Box<dyn VerbositySelector>,
    config: VerbosityConfig,
}

impl VerbosityMiddleware {
    /// Apply verbosity to response based on cognitive pulse
    pub fn apply_verbosity<T: Serialize>(
        &self,
        response: T,
        pulse: &CognitivePulse,
        override_tier: Option<VerbosityTier>,
    ) -> FormattedResponse {
        let tier = override_tier.unwrap_or_else(|| {
            self.selector.select_verbosity(pulse.quadrant)
        });

        FormattedResponse {
            data: response,
            verbosity_tier: tier,
            token_budget: self.selector.get_token_budget(tier),
        }
    }
}
```

### Manual Override

Users can override automatic verbosity via:
1. Request parameter: `verbosity_tier: "full_insights"`
2. Session preference: stored in session context
3. API header: `X-Verbosity-Tier: 2`

```rust
/// Check for verbosity override in request
pub fn get_override_from_request(request: &McpRequest) -> Option<VerbosityTier> {
    request.params.get("verbosity_tier")
        .and_then(|v| v.as_str())
        .and_then(|s| VerbosityTier::from_str(s).ok())
}
```

---

## Implementation Checklist

1. [ ] Create `crates/context-graph-mcp/src/response/mod.rs`
2. [ ] Create `crates/context-graph-mcp/src/response/verbosity.rs`
3. [ ] Define `VerbosityTier` enum with 3 variants
4. [ ] Implement `From<JohariQuadrant>` for VerbosityTier
5. [ ] Define `VerbositySelector` trait
6. [ ] Define `VerbosityConfig` struct
7. [ ] Implement `DefaultVerbositySelector`
8. [ ] Create `VerbosityMiddleware` for MCP integration
9. [ ] Implement manual override detection
10. [ ] Add token budget enforcement
11. [ ] Update MCP response generation to use verbosity
12. [ ] Write unit tests for all mappings
13. [ ] Write tests for override behavior

---

## Test Cases

### Unit Tests

```rust
#[test]
fn test_open_quadrant_to_tier_0() {
    let tier: VerbosityTier = JohariQuadrant::Open.into();
    assert_eq!(tier, VerbosityTier::RawOnly);
}

#[test]
fn test_hidden_quadrant_to_tier_1() {
    let tier: VerbosityTier = JohariQuadrant::Hidden.into();
    assert_eq!(tier, VerbosityTier::TextAndIds);
}

#[test]
fn test_blind_quadrant_to_tier_1() {
    let tier: VerbosityTier = JohariQuadrant::Blind.into();
    assert_eq!(tier, VerbosityTier::TextAndIds);
}

#[test]
fn test_unknown_quadrant_to_tier_2() {
    let tier: VerbosityTier = JohariQuadrant::Unknown.into();
    assert_eq!(tier, VerbosityTier::FullInsights);
}

#[test]
fn test_token_budget_tier_0() {
    let selector = DefaultVerbositySelector::new(VerbosityConfig::default());
    assert_eq!(selector.get_token_budget(VerbosityTier::RawOnly), 100);
}

#[test]
fn test_token_budget_tier_2() {
    let selector = DefaultVerbositySelector::new(VerbosityConfig::default());
    assert_eq!(selector.get_token_budget(VerbosityTier::FullInsights), 800);
}

#[test]
fn test_manual_override() {
    let middleware = VerbosityMiddleware::new(VerbosityConfig::default());
    let pulse = CognitivePulse { quadrant: JohariQuadrant::Open, ..Default::default() };

    // Without override -> Tier 0 (from Open)
    let response = middleware.apply_verbosity("data", &pulse, None);
    assert_eq!(response.verbosity_tier, VerbosityTier::RawOnly);

    // With override -> Tier 2
    let response = middleware.apply_verbosity("data", &pulse, Some(VerbosityTier::FullInsights));
    assert_eq!(response.verbosity_tier, VerbosityTier::FullInsights);
}

#[test]
fn test_default_tier() {
    let config = VerbosityConfig {
        auto_select: false,
        default_tier: VerbosityTier::TextAndIds,
        ..Default::default()
    };
    let selector = DefaultVerbositySelector::new(config);

    // When auto-select is off, always returns default
    assert_eq!(selector.select_verbosity(JohariQuadrant::Unknown), VerbosityTier::TextAndIds);
}
```

---

*Module: 05 - UTL Integration*
*Task: 37 of 57*
*Layer: Integration*
