# M05-T46: Create UTL Chaos and Edge Case Tests

## Task Metadata
- **ID**: M05-T46
- **Title**: Create UTL Chaos and Edge Case Tests
- **Module**: 05 - UTL Integration
- **Layer**: integration
- **Priority**: high
- **Estimated Hours**: 4

## Description

Create comprehensive chaos and edge case tests for UTL robustness.

Test scenarios:
1. NaN/Infinity injection in all computation paths
2. Empty/null context scenarios
3. Extremely large context windows (10K+ entries)
4. Rapid lifecycle transitions (concurrent mutations)
5. Zero-length embeddings
6. Invalid lambda weight combinations
7. Phase oscillator overflow/underflow
8. Concurrent UTL computations (thread safety)
9. Memory pressure scenarios
10. Clock skew for timestamp-based operations

All tests must verify graceful degradation without panics.

## File Path
`crates/context-graph-utl/tests/chaos_tests.rs`

## Dependencies
- M05-T25: Integration tests and benchmarks
- M05-T22: UtlProcessor orchestrator

## Acceptance Criteria
- [ ] NaN/Infinity never propagates to outputs
- [ ] Empty context handled gracefully
- [ ] Large windows don't cause OOM
- [ ] Concurrent access is thread-safe
- [ ] All edge cases return valid defaults
- [ ] No panics under any test scenario
- [ ] Graceful degradation logged/traced

## Test File
`crates/context-graph-utl/tests/chaos_tests.rs`

## Specification References
- constitution.yaml testing.types.chaos
- constitution.yaml forbidden.AP-009

## Implementation Notes

### Chaos Test Structure

```rust
//! Chaos and edge case tests for UTL robustness
//!
//! These tests verify graceful degradation under adversarial conditions.
//! Per constitution.yaml forbidden.AP-009: "returning NaN or Infinity from any computation"

use context_graph_utl::*;
use std::f32::{NAN, INFINITY, NEG_INFINITY};
use std::sync::Arc;
use std::thread;

mod nan_infinity_tests {
    use super::*;

    #[test]
    fn nan_in_embedding_returns_default() {
        let processor = UtlProcessor::new(Default::default());
        let embedding = vec![NAN; 1536];

        let result = processor.compute(&"test", &embedding, &[]);

        assert!(!result.learning_magnitude.is_nan());
        assert!(!result.learning_magnitude.is_infinite());
        assert!(result.learning_magnitude >= 0.0);
        assert!(result.learning_magnitude <= 1.0);
    }

    #[test]
    fn infinity_in_surprise_clamped() {
        let mut calculator = SurpriseCalculator::new(Default::default());
        calculator.inject_prior_for_test(vec![INFINITY; 1536]);

        let result = calculator.compute_surprise(&vec![1.0; 1536]);

        assert!(result.is_ok());
        assert!(!result.unwrap().is_infinite());
    }

    #[test]
    fn mixed_nan_infinity_context() {
        let processor = UtlProcessor::new(Default::default());
        let embedding = vec![1.0; 1536];
        let context = vec![
            ContextEntry { embedding: vec![NAN; 1536], ..Default::default() },
            ContextEntry { embedding: vec![INFINITY; 1536], ..Default::default() },
            ContextEntry { embedding: vec![NEG_INFINITY; 1536], ..Default::default() },
        ];

        let result = processor.compute(&"test", &embedding, &context);

        assert!(result.is_valid());
    }
}

mod empty_context_tests {
    use super::*;

    #[test]
    fn empty_context_returns_default() {
        let processor = UtlProcessor::new(Default::default());
        let embedding = vec![1.0; 1536];

        let result = processor.compute(&"test", &embedding, &[]);

        assert!(result.is_ok());
        assert_eq!(result.johari_quadrant, JohariQuadrant::Unknown);
    }

    #[test]
    fn empty_embedding_handled() {
        let processor = UtlProcessor::new(Default::default());

        let result = processor.compute(&"test", &[], &[]);

        assert!(result.is_ok());
        assert_eq!(result.learning_magnitude, 0.5); // Default value
    }

    #[test]
    fn empty_text_handled() {
        let processor = UtlProcessor::new(Default::default());
        let embedding = vec![1.0; 1536];

        let result = processor.compute(&"", &embedding, &[]);

        assert!(result.is_ok());
    }

    #[test]
    fn null_content_equivalent() {
        let processor = UtlProcessor::new(Default::default());

        let result = processor.compute_optional(None, None, &[]);

        assert!(result.is_ok());
    }
}

mod large_context_tests {
    use super::*;

    #[test]
    fn large_context_window_no_oom() {
        let processor = UtlProcessor::new(Default::default());
        let embedding = vec![1.0; 1536];

        // 10K+ context entries
        let context: Vec<ContextEntry> = (0..10_000)
            .map(|i| ContextEntry {
                embedding: vec![(i as f32 / 10000.0); 1536],
                timestamp: i as u64,
                ..Default::default()
            })
            .collect();

        let result = processor.compute(&"test", &embedding, &context);

        assert!(result.is_ok());
    }

    #[test]
    fn context_window_truncation() {
        let processor = UtlProcessor::with_max_context(100);
        let embedding = vec![1.0; 1536];

        let context: Vec<ContextEntry> = (0..1000)
            .map(|_| ContextEntry::default())
            .collect();

        let result = processor.compute(&"test", &embedding, &context);

        assert!(result.is_ok());
        // Verify only most recent 100 were used
    }

    #[test]
    fn extremely_large_embedding() {
        let processor = UtlProcessor::new(Default::default());
        // Non-standard embedding size
        let embedding = vec![1.0; 100_000];

        let result = processor.compute(&"test", &embedding, &[]);

        // Should either handle or return error, never panic
        assert!(result.is_ok() || result.is_err());
    }
}

mod concurrent_mutation_tests {
    use super::*;
    use std::sync::atomic::{AtomicU64, Ordering};

    #[test]
    fn rapid_lifecycle_transitions() {
        let manager = Arc::new(LifecycleManager::new(Default::default()));
        let counter = Arc::new(AtomicU64::new(0));

        let handles: Vec<_> = (0..10)
            .map(|_| {
                let m = Arc::clone(&manager);
                let c = Arc::clone(&counter);
                thread::spawn(move || {
                    for _ in 0..100 {
                        m.record_interaction();
                        c.fetch_add(1, Ordering::SeqCst);
                    }
                })
            })
            .collect();

        for h in handles {
            h.join().unwrap();
        }

        // Should not panic and state should be consistent
        let stage = manager.current_stage();
        assert!(matches!(
            stage,
            LifecycleStage::Infancy | LifecycleStage::Growth | LifecycleStage::Maturity
        ));
    }

    #[test]
    fn concurrent_utl_computations() {
        let processor = Arc::new(UtlProcessor::new(Default::default()));

        let handles: Vec<_> = (0..50)
            .map(|i| {
                let p = Arc::clone(&processor);
                thread::spawn(move || {
                    let embedding = vec![(i as f32 / 50.0); 1536];
                    p.compute(&format!("test {}", i), &embedding, &[])
                })
            })
            .collect();

        for h in handles {
            let result = h.join().unwrap();
            assert!(result.is_valid());
        }
    }
}

mod invalid_lambda_tests {
    use super::*;

    #[test]
    fn lambda_sum_not_one_normalized() {
        // Attempting to create invalid weights should normalize
        let weights = LifecycleLambdaWeights::new(0.3, 0.3);

        let sum = weights.lambda_novelty + weights.lambda_consolidation;
        assert!((sum - 1.0).abs() < 0.001);
    }

    #[test]
    fn negative_lambda_rejected() {
        let result = LifecycleLambdaWeights::try_new(-0.5, 1.5);

        assert!(result.is_err());
    }

    #[test]
    fn lambda_greater_than_one_normalized() {
        let weights = LifecycleLambdaWeights::new(1.5, 0.5);

        assert!(weights.lambda_novelty <= 1.0);
        assert!(weights.lambda_consolidation <= 1.0);
    }
}

mod phase_oscillator_tests {
    use super::*;

    #[test]
    fn phase_overflow_wraps() {
        let mut oscillator = PhaseOscillator::new(Default::default());

        // Advance phase many times
        for _ in 0..100_000 {
            oscillator.advance(0.1);
        }

        // Phase should still be in valid range [0, 2Ï€]
        let phase = oscillator.current_phase();
        assert!(phase >= 0.0);
        assert!(phase <= std::f32::consts::TAU);
    }

    #[test]
    fn negative_delta_handled() {
        let mut oscillator = PhaseOscillator::new(Default::default());

        oscillator.advance(-1.0);

        let phase = oscillator.current_phase();
        assert!(phase >= 0.0);
    }

    #[test]
    fn extreme_frequency_clamped() {
        let config = PhaseConfig {
            base_frequency: 1e10,
            ..Default::default()
        };
        let oscillator = PhaseOscillator::new(config);

        // Should be clamped to reasonable range
        assert!(oscillator.frequency() <= MAX_FREQUENCY);
    }
}

mod memory_pressure_tests {
    use super::*;

    #[test]
    #[ignore] // Run with --ignored for stress tests
    fn sustained_load_no_memory_leak() {
        let processor = UtlProcessor::new(Default::default());

        for _ in 0..100_000 {
            let embedding = vec![rand::random::<f32>(); 1536];
            let _ = processor.compute(&"test", &embedding, &[]);
        }

        // If we get here without OOM, test passes
    }

    #[test]
    fn coherence_window_bounded() {
        let mut tracker = CoherenceTracker::with_max_window(100);

        // Add many entries
        for i in 0..10_000 {
            tracker.add_entry(CoherenceEntry {
                similarity: (i as f32 / 10000.0),
                timestamp: i as u64,
            });
        }

        // Window should be bounded
        assert!(tracker.window_size() <= 100);
    }
}

mod timestamp_tests {
    use super::*;

    #[test]
    fn future_timestamp_handled() {
        let mut tracker = CoherenceTracker::new(Default::default());

        // Far future timestamp
        tracker.add_entry(CoherenceEntry {
            similarity: 0.5,
            timestamp: u64::MAX,
        });

        let coherence = tracker.current_coherence();
        assert!(coherence.is_finite());
    }

    #[test]
    fn zero_timestamp_handled() {
        let mut tracker = CoherenceTracker::new(Default::default());

        tracker.add_entry(CoherenceEntry {
            similarity: 0.5,
            timestamp: 0,
        });

        let coherence = tracker.current_coherence();
        assert!(coherence.is_finite());
    }

    #[test]
    fn out_of_order_timestamps() {
        let mut tracker = CoherenceTracker::new(Default::default());

        tracker.add_entry(CoherenceEntry { similarity: 0.5, timestamp: 100 });
        tracker.add_entry(CoherenceEntry { similarity: 0.5, timestamp: 50 });
        tracker.add_entry(CoherenceEntry { similarity: 0.5, timestamp: 200 });

        let coherence = tracker.current_coherence();
        assert!(coherence.is_finite());
    }
}

mod graceful_degradation_tests {
    use super::*;
    use tracing_test::traced_test;

    #[test]
    #[traced_test]
    fn degradation_logged() {
        let processor = UtlProcessor::new(Default::default());
        let embedding = vec![NAN; 1536];

        let _ = processor.compute(&"test", &embedding, &[]);

        // Verify warning was logged
        assert!(logs_contain("graceful degradation"));
    }

    #[test]
    fn all_failures_return_valid_state() {
        let processor = UtlProcessor::new(Default::default());

        // Various failure scenarios
        let scenarios = vec![
            (vec![], vec![]),                    // Empty everything
            (vec![NAN], vec![]),                 // NaN embedding
            (vec![1.0; 1536], vec![ContextEntry { embedding: vec![], ..Default::default() }]),
        ];

        for (embedding, context) in scenarios {
            let result = processor.compute(&"test", &embedding, &context);

            // All should return valid defaults, never panic
            assert!(result.learning_magnitude >= 0.0);
            assert!(result.learning_magnitude <= 1.0);
            assert!(!result.learning_magnitude.is_nan());
        }
    }
}
```

### Test Categories and Coverage

| Category | Scenarios | Expected Behavior |
|----------|-----------|-------------------|
| NaN/Infinity | 3 tests | Returns clamped defaults |
| Empty Context | 4 tests | Returns default quadrant |
| Large Context | 3 tests | Truncates, no OOM |
| Concurrent | 2 tests | Thread-safe, consistent |
| Lambda Weights | 3 tests | Normalizes or rejects |
| Phase Oscillator | 3 tests | Wraps, clamps |
| Memory Pressure | 2 tests | Bounded, no leaks |
| Timestamps | 3 tests | Handles all edge cases |
| Degradation | 2 tests | Logged, valid returns |

## Performance Targets
- All chaos tests complete in <30s total
- No individual test exceeds 5s (except stress tests)
- Memory usage stays under 500MB during large context tests

## Related Tasks
- M05-T22: UtlProcessor being tested
- M05-T25: Integration test foundation

---
*Generated: 2026-01-04*
*Module: 05 - UTL Integration*
*Version: 1.0.0*
