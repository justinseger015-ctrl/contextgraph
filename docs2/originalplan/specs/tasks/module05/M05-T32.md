# M05-T32: Implement PhaseConfig Struct

```yaml
task_id: M05-T32
title: "Implement PhaseConfig Struct"
module: "module-05-utl-integration"
layer: "integration"
priority: "high"
status: "pending"
estimated_hours: 1
created: "2026-01-04"
dependencies:
  - M05-T01  # UtlConfig and UtlThresholds Structs
spec_refs:
  - "TECH-UTL-005 Section 10"
  - "SPEC-UTL-005 Section 15.1"
file_path: "crates/context-graph-utl/src/config.rs"
test_file: "crates/context-graph-utl/tests/config_tests.rs"
```

---

## Description

Implement the PhaseConfig struct for phase oscillator configuration. This struct contains all parameters needed to configure the PhaseOscillator, which tracks the theta-inspired memory phase for encoding/consolidation timing.

The phase oscillator models the theta rhythm observed in hippocampal memory encoding, where different phases favor encoding (learning) vs consolidation (memory stabilization).

---

## Implementation Requirements

### PhaseConfig Struct

```rust
use serde::{Deserialize, Serialize};

/// Configuration for the PhaseOscillator.
///
/// Controls the theta-inspired memory phase oscillation that determines
/// whether the system is in encoding (learning) or consolidation (memory
/// stabilization) mode.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PhaseConfig {
    /// Base oscillation frequency in Hz (default: 0.1)
    /// Lower values = slower phase transitions
    pub base_frequency: f32,

    /// Minimum modulation factor (default: 0.1)
    /// Clamps modulation input to this minimum
    pub modulation_min: f32,

    /// Maximum modulation factor (default: 3.0)
    /// Clamps modulation input to this maximum
    pub modulation_max: f32,

    /// Phase threshold for encoding mode (default: 0.33)
    /// phi < encoding_threshold * PI => Encoding phase
    pub encoding_threshold: f32,

    /// Phase threshold for consolidation mode (default: 0.67)
    /// phi > consolidation_threshold * PI => Consolidation phase
    /// encoding_threshold < phi < consolidation_threshold => Transition phase
    pub consolidation_threshold: f32,

    /// Phase angle threshold for triggering consolidation (default: 2.1 radians)
    /// When phi >= this value, consolidation may be triggered
    pub consolidation_phase_threshold: f32,

    /// Minimum importance for consolidation consideration (default: 0.4)
    /// Nodes with importance below this are not considered for consolidation
    pub consolidation_importance_threshold: f32,

    /// Staleness threshold in seconds for consolidation (default: 300)
    /// Nodes not accessed within this time become consolidation candidates
    pub consolidation_staleness_seconds: u64,
}
```

### Default Implementation

```rust
impl Default for PhaseConfig {
    fn default() -> Self {
        Self {
            base_frequency: 0.1,
            modulation_min: 0.1,
            modulation_max: 3.0,
            encoding_threshold: 0.33,
            consolidation_threshold: 0.67,
            consolidation_phase_threshold: 2.1,
            consolidation_importance_threshold: 0.4,
            consolidation_staleness_seconds: 300,
        }
    }
}
```

### Validation Method

```rust
impl PhaseConfig {
    /// Validate configuration values are within acceptable ranges.
    ///
    /// # Returns
    /// - `Ok(())` if configuration is valid
    /// - `Err(ConfigError)` with details if invalid
    pub fn validate(&self) -> Result<(), ConfigError> {
        // base_frequency must be positive
        if self.base_frequency <= 0.0 {
            return Err(ConfigError::InvalidValue {
                field: "base_frequency".to_string(),
                value: self.base_frequency.to_string(),
                reason: "must be positive".to_string(),
            });
        }

        // modulation_min must be less than modulation_max
        if self.modulation_min >= self.modulation_max {
            return Err(ConfigError::InvalidValue {
                field: "modulation_min/modulation_max".to_string(),
                value: format!("{}/{}", self.modulation_min, self.modulation_max),
                reason: "modulation_min must be less than modulation_max".to_string(),
            });
        }

        // encoding_threshold must be less than consolidation_threshold
        if self.encoding_threshold >= self.consolidation_threshold {
            return Err(ConfigError::InvalidValue {
                field: "encoding_threshold/consolidation_threshold".to_string(),
                value: format!("{}/{}", self.encoding_threshold, self.consolidation_threshold),
                reason: "encoding_threshold must be less than consolidation_threshold".to_string(),
            });
        }

        // Thresholds must be in valid range [0, 1]
        if self.encoding_threshold < 0.0 || self.encoding_threshold > 1.0 {
            return Err(ConfigError::InvalidValue {
                field: "encoding_threshold".to_string(),
                value: self.encoding_threshold.to_string(),
                reason: "must be in range [0, 1]".to_string(),
            });
        }

        if self.consolidation_threshold < 0.0 || self.consolidation_threshold > 1.0 {
            return Err(ConfigError::InvalidValue {
                field: "consolidation_threshold".to_string(),
                value: self.consolidation_threshold.to_string(),
                reason: "must be in range [0, 1]".to_string(),
            });
        }

        // consolidation_phase_threshold must be in valid range [0, PI]
        if self.consolidation_phase_threshold < 0.0 || self.consolidation_phase_threshold > std::f32::consts::PI {
            return Err(ConfigError::InvalidValue {
                field: "consolidation_phase_threshold".to_string(),
                value: self.consolidation_phase_threshold.to_string(),
                reason: "must be in range [0, PI]".to_string(),
            });
        }

        // importance threshold must be in [0, 1]
        if self.consolidation_importance_threshold < 0.0 || self.consolidation_importance_threshold > 1.0 {
            return Err(ConfigError::InvalidValue {
                field: "consolidation_importance_threshold".to_string(),
                value: self.consolidation_importance_threshold.to_string(),
                reason: "must be in range [0, 1]".to_string(),
            });
        }

        Ok(())
    }
}
```

### Builder Pattern (Optional)

```rust
impl PhaseConfig {
    /// Create a new PhaseConfig builder
    pub fn builder() -> PhaseConfigBuilder {
        PhaseConfigBuilder::default()
    }
}

#[derive(Default)]
pub struct PhaseConfigBuilder {
    config: PhaseConfig,
}

impl PhaseConfigBuilder {
    pub fn base_frequency(mut self, value: f32) -> Self {
        self.config.base_frequency = value;
        self
    }

    pub fn modulation_range(mut self, min: f32, max: f32) -> Self {
        self.config.modulation_min = min;
        self.config.modulation_max = max;
        self
    }

    pub fn encoding_threshold(mut self, value: f32) -> Self {
        self.config.encoding_threshold = value;
        self
    }

    pub fn consolidation_threshold(mut self, value: f32) -> Self {
        self.config.consolidation_threshold = value;
        self
    }

    pub fn build(self) -> Result<PhaseConfig, ConfigError> {
        self.config.validate()?;
        Ok(self.config)
    }
}
```

---

## Integration with PhaseOscillator

The PhaseConfig integrates with the PhaseOscillator from M05-T17:

```rust
impl PhaseOscillator {
    pub fn new(config: PhaseConfig) -> Self {
        Self {
            phi: 0.0,
            frequency: config.base_frequency,
            last_update: Instant::now(),
            modulation: 1.0,
            config,
        }
    }

    pub fn get_phase(&self) -> ConsolidationPhase {
        let normalized_phi = self.phi / std::f32::consts::PI;
        if normalized_phi < self.config.encoding_threshold {
            ConsolidationPhase::Encoding
        } else if normalized_phi > self.config.consolidation_threshold {
            ConsolidationPhase::Consolidation
        } else {
            ConsolidationPhase::Transition
        }
    }

    pub fn set_modulation(&mut self, modulation: f32) {
        self.modulation = modulation.clamp(
            self.config.modulation_min,
            self.config.modulation_max,
        );
    }
}
```

---

## Parameter Reference Table

| Parameter | Default | Range | Description |
|-----------|---------|-------|-------------|
| `base_frequency` | 0.1 | (0, inf) | Base oscillation frequency in Hz |
| `modulation_min` | 0.1 | (0, modulation_max) | Minimum modulation clamp |
| `modulation_max` | 3.0 | (modulation_min, inf) | Maximum modulation clamp |
| `encoding_threshold` | 0.33 | [0, consolidation_threshold) | Phase threshold for encoding mode |
| `consolidation_threshold` | 0.67 | (encoding_threshold, 1] | Phase threshold for consolidation |
| `consolidation_phase_threshold` | 2.1 | [0, PI] | Phase angle for consolidation trigger |
| `consolidation_importance_threshold` | 0.4 | [0, 1] | Min importance for consolidation |
| `consolidation_staleness_seconds` | 300 | [0, inf) | Staleness threshold in seconds |

---

## Acceptance Criteria

- [ ] PhaseConfig struct with all 8 specified fields
- [ ] Default implementation returns spec-defined values
- [ ] Serde Serialize/Deserialize traits implemented
- [ ] Clone, Debug traits implemented
- [ ] `validate()` method checks all constraints
- [ ] Integrates correctly with PhaseOscillator
- [ ] Unit tests verify default values
- [ ] Unit tests verify validation logic

---

## Test Cases

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_default_values() {
        let config = PhaseConfig::default();
        assert_eq!(config.base_frequency, 0.1);
        assert_eq!(config.modulation_min, 0.1);
        assert_eq!(config.modulation_max, 3.0);
        assert_eq!(config.encoding_threshold, 0.33);
        assert_eq!(config.consolidation_threshold, 0.67);
        assert_eq!(config.consolidation_phase_threshold, 2.1);
        assert_eq!(config.consolidation_importance_threshold, 0.4);
        assert_eq!(config.consolidation_staleness_seconds, 300);
    }

    #[test]
    fn test_default_validates() {
        let config = PhaseConfig::default();
        assert!(config.validate().is_ok());
    }

    #[test]
    fn test_invalid_base_frequency() {
        let mut config = PhaseConfig::default();
        config.base_frequency = -0.1;
        assert!(config.validate().is_err());
    }

    #[test]
    fn test_invalid_modulation_range() {
        let mut config = PhaseConfig::default();
        config.modulation_min = 5.0;
        config.modulation_max = 2.0;
        assert!(config.validate().is_err());
    }

    #[test]
    fn test_invalid_threshold_order() {
        let mut config = PhaseConfig::default();
        config.encoding_threshold = 0.8;
        config.consolidation_threshold = 0.4;
        assert!(config.validate().is_err());
    }

    #[test]
    fn test_serde_roundtrip() {
        let config = PhaseConfig::default();
        let json = serde_json::to_string(&config).unwrap();
        let deserialized: PhaseConfig = serde_json::from_str(&json).unwrap();
        assert_eq!(config.base_frequency, deserialized.base_frequency);
    }

    #[test]
    fn test_builder_pattern() {
        let config = PhaseConfig::builder()
            .base_frequency(0.2)
            .modulation_range(0.2, 2.0)
            .encoding_threshold(0.25)
            .consolidation_threshold(0.75)
            .build()
            .unwrap();

        assert_eq!(config.base_frequency, 0.2);
        assert_eq!(config.modulation_min, 0.2);
        assert_eq!(config.modulation_max, 2.0);
    }
}
```

---

## YAML Configuration Example

```yaml
phase:
  base_frequency: 0.1
  modulation_min: 0.1
  modulation_max: 3.0
  encoding_threshold: 0.33
  consolidation_threshold: 0.67
  consolidation_phase_threshold: 2.1
  consolidation_importance_threshold: 0.4
  consolidation_staleness_seconds: 300
```

---

## File Structure

```
crates/context-graph-utl/
  src/
    config.rs           <- Implementation file (add PhaseConfig here)
  tests/
    config_tests.rs     <- Test file
```

---

## Dependencies

- `serde`: Serialization/deserialization
- `std::f32::consts::PI`: For phase threshold validation

---

## Notes

- PhaseConfig is part of the larger UtlConfig structure
- The phase oscillator models biological theta rhythms (~4-8 Hz in hippocampus)
- The default frequency (0.1 Hz) provides 10-second oscillation periods for testing
- Real-time applications may use faster frequencies
- Modulation allows external systems to speed up or slow down phase transitions
