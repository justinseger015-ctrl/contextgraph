# M05-T50: Implement Predictive Coding Interface Stubs

## Task Metadata
- **ID**: M05-T50
- **Title**: Implement Predictive Coding Interface Stubs
- **Module**: 05 - UTL Integration
- **Layer**: completion
- **Priority**: medium
- **Estimated Hours**: 2

## Description

Create predictive coding interface stubs for L5→L1 prediction error flow.
Per constitution.yaml pred_coding section:
- L5 generates predictions, L1 computes prediction error
- Error = observation - prediction
- Only propagate surprise (large errors)
- ~30% token reduction for predictable content

Create PredictiveCodingInterface trait with:
- generate_prediction(context) -> Prediction
- compute_prediction_error(observation, prediction) -> f32
- should_propagate_error(error) -> bool

Stub implementation passes through all content until Module 7.

## File Path

`crates/context-graph-utl/src/predictive/interface.rs`

## Dependencies

| Task ID | Task Title | Status |
|---------|------------|--------|
| M05-T22 | UtlProcessor Orchestrator | pending |

## Acceptance Criteria

- [ ] PredictiveCodingInterface trait defined
- [ ] Stub implementation returns all content (no reduction)
- [ ] compute_prediction_error() returns delta
- [ ] should_propagate_error() threshold configurable
- [ ] Interface ready for Module 7 implementation

## Test File

`crates/context-graph-utl/tests/predictive_tests.rs`

## Specification References

- constitution.yaml pred_coding
- PRD Section 2.1 (5-Layer System)

## Implementation Notes

### Trait Definition

```rust
/// Predictive coding interface for L5→L1 prediction error flow.
///
/// Per constitution.yaml pred_coding section, this implements
/// hierarchical predictive coding where higher layers generate
/// predictions and lower layers compute prediction errors.
pub trait PredictiveCodingInterface: Send + Sync {
    /// Generate a prediction based on current context.
    /// L5 generates predictions for L1 observations.
    fn generate_prediction(&self, context: &[u8]) -> Prediction;

    /// Compute prediction error as delta between observation and prediction.
    /// Error = observation - prediction
    fn compute_prediction_error(&self, observation: &[u8], prediction: &Prediction) -> f32;

    /// Determine if error is surprising enough to propagate.
    /// Only large errors (surprises) should be propagated.
    fn should_propagate_error(&self, error: f32) -> bool;
}
```

### Prediction Struct

```rust
/// Represents a prediction from L5 to L1.
#[derive(Debug, Clone)]
pub struct Prediction {
    /// Predicted content representation
    pub content: Vec<u8>,
    /// Confidence in this prediction [0, 1]
    pub confidence: f32,
    /// Timestamp of prediction generation
    pub timestamp: std::time::Instant,
}
```

### Stub Implementation

```rust
/// Stub implementation that passes through all content until Module 7.
pub struct StubPredictiveCoding {
    /// Threshold for error propagation (configurable)
    pub error_threshold: f32,
}

impl Default for StubPredictiveCoding {
    fn default() -> Self {
        Self {
            // High threshold means all errors propagate (no reduction)
            error_threshold: 0.0,
        }
    }
}

impl PredictiveCodingInterface for StubPredictiveCoding {
    fn generate_prediction(&self, _context: &[u8]) -> Prediction {
        // Stub: Return empty prediction (no prediction capability yet)
        Prediction {
            content: Vec::new(),
            confidence: 0.0,
            timestamp: std::time::Instant::now(),
        }
    }

    fn compute_prediction_error(&self, observation: &[u8], prediction: &Prediction) -> f32 {
        // Stub: Return maximum error (all content is "surprising")
        if prediction.content.is_empty() {
            1.0
        } else {
            // Simple byte-wise difference ratio
            let diff_count = observation.iter()
                .zip(prediction.content.iter())
                .filter(|(a, b)| a != b)
                .count();
            diff_count as f32 / observation.len().max(1) as f32
        }
    }

    fn should_propagate_error(&self, error: f32) -> bool {
        // Stub: Propagate all errors (no filtering)
        error >= self.error_threshold
    }
}
```

### Configuration

```rust
/// Configuration for predictive coding threshold.
#[derive(Debug, Clone, serde::Deserialize)]
pub struct PredictiveCodingConfig {
    /// Error threshold for propagation [0, 1]
    /// Lower values = more content filtered (not passed through)
    /// Default 0.0 = pass all content (stub behavior)
    #[serde(default)]
    pub error_threshold: f32,

    /// Enable predictive coding (false until Module 7)
    #[serde(default)]
    pub enabled: bool,
}
```

## Verification Commands

```bash
# Run predictive coding tests
cargo test -p context-graph-utl predictive

# Verify trait is object-safe
cargo check -p context-graph-utl

# Check documentation
cargo doc -p context-graph-utl --no-deps --open
```

---

*Generated: 2026-01-04*
*Module: 05 - UTL Integration*
*Task: M05-T50*
