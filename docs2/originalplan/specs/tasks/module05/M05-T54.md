# M05-T54: Implement get_graph_manifest UTL Section

## Task Metadata
- **ID**: M05-T54
- **Title**: Implement get_graph_manifest UTL Section
- **Module**: 05 - UTL Integration
- **Layer**: completion
- **Priority**: medium
- **Estimated Hours**: 2

## Description

Extend get_graph_manifest MCP tool with UTL state summary.
Per PRD Section 4.2, this tool returns meta-cognitive system prompt fragment.

Add section for UTL state:
- Current lifecycle stage
- Lambda weights
- Recent Johari quadrant distribution
- Suggested actions based on entropy/coherence
- Threshold breach alerts

Manifest should help agent understand current knowledge state.
Format as natural language guidance, not raw metrics.

## File Path

`crates/context-graph-mcp/src/tools/graph_manifest.rs`

## Dependencies

| Task ID | Task Title | Status |
|---------|------------|--------|
| M05-T22 | UtlProcessor Orchestrator | pending |
| M05-T24 | UtlMetrics and UtlStatus | pending |

## Acceptance Criteria

- [ ] get_graph_manifest includes UTL summary section
- [ ] Natural language format for agent consumption
- [ ] Lifecycle stage clearly communicated
- [ ] Actionable suggestions included
- [ ] Backward compatible response schema

## Test File

`crates/context-graph-mcp/tests/graph_manifest_utl_tests.rs`

## Specification References

- PRD Section 4.2 (get_graph_manifest)
- constitution.yaml agent.session_start

## Implementation Notes

### UTL Manifest Section

```rust
use context_graph_utl::{LifecycleStage, JohariQuadrant, UtlMetrics};

/// UTL state summary for graph manifest.
#[derive(Debug, Clone, serde::Serialize)]
pub struct UtlManifestSection {
    /// Natural language summary of current state
    pub summary: String,
    /// Current lifecycle stage
    pub lifecycle_stage: LifecycleStage,
    /// Lambda weight description
    pub learning_focus: String,
    /// Recent quadrant distribution
    pub knowledge_confidence: KnowledgeConfidenceReport,
    /// Actionable suggestions
    pub suggestions: Vec<String>,
    /// Active alerts
    pub alerts: Vec<ManifestAlert>,
}

/// Knowledge confidence report based on Johari distribution.
#[derive(Debug, Clone, serde::Serialize)]
pub struct KnowledgeConfidenceReport {
    /// Percentage in Open quadrant (high confidence)
    pub confident_knowledge_pct: f32,
    /// Percentage in Blind quadrant (uncertain)
    pub uncertain_knowledge_pct: f32,
    /// Percentage in Hidden quadrant (stale)
    pub stale_knowledge_pct: f32,
    /// Percentage in Unknown quadrant (novel)
    pub novel_context_pct: f32,
    /// Natural language interpretation
    pub interpretation: String,
}

/// Alert for threshold breaches or important state changes.
#[derive(Debug, Clone, serde::Serialize)]
pub struct ManifestAlert {
    /// Alert level
    pub level: AlertLevel,
    /// Alert message
    pub message: String,
    /// Suggested action
    pub suggested_action: Option<String>,
}

#[derive(Debug, Clone, serde::Serialize)]
pub enum AlertLevel {
    Info,
    Warning,
    Critical,
}
```

### Natural Language Generation

```rust
impl UtlManifestSection {
    /// Generate UTL manifest section from metrics and state.
    pub fn from_metrics(metrics: &UtlMetrics, thresholds: &ThresholdState) -> Self {
        let lifecycle_stage = metrics.lifecycle_stage;

        // Generate natural language summary
        let summary = Self::generate_summary(metrics);

        // Describe learning focus based on lambda weights
        let learning_focus = Self::describe_learning_focus(metrics);

        // Generate confidence report
        let knowledge_confidence = Self::generate_confidence_report(metrics);

        // Generate actionable suggestions
        let suggestions = Self::generate_suggestions(metrics, thresholds);

        // Check for alerts
        let alerts = Self::check_alerts(metrics, thresholds);

        Self {
            summary,
            lifecycle_stage,
            learning_focus,
            knowledge_confidence,
            suggestions,
            alerts,
        }
    }

    fn generate_summary(metrics: &UtlMetrics) -> String {
        let stage_desc = match metrics.lifecycle_stage {
            LifecycleStage::Infancy => "early learning phase, prioritizing novel information",
            LifecycleStage::Growth => "growth phase, balancing exploration and consolidation",
            LifecycleStage::Maturity => "mature phase, focusing on coherence and refinement",
        };

        let coherence_desc = if metrics.coherence > 0.7 {
            "Knowledge base is well-organized and consistent"
        } else if metrics.coherence > 0.4 {
            "Knowledge base has moderate consistency"
        } else {
            "Knowledge base may benefit from consolidation"
        };

        format!(
            "The knowledge system is in its {}. {}. Current learning magnitude: {:.2}.",
            stage_desc,
            coherence_desc,
            metrics.learning_magnitude
        )
    }

    fn describe_learning_focus(metrics: &UtlMetrics) -> String {
        let novelty_pct = (metrics.lambda_novelty * 100.0) as u32;
        let consolidation_pct = (metrics.lambda_consolidation * 100.0) as u32;

        format!(
            "Learning weights: {}% novelty (new information), {}% consolidation (strengthening existing knowledge)",
            novelty_pct,
            consolidation_pct
        )
    }

    fn generate_confidence_report(metrics: &UtlMetrics) -> KnowledgeConfidenceReport {
        let dist = &metrics.johari_distribution;

        let interpretation = if dist.open > 0.6 {
            "Most knowledge is well-established and reliable"
        } else if dist.unknown > 0.4 {
            "Significant novel context detected; exploration recommended"
        } else if dist.hidden > 0.3 {
            "Some knowledge may be stale; consider refreshing context"
        } else if dist.blind > 0.3 {
            "Uncertainty detected; clarification may help"
        } else {
            "Knowledge state is balanced across confidence levels"
        };

        KnowledgeConfidenceReport {
            confident_knowledge_pct: dist.open * 100.0,
            uncertain_knowledge_pct: dist.blind * 100.0,
            stale_knowledge_pct: dist.hidden * 100.0,
            novel_context_pct: dist.unknown * 100.0,
            interpretation: interpretation.into(),
        }
    }

    fn generate_suggestions(metrics: &UtlMetrics, thresholds: &ThresholdState) -> Vec<String> {
        let mut suggestions = Vec::new();

        if metrics.entropy > 0.7 {
            suggestions.push(
                "High entropy detected. Consider organizing or consolidating recent information.".into()
            );
        }

        if metrics.coherence < 0.4 {
            suggestions.push(
                "Low coherence detected. Clarifying questions may help establish context.".into()
            );
        }

        if metrics.johari_distribution.unknown > 0.4 {
            suggestions.push(
                "Novel context detected. Broader exploration may yield relevant connections.".into()
            );
        }

        if metrics.johari_distribution.hidden > 0.3 {
            suggestions.push(
                "Some stored knowledge may be outdated. Consider refreshing temporal context.".into()
            );
        }

        if thresholds.near_lifecycle_transition {
            suggestions.push(format!(
                "Approaching {} lifecycle stage. Learning priorities will shift.",
                thresholds.next_lifecycle_stage.map(|s| format!("{:?}", s)).unwrap_or_default()
            ));
        }

        suggestions
    }

    fn check_alerts(metrics: &UtlMetrics, thresholds: &ThresholdState) -> Vec<ManifestAlert> {
        let mut alerts = Vec::new();

        if thresholds.entropy_breach {
            alerts.push(ManifestAlert {
                level: AlertLevel::Warning,
                message: "Entropy has been above 0.7 for extended period".into(),
                suggested_action: Some("Consider triggering consolidation or dream cycle".into()),
            });
        }

        if thresholds.coherence_breach {
            alerts.push(ManifestAlert {
                level: AlertLevel::Warning,
                message: "Coherence has dropped below 0.4".into(),
                suggested_action: Some("Process curation tasks to improve consistency".into()),
            });
        }

        if metrics.entropy > 0.8 {
            alerts.push(ManifestAlert {
                level: AlertLevel::Critical,
                message: "Very high entropy detected - tool gating may be restricted".into(),
                suggested_action: Some("Reduce information intake or consolidate knowledge".into()),
            });
        }

        alerts
    }
}
```

### Integration with Graph Manifest

```rust
/// Extended graph manifest with UTL section.
#[derive(Debug, Clone, serde::Serialize)]
pub struct GraphManifest {
    /// Graph statistics
    pub graph_stats: GraphStats,
    /// Schema information
    pub schema: SchemaInfo,
    /// Available tools summary
    pub available_tools: Vec<ToolSummary>,
    /// UTL state section (NEW)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub utl_state: Option<UtlManifestSection>,
    /// Manifest generation timestamp
    pub generated_at: chrono::DateTime<chrono::Utc>,
}

impl GraphManifest {
    /// Generate manifest with optional UTL section.
    pub fn generate(
        graph: &KnowledgeGraph,
        utl_processor: Option<&UtlProcessor>,
        thresholds: Option<&ThresholdState>,
    ) -> Self {
        let utl_state = utl_processor.map(|proc| {
            let metrics = proc.get_metrics();
            let thresholds = thresholds.cloned().unwrap_or_default();
            UtlManifestSection::from_metrics(&metrics, &thresholds)
        });

        Self {
            graph_stats: graph.get_stats(),
            schema: graph.get_schema(),
            available_tools: get_available_tools(),
            utl_state,
            generated_at: chrono::Utc::now(),
        }
    }
}
```

### Backward Compatibility

```rust
impl GraphManifest {
    /// Convert to legacy format without UTL section.
    pub fn to_legacy(&self) -> LegacyGraphManifest {
        LegacyGraphManifest {
            graph_stats: self.graph_stats.clone(),
            schema: self.schema.clone(),
            available_tools: self.available_tools.clone(),
            generated_at: self.generated_at,
            // utl_state intentionally omitted
        }
    }

    /// Check if this is a legacy request (no UTL support expected).
    pub fn should_include_utl(&self, request: &ManifestRequest) -> bool {
        request.include_utl.unwrap_or(true)
    }
}

/// Request parameters for graph manifest.
#[derive(Debug, Clone, serde::Deserialize, Default)]
pub struct ManifestRequest {
    /// Include UTL section (default: true)
    #[serde(default = "default_include_utl")]
    pub include_utl: Option<bool>,
}

fn default_include_utl() -> Option<bool> { Some(true) }
```

### Example Output

```json
{
  "graph_stats": { "node_count": 1542, "edge_count": 3891 },
  "schema": { ... },
  "available_tools": [ ... ],
  "utl_state": {
    "summary": "The knowledge system is in its growth phase, balancing exploration and consolidation. Knowledge base has moderate consistency. Current learning magnitude: 0.42.",
    "lifecycle_stage": "Growth",
    "learning_focus": "Learning weights: 60% novelty (new information), 40% consolidation (strengthening existing knowledge)",
    "knowledge_confidence": {
      "confident_knowledge_pct": 45.2,
      "uncertain_knowledge_pct": 22.1,
      "stale_knowledge_pct": 18.3,
      "novel_context_pct": 14.4,
      "interpretation": "Knowledge state is balanced across confidence levels"
    },
    "suggestions": [
      "Some stored knowledge may be outdated. Consider refreshing temporal context."
    ],
    "alerts": []
  },
  "generated_at": "2026-01-04T10:30:00Z"
}
```

## Verification Commands

```bash
# Run graph manifest UTL tests
cargo test -p context-graph-mcp graph_manifest_utl

# Verify natural language output quality
cargo test -p context-graph-mcp manifest_natural_language

# Check backward compatibility
cargo test -p context-graph-mcp manifest_legacy_compat

# Verify JSON serialization
cargo test -p context-graph-mcp manifest_serialize

# Performance test
cargo test -p context-graph-mcp manifest_generation_perf --release
```

---

*Generated: 2026-01-04*
*Module: 05 - UTL Integration*
*Task: M05-T54*
