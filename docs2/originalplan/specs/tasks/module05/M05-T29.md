# M05-T29: Extend MemoryNode with UTL Fields

```yaml
metadata:
  id: "M05-T29"
  title: "Extend MemoryNode with UTL Fields"
  module: "module-05"
  module_name: "UTL Integration"
  layer: "integration"
  priority: "critical"
  estimated_hours: 3
  created: "2026-01-04"
  status: "pending"
  dependencies:
    - "M05-T21"
    - "M05-T08"
  spec_refs:
    - "SPEC-UTL-005 Section 11.1"
```

## Description

Extend MemoryNode struct in context-graph-core with UTL-specific fields:
- Add: utl_state (Option<UtlState>), johari_quadrant (JohariQuadrant), observer_perspective (Option<ObserverPerspective>), priors_vibe_check (Option<PriorsVibeCheck>)
- ObserverPerspective: domain (String), confidence_priors (HashMap<String, f32>)
- PriorsVibeCheck: assumption_embedding ([f32; 128]), domain_priors (Vec<String>), prior_confidence (f32)
- Update serialization and storage layer
- Handle backward compatibility with existing node data

## File Locations

| Type | Path |
|------|------|
| Implementation | `crates/context-graph-core/src/types/memory_node.rs` |
| Test File | `crates/context-graph-core/tests/memory_node_utl_tests.rs` |

## Acceptance Criteria

- [ ] MemoryNode has all 4 new optional fields
- [ ] ObserverPerspective struct implemented
- [ ] PriorsVibeCheck struct with 128-dim embedding
- [ ] RocksDB serialization updated
- [ ] Existing node data migration handled
- [ ] Backward compatible with old nodes

## Technical Requirements

### UtlState Struct (from M05-T21)

```rust
// crates/context-graph-utl/src/lib.rs (re-exported)

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};

/// UTL state snapshot for storage in MemoryNode
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UtlState {
    /// Surprise/entropy at time of storage
    pub delta_s: f32,

    /// Coherence at time of storage
    pub delta_c: f32,

    /// Emotional weight at time of storage
    pub w_e: f32,

    /// Phase angle at time of storage
    pub phi: f32,

    /// Computed learning magnitude
    pub learning_magnitude: f32,

    /// Johari quadrant classification
    pub quadrant: JohariQuadrant,

    /// Timestamp of last computation
    pub last_computed: DateTime<Utc>,
}

impl Default for UtlState {
    fn default() -> Self {
        Self {
            delta_s: 0.0,
            delta_c: 1.0,
            w_e: 1.0,
            phi: 0.0,
            learning_magnitude: 0.0,
            quadrant: JohariQuadrant::Open,
            last_computed: Utc::now(),
        }
    }
}
```

### JohariQuadrant Enum (from M05-T08)

```rust
// crates/context-graph-utl/src/johari/quadrant.rs (re-exported)

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[repr(u8)]
pub enum JohariQuadrant {
    /// Low entropy, high coherence - well understood
    Open = 0,
    /// High entropy, low coherence - surprising and inconsistent
    Blind = 1,
    /// Low entropy, low coherence - hidden but consistent
    Hidden = 2,
    /// High entropy, high coherence - surprising but fits
    Unknown = 3,
}

impl Default for JohariQuadrant {
    fn default() -> Self {
        Self::Open
    }
}

impl JohariQuadrant {
    pub fn name(&self) -> &'static str {
        match self {
            Self::Open => "Open",
            Self::Blind => "Blind",
            Self::Hidden => "Hidden",
            Self::Unknown => "Unknown",
        }
    }
}
```

### New UTL Types for MemoryNode

```rust
// crates/context-graph-core/src/types/memory_node.rs

use std::collections::HashMap;
use serde::{Deserialize, Serialize};

/// Observer perspective for priors-aware reasoning
/// Tracks domain-specific confidence priors
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ObserverPerspective {
    /// Domain of expertise (e.g., "software_engineering", "medicine")
    pub domain: String,

    /// Confidence priors per concept type
    /// Maps concept type -> confidence in [0, 1]
    pub confidence_priors: HashMap<String, f32>,
}

impl Default for ObserverPerspective {
    fn default() -> Self {
        Self {
            domain: String::new(),
            confidence_priors: HashMap::new(),
        }
    }
}

impl ObserverPerspective {
    pub fn new(domain: impl Into<String>) -> Self {
        Self {
            domain: domain.into(),
            confidence_priors: HashMap::new(),
        }
    }

    pub fn with_prior(mut self, concept_type: impl Into<String>, confidence: f32) -> Self {
        self.confidence_priors.insert(concept_type.into(), confidence.clamp(0.0, 1.0));
        self
    }

    pub fn get_confidence(&self, concept_type: &str) -> Option<f32> {
        self.confidence_priors.get(concept_type).copied()
    }
}

/// Priors vibe check for assumption validation
/// Embeds domain assumptions for coherence checking
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PriorsVibeCheck {
    /// 128-dimensional embedding of domain assumptions
    /// Compressed representation for fast similarity checking
    pub assumption_embedding: [f32; 128],

    /// List of domain prior identifiers
    pub domain_priors: Vec<String>,

    /// Overall confidence in prior set in [0, 1]
    pub prior_confidence: f32,
}

impl Default for PriorsVibeCheck {
    fn default() -> Self {
        Self {
            assumption_embedding: [0.0; 128],
            domain_priors: Vec::new(),
            prior_confidence: 0.5,
        }
    }
}

impl PriorsVibeCheck {
    pub fn new(embedding: [f32; 128]) -> Self {
        Self {
            assumption_embedding: embedding,
            domain_priors: Vec::new(),
            prior_confidence: 0.5,
        }
    }

    pub fn with_priors(mut self, priors: Vec<String>) -> Self {
        self.domain_priors = priors;
        self
    }

    pub fn with_confidence(mut self, confidence: f32) -> Self {
        self.prior_confidence = confidence.clamp(0.0, 1.0);
        self
    }

    /// Compute similarity with another vibe check
    pub fn similarity(&self, other: &PriorsVibeCheck) -> f32 {
        let dot: f32 = self.assumption_embedding.iter()
            .zip(other.assumption_embedding.iter())
            .map(|(a, b)| a * b)
            .sum();

        let mag_a: f32 = self.assumption_embedding.iter().map(|x| x * x).sum::<f32>().sqrt();
        let mag_b: f32 = other.assumption_embedding.iter().map(|x| x * x).sum::<f32>().sqrt();

        if mag_a == 0.0 || mag_b == 0.0 {
            0.0
        } else {
            dot / (mag_a * mag_b)
        }
    }
}
```

### Extended MemoryNode

```rust
// crates/context-graph-core/src/types/memory_node.rs

use context_graph_utl::{UtlState, JohariQuadrant};

/// Memory node with UTL integration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MemoryNode {
    // ============================================
    // EXISTING FIELDS (preserved for compatibility)
    // ============================================

    /// Unique node identifier
    pub id: Uuid,

    /// Raw content text
    pub content: String,

    /// Embedding vector (1536 dimensions for text-embedding-3-large)
    pub embedding: Vec<f32>,

    /// Node importance score in [0, 1]
    pub importance: f32,

    /// Creation timestamp
    pub created_at: DateTime<Utc>,

    /// Last access timestamp
    pub accessed_at: DateTime<Utc>,

    /// Access count for recency calculation
    pub access_count: u64,

    /// Node metadata (tags, source, etc.)
    pub metadata: HashMap<String, String>,

    /// Associated session ID
    pub session_id: Option<Uuid>,

    // ============================================
    // NEW UTL FIELDS (v1.3.0)
    // ============================================

    /// UTL state at time of creation/last update
    /// None for nodes created before UTL integration
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub utl_state: Option<UtlState>,

    /// Johari quadrant classification
    /// Defaults to Open for backward compatibility
    #[serde(default)]
    pub johari_quadrant: JohariQuadrant,

    /// Observer perspective for priors-aware reasoning
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub observer_perspective: Option<ObserverPerspective>,

    /// Priors vibe check for assumption validation
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub priors_vibe_check: Option<PriorsVibeCheck>,
}

impl MemoryNode {
    /// Create a new memory node with UTL state
    pub fn new_with_utl(
        content: String,
        embedding: Vec<f32>,
        importance: f32,
        utl_state: UtlState,
    ) -> Self {
        let now = Utc::now();
        Self {
            id: Uuid::new_v4(),
            content,
            embedding,
            importance,
            created_at: now,
            accessed_at: now,
            access_count: 0,
            metadata: HashMap::new(),
            session_id: None,
            utl_state: Some(utl_state.clone()),
            johari_quadrant: utl_state.quadrant,
            observer_perspective: None,
            priors_vibe_check: None,
        }
    }

    /// Update UTL state
    pub fn update_utl_state(&mut self, state: UtlState) {
        self.johari_quadrant = state.quadrant;
        self.utl_state = Some(state);
    }

    /// Set observer perspective
    pub fn with_observer_perspective(mut self, perspective: ObserverPerspective) -> Self {
        self.observer_perspective = Some(perspective);
        self
    }

    /// Set priors vibe check
    pub fn with_priors_vibe_check(mut self, vibe_check: PriorsVibeCheck) -> Self {
        self.priors_vibe_check = Some(vibe_check);
        self
    }

    /// Get learning magnitude from UTL state
    pub fn learning_magnitude(&self) -> f32 {
        self.utl_state.as_ref()
            .map(|s| s.learning_magnitude)
            .unwrap_or(0.0)
    }

    /// Check if node has UTL state
    pub fn has_utl_state(&self) -> bool {
        self.utl_state.is_some()
    }
}

// Backward compatibility: Default for new optional fields
impl Default for MemoryNode {
    fn default() -> Self {
        Self {
            id: Uuid::new_v4(),
            content: String::new(),
            embedding: Vec::new(),
            importance: 0.0,
            created_at: Utc::now(),
            accessed_at: Utc::now(),
            access_count: 0,
            metadata: HashMap::new(),
            session_id: None,
            utl_state: None,
            johari_quadrant: JohariQuadrant::default(),
            observer_perspective: None,
            priors_vibe_check: None,
        }
    }
}
```

### RocksDB Serialization Update

```rust
// crates/context-graph-storage/src/rocksdb/node_store.rs

use bincode::{serialize, deserialize};

impl NodeStore {
    /// Serialize node with version header for migration
    pub fn serialize_node(&self, node: &MemoryNode) -> Result<Vec<u8>, StorageError> {
        // Version 2 includes UTL fields
        let version: u8 = 2;
        let mut data = vec![version];

        let node_bytes = serialize(node)
            .map_err(|e| StorageError::Serialization(e.to_string()))?;
        data.extend(node_bytes);

        Ok(data)
    }

    /// Deserialize node with version-aware migration
    pub fn deserialize_node(&self, data: &[u8]) -> Result<MemoryNode, StorageError> {
        if data.is_empty() {
            return Err(StorageError::EmptyData);
        }

        let version = data[0];
        let node_data = &data[1..];

        match version {
            1 => {
                // V1: Old format without UTL fields
                let old_node: MemoryNodeV1 = deserialize(node_data)
                    .map_err(|e| StorageError::Deserialization(e.to_string()))?;
                Ok(old_node.migrate_to_v2())
            }
            2 => {
                // V2: Current format with UTL fields
                deserialize(node_data)
                    .map_err(|e| StorageError::Deserialization(e.to_string()))
            }
            _ => Err(StorageError::UnsupportedVersion(version)),
        }
    }
}

/// V1 node format for migration
#[derive(Deserialize)]
struct MemoryNodeV1 {
    id: Uuid,
    content: String,
    embedding: Vec<f32>,
    importance: f32,
    created_at: DateTime<Utc>,
    accessed_at: DateTime<Utc>,
    access_count: u64,
    metadata: HashMap<String, String>,
    session_id: Option<Uuid>,
}

impl MemoryNodeV1 {
    fn migrate_to_v2(self) -> MemoryNode {
        MemoryNode {
            id: self.id,
            content: self.content,
            embedding: self.embedding,
            importance: self.importance,
            created_at: self.created_at,
            accessed_at: self.accessed_at,
            access_count: self.access_count,
            metadata: self.metadata,
            session_id: self.session_id,
            // New UTL fields with defaults
            utl_state: None,
            johari_quadrant: JohariQuadrant::default(),
            observer_perspective: None,
            priors_vibe_check: None,
        }
    }
}
```

## Dependencies

### Required Tasks
- M05-T21: LearningSignal and UtlState Structs
- M05-T08: JohariQuadrant Enum and SuggestedAction

### Required Crates
```toml
[dependencies]
serde = { version = "1.0", features = ["derive"] }
bincode = "1.3"
uuid = { version = "1.0", features = ["v4", "serde"] }
chrono = { version = "0.4", features = ["serde"] }
```

## Test Cases

```rust
// crates/context-graph-core/tests/memory_node_utl_tests.rs

use context_graph_core::types::{MemoryNode, ObserverPerspective, PriorsVibeCheck};
use context_graph_utl::{UtlState, JohariQuadrant};

#[test]
fn test_memory_node_with_utl_state() {
    let utl_state = UtlState {
        delta_s: 0.6,
        delta_c: 0.8,
        w_e: 1.2,
        phi: 1.0,
        learning_magnitude: 0.55,
        quadrant: JohariQuadrant::Open,
        last_computed: Utc::now(),
    };

    let node = MemoryNode::new_with_utl(
        "Test content".to_string(),
        vec![0.1; 1536],
        0.5,
        utl_state,
    );

    assert!(node.has_utl_state());
    assert!((node.learning_magnitude() - 0.55).abs() < 0.001);
    assert_eq!(node.johari_quadrant, JohariQuadrant::Open);
}

#[test]
fn test_observer_perspective() {
    let perspective = ObserverPerspective::new("software_engineering")
        .with_prior("design_pattern", 0.8)
        .with_prior("algorithm", 0.9);

    assert_eq!(perspective.domain, "software_engineering");
    assert!((perspective.get_confidence("design_pattern").unwrap() - 0.8).abs() < 0.001);
    assert!((perspective.get_confidence("algorithm").unwrap() - 0.9).abs() < 0.001);
    assert!(perspective.get_confidence("unknown").is_none());
}

#[test]
fn test_priors_vibe_check() {
    let embedding1 = [0.5f32; 128];
    let embedding2 = [0.5f32; 128];

    let vibe1 = PriorsVibeCheck::new(embedding1)
        .with_priors(vec!["rust".to_string(), "systems".to_string()])
        .with_confidence(0.85);

    let vibe2 = PriorsVibeCheck::new(embedding2);

    // Same embeddings should have similarity ~1.0
    let sim = vibe1.similarity(&vibe2);
    assert!(sim > 0.99);

    assert_eq!(vibe1.domain_priors.len(), 2);
    assert!((vibe1.prior_confidence - 0.85).abs() < 0.001);
}

#[test]
fn test_backward_compatibility_serialization() {
    // Simulate V1 node data (without UTL fields)
    let v1_data = create_v1_node_bytes();

    let store = NodeStore::new_test();
    let node = store.deserialize_node(&v1_data).unwrap();

    // Should have defaults for new fields
    assert!(node.utl_state.is_none());
    assert_eq!(node.johari_quadrant, JohariQuadrant::Open);
    assert!(node.observer_perspective.is_none());
    assert!(node.priors_vibe_check.is_none());
}

#[test]
fn test_v2_round_trip_serialization() {
    let utl_state = UtlState::default();
    let node = MemoryNode::new_with_utl(
        "Test content".to_string(),
        vec![0.1; 1536],
        0.5,
        utl_state,
    )
    .with_observer_perspective(ObserverPerspective::new("test"))
    .with_priors_vibe_check(PriorsVibeCheck::default());

    let store = NodeStore::new_test();
    let bytes = store.serialize_node(&node).unwrap();
    let deserialized = store.deserialize_node(&bytes).unwrap();

    assert_eq!(node.id, deserialized.id);
    assert!(deserialized.utl_state.is_some());
    assert!(deserialized.observer_perspective.is_some());
    assert!(deserialized.priors_vibe_check.is_some());
}

#[test]
fn test_johari_quadrant_default() {
    let node = MemoryNode::default();
    assert_eq!(node.johari_quadrant, JohariQuadrant::Open);
}
```

## Verification

```bash
# Run tests
cargo test --package context-graph-core --test memory_node_utl_tests

# Test serialization compatibility
cargo test --package context-graph-storage serialization

# Check for breaking changes
cargo semver-checks check-release
```

## Notes

- New fields use `#[serde(default, skip_serializing_if = "Option::is_none")]` for backward compatibility
- Version header in serialization enables future migrations
- V1 nodes automatically migrated to V2 on read (lazy migration)
- PriorsVibeCheck uses 128-dim embedding (compressed from 1536) for efficiency
- All new fields are optional to avoid breaking existing data
