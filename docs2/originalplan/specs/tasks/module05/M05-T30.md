# M05-T30: Implement SessionContext for UTL Computation

```yaml
task_id: M05-T30
title: "Implement SessionContext for UTL Computation"
module: "module-05-utl-integration"
layer: "integration"
priority: "high"
status: "pending"
estimated_hours: 2
created: "2026-01-04"
dependencies:
  - M05-T22  # UtlProcessor Main Orchestrator
spec_refs:
  - "SPEC-UTL-005 Section 11.2"
file_path: "crates/context-graph-utl/src/context.rs"
test_file: "crates/context-graph-utl/tests/context_tests.rs"
```

---

## Description

Implement SessionContext struct for maintaining UTL computation context across interactions within a session. This struct tracks recent nodes, current entropy/coherence values, and interaction counts to provide contextual information for UTL computations.

The SessionContext integrates with the session management system from Module 2 to provide session-scoped UTL state that persists across multiple interactions.

---

## Implementation Requirements

### SessionContext Struct

```rust
use chrono::{DateTime, Utc};
use uuid::Uuid;

/// Maintains UTL computation context for a session.
///
/// Tracks recent memory nodes, current entropy/coherence values, and interaction
/// counts to provide contextual information for UTL computations.
#[derive(Debug, Clone)]
pub struct SessionContext {
    /// Unique identifier for this session
    pub session_id: Uuid,

    /// Recent memory nodes for context (rolling window)
    pub recent_nodes: Vec<MemoryNode>,

    /// Current entropy value (delta_s) for the session
    pub current_entropy: f32,

    /// Current coherence value (delta_c) for the session
    pub current_coherence: f32,

    /// Total number of interactions in this session
    pub interaction_count: u64,

    /// Timestamp of last activity in this session
    pub last_activity: DateTime<Utc>,
}
```

### Required Methods

| Method | Signature | Description |
|--------|-----------|-------------|
| `new` | `fn new(session_id: Uuid) -> Self` | Create new context with given session ID |
| `new_empty` | `fn new_empty() -> Self` | Create context with default values and new UUID |
| `update_with_node` | `fn update_with_node(&mut self, node: MemoryNode)` | Add node to recent_nodes and update activity |
| `get_context_embeddings` | `fn get_context_embeddings(&self) -> Vec<&[f32]>` | Return embedding slices from recent nodes |
| `clear` | `fn clear(&mut self)` | Reset context to empty state while preserving session_id |
| `is_stale` | `fn is_stale(&self, threshold_seconds: u64) -> bool` | Check if last activity exceeds threshold |

### Method Specifications

#### `new(session_id: Uuid) -> Self`

```rust
impl SessionContext {
    pub fn new(session_id: Uuid) -> Self {
        Self {
            session_id,
            recent_nodes: Vec::new(),
            current_entropy: 0.0,
            current_coherence: 0.5, // Default mid-coherence
            interaction_count: 0,
            last_activity: Utc::now(),
        }
    }
}
```

#### `new_empty() -> Self`

Creates a context with:
- New random UUID for session_id
- Empty recent_nodes vector
- `current_entropy = 0.0`
- `current_coherence = 0.5`
- `interaction_count = 0`
- `last_activity = Utc::now()`

#### `update_with_node(&mut self, node: MemoryNode)`

1. Add node to `recent_nodes` (push to back)
2. Maintain maximum window size (configurable, default 50)
3. Evict oldest nodes when at capacity
4. Increment `interaction_count`
5. Update `last_activity` to current time
6. Optionally update `current_entropy`/`current_coherence` if node has UTL state

#### `get_context_embeddings(&self) -> Vec<&[f32]>`

Returns a vector of references to embedding slices from all `recent_nodes`. Used by `SurpriseCalculator` for context-aware surprise computation.

#### `clear(&mut self)`

```rust
pub fn clear(&mut self) {
    self.recent_nodes.clear();
    self.current_entropy = 0.0;
    self.current_coherence = 0.5;
    self.interaction_count = 0;
    self.last_activity = Utc::now();
    // session_id preserved
}
```

#### `is_stale(&self, threshold_seconds: u64) -> bool`

```rust
pub fn is_stale(&self, threshold_seconds: u64) -> bool {
    let elapsed = Utc::now()
        .signed_duration_since(self.last_activity)
        .num_seconds() as u64;
    elapsed > threshold_seconds
}
```

---

## Integration with Session Manager

The SessionContext must integrate with the existing session management from Module 2:

```rust
/// Integration trait for session management
pub trait SessionContextProvider {
    /// Get or create session context for given session ID
    fn get_session_context(&self, session_id: Uuid) -> SessionContext;

    /// Store updated session context
    fn store_session_context(&self, context: SessionContext);

    /// Remove stale session contexts
    fn cleanup_stale_sessions(&self, threshold_seconds: u64);
}
```

---

## Configuration

The SessionContext should respect the following configuration parameters:

| Parameter | Default | Description |
|-----------|---------|-------------|
| `max_recent_nodes` | 50 | Maximum nodes to keep in recent_nodes |
| `stale_threshold_seconds` | 1800 | Session staleness threshold (30 min) |
| `default_coherence` | 0.5 | Default coherence for new sessions |

---

## Acceptance Criteria

- [ ] SessionContext struct with all 6 specified fields
- [ ] `new_empty()` creates context with default values
- [ ] `update_with_node()` adds nodes to recent_nodes correctly
- [ ] `update_with_node()` respects max window size
- [ ] `get_context_embeddings()` returns embedding slices from all recent nodes
- [ ] `clear()` resets state while preserving session_id
- [ ] `is_stale()` correctly computes staleness based on threshold
- [ ] Session integration works with existing session manager from Module 2
- [ ] Clone, Debug traits implemented
- [ ] Unit tests cover all methods

---

## Test Cases

### Unit Tests

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_new_empty() {
        let ctx = SessionContext::new_empty();
        assert!(!ctx.session_id.is_nil());
        assert!(ctx.recent_nodes.is_empty());
        assert_eq!(ctx.current_entropy, 0.0);
        assert_eq!(ctx.current_coherence, 0.5);
        assert_eq!(ctx.interaction_count, 0);
    }

    #[test]
    fn test_update_with_node() {
        let mut ctx = SessionContext::new_empty();
        let node = create_test_node();
        ctx.update_with_node(node);
        assert_eq!(ctx.recent_nodes.len(), 1);
        assert_eq!(ctx.interaction_count, 1);
    }

    #[test]
    fn test_window_eviction() {
        // Test that old nodes are evicted when at capacity
    }

    #[test]
    fn test_is_stale() {
        let mut ctx = SessionContext::new_empty();
        assert!(!ctx.is_stale(60)); // Not stale initially
        // Simulate old activity timestamp
        ctx.last_activity = Utc::now() - chrono::Duration::seconds(120);
        assert!(ctx.is_stale(60)); // Now stale
    }

    #[test]
    fn test_clear_preserves_session_id() {
        let ctx = SessionContext::new_empty();
        let original_id = ctx.session_id;
        let mut ctx = ctx;
        ctx.update_with_node(create_test_node());
        ctx.clear();
        assert_eq!(ctx.session_id, original_id);
        assert!(ctx.recent_nodes.is_empty());
    }

    #[test]
    fn test_get_context_embeddings() {
        // Test that embeddings are correctly extracted
    }
}
```

---

## File Structure

```
crates/context-graph-utl/
  src/
    context.rs        <- Implementation file (this task)
    lib.rs            <- Add mod context; pub use context::*;
  tests/
    context_tests.rs  <- Test file
```

---

## Dependencies

- `chrono`: DateTime handling
- `uuid`: Session ID generation
- `context-graph-core`: MemoryNode type

---

## Notes

- SessionContext is the bridge between session management and UTL computation
- Recent nodes provide context for surprise calculation (KL divergence needs context distribution)
- The staleness check is important for resource management and cleanup
- Integration with Module 2 session manager requires trait implementation
