# M05-T42: Implement Entropy/Coherence Threshold Triggers

## Task Metadata
- **ID**: M05-T42
- **Title**: Implement Entropy/Coherence Threshold Triggers
- **Module**: 05 - UTL Integration
- **Layer**: integration
- **Priority**: high
- **Estimated Hours**: 3
- **Created**: 2026-01-04
- **Status**: pending

## Description

Implement threshold-based triggers as defined in constitution.yaml agent.mental_checks.

Triggers:
- entropy > 0.7 for 5min: emit `trigger_dream` suggestion
- coherence < 0.4: emit `process curation_tasks` suggestion
- entropy > 0.8: emit `tool_gating_warning`

Create ThresholdMonitor struct tracking:
- Rolling entropy average over 5-minute window
- Current coherence state
- Time since last threshold breach

Integrate with CognitivePulse to emit `suggested_action`. Add configurable thresholds in config/utl.yaml.

## File Paths

### Implementation
- `crates/context-graph-utl/src/monitoring/threshold_monitor.rs`

### Tests
- `crates/context-graph-utl/tests/threshold_monitor_tests.rs`

## Dependencies

| Task ID | Title | Status |
|---------|-------|--------|
| M05-T22 | Implement UtlProcessor | pending |
| M05-T28 | Implement CognitivePulse Header | pending |

## Acceptance Criteria

- [ ] ThresholdMonitor tracks rolling entropy/coherence
- [ ] entropy > 0.7 for 5min triggers dream suggestion
- [ ] coherence < 0.4 triggers curation suggestion
- [ ] entropy > 0.8 triggers tool_gating_warning
- [ ] Thresholds configurable in utl.yaml
- [ ] Integrates with CognitivePulse suggested_action
- [ ] Time-based triggers use efficient windowing

## Specification References

- `constitution.yaml agent.mental_checks`
- `PRD Section 3.2 (Cognitive Pulse)`

## Implementation Notes

### Constitution.yaml Mental Checks

```yaml
agent:
  mental_checks:
    high_entropy_sustained:
      threshold: 0.7
      duration: 300  # 5 minutes in seconds
      action: trigger_dream
    low_coherence:
      threshold: 0.4
      action: process_curation_tasks
    critical_entropy:
      threshold: 0.8
      action: tool_gating_warning
```

### ThresholdMonitor Structure

```rust
/// Monitors entropy and coherence for threshold breaches
pub struct ThresholdMonitor {
    /// Rolling entropy samples with timestamps
    entropy_window: VecDeque<(Instant, f32)>,

    /// Window duration (default 5 minutes)
    window_duration: Duration,

    /// Configurable thresholds
    config: ThresholdConfig,

    /// Last breach times for rate limiting
    last_dream_suggestion: Option<Instant>,
    last_curation_suggestion: Option<Instant>,
    last_gating_warning: Option<Instant>,
}

#[derive(Clone)]
pub struct ThresholdConfig {
    pub high_entropy_threshold: f32,      // 0.7
    pub high_entropy_duration: Duration,   // 5min
    pub low_coherence_threshold: f32,      // 0.4
    pub critical_entropy_threshold: f32,   // 0.8
    pub suggestion_cooldown: Duration,     // Prevent spam
}
```

### Trigger Types

```rust
#[derive(Debug, Clone, PartialEq)]
pub enum ThresholdTrigger {
    /// Entropy > 0.7 sustained for 5min
    TriggerDream {
        average_entropy: f32,
        duration_exceeded: Duration,
    },

    /// Coherence < 0.4
    ProcessCurationTasks {
        current_coherence: f32,
    },

    /// Entropy > 0.8 (immediate)
    ToolGatingWarning {
        current_entropy: f32,
    },
}
```

### Core Methods

```rust
impl ThresholdMonitor {
    /// Record new entropy sample
    pub fn record_entropy(&mut self, entropy: f32) {
        self.entropy_window.push_back((Instant::now(), entropy));
        self.prune_old_samples();
    }

    /// Check for threshold breaches
    pub fn check_thresholds(
        &mut self,
        current_entropy: f32,
        current_coherence: f32,
    ) -> Vec<ThresholdTrigger> {
        let mut triggers = Vec::new();

        // Critical entropy check (immediate)
        if current_entropy > self.config.critical_entropy_threshold {
            triggers.push(ThresholdTrigger::ToolGatingWarning {
                current_entropy,
            });
        }

        // Sustained high entropy check
        if self.check_sustained_high_entropy() {
            triggers.push(ThresholdTrigger::TriggerDream {
                average_entropy: self.calculate_average_entropy(),
                duration_exceeded: self.window_duration,
            });
        }

        // Low coherence check
        if current_coherence < self.config.low_coherence_threshold {
            triggers.push(ThresholdTrigger::ProcessCurationTasks {
                current_coherence,
            });
        }

        triggers
    }

    /// Calculate rolling average entropy
    fn calculate_average_entropy(&self) -> f32 {
        if self.entropy_window.is_empty() {
            return 0.0;
        }
        let sum: f32 = self.entropy_window.iter().map(|(_, e)| e).sum();
        sum / self.entropy_window.len() as f32
    }

    /// Check if high entropy sustained for window duration
    fn check_sustained_high_entropy(&self) -> bool {
        // Must have samples spanning the full window
        // All samples must exceed threshold
    }
}
```

### CognitivePulse Integration

```rust
impl CognitivePulse {
    pub fn with_threshold_triggers(
        mut self,
        triggers: Vec<ThresholdTrigger>,
    ) -> Self {
        for trigger in triggers {
            match trigger {
                ThresholdTrigger::TriggerDream { .. } => {
                    self.suggested_action = Some(SuggestedAction::TriggerDream);
                }
                ThresholdTrigger::ProcessCurationTasks { .. } => {
                    self.suggested_action = Some(SuggestedAction::ProcessCurationTasks);
                }
                ThresholdTrigger::ToolGatingWarning { .. } => {
                    self.tool_gating_active = true;
                }
            }
        }
        self
    }
}
```

### Configuration (config/utl.yaml)

```yaml
thresholds:
  high_entropy:
    value: 0.7
    duration_seconds: 300
  low_coherence:
    value: 0.4
  critical_entropy:
    value: 0.8
  suggestion_cooldown_seconds: 60
```

## Performance Considerations

- Use VecDeque for O(1) push/pop at both ends
- Prune old samples lazily during record operations
- Avoid allocations in hot path
- Cooldown prevents trigger spam

## Testing Requirements

1. **Unit Tests**
   - Test entropy recording and window management
   - Test threshold breach detection
   - Test sustained high entropy detection
   - Test cooldown behavior

2. **Integration Tests**
   - Test CognitivePulse integration
   - Test config loading from utl.yaml
   - Test multiple concurrent triggers

3. **Edge Cases**
   - Empty window handling
   - Exactly-at-threshold behavior
   - Clock skew scenarios
   - Window boundary conditions

4. **Performance Tests**
   - Benchmark with large window sizes
   - Verify O(1) sample recording

---

*Task specification generated for Module 05 - UTL Integration*
