# M05-T44: Implement UTL Resource Endpoints

## Task Metadata
- **ID**: M05-T44
- **Title**: Implement UTL Resource Endpoints
- **Module**: 05 - UTL Integration
- **Layer**: integration
- **Priority**: medium
- **Estimated Hours**: 3
- **Created**: 2026-01-04
- **Status**: pending

## Description

Implement MCP resource endpoints for UTL state access per PRD Section 4.6.

Resources:
- `utl://{session}/state`: Full UTL state for session
- `utl://current_session/pulse`: Subscribable cognitive pulse stream
- `utl://lifecycle/status`: Global lifecycle stage info

Resource handlers must:
- Support both GET (one-time) and SUBSCRIBE (streaming)
- Return JSON-serializable UTL data
- Include latency tracking
- Respect session isolation

Performance: <5ms for state retrieval.

## File Paths

### Implementation
- `crates/context-graph-mcp/src/resources/utl_resources.rs`

### Tests
- `crates/context-graph-mcp/tests/utl_resources_tests.rs`

## Dependencies

| Task ID | Title | Status |
|---------|-------|--------|
| M05-T22 | Implement UtlProcessor | pending |
| M05-T26 | Implement utl_status MCP Tool | pending |
| M05-T39 | Implement UtlState Persistence to RocksDB | pending |

## Acceptance Criteria

- [ ] utl://{session}/state returns full UtlState
- [ ] utl://current_session/pulse supports subscription
- [ ] utl://lifecycle/status returns lifecycle info
- [ ] Session isolation enforced
- [ ] Resource retrieval <5ms
- [ ] Subscription emits on UTL updates

## Specification References

- `PRD Section 4.6 (Resources)`
- `constitution.yaml mcp.caps`

## Implementation Notes

### MCP Resource URIs

```
utl://{session_id}/state     - Full UTL state for specific session
utl://current_session/pulse  - Real-time cognitive pulse stream
utl://lifecycle/status       - Global lifecycle stage information
```

### Resource Handler Trait

```rust
use async_trait::async_trait;
use futures::Stream;

/// MCP Resource handler for UTL endpoints
#[async_trait]
pub trait UtlResourceHandler: Send + Sync {
    /// GET - One-time resource retrieval
    async fn get(&self, uri: &str) -> Result<UtlResource, ResourceError>;

    /// SUBSCRIBE - Streaming resource updates
    async fn subscribe(
        &self,
        uri: &str,
    ) -> Result<Box<dyn Stream<Item = UtlResource> + Send + Unpin>, ResourceError>;
}
```

### Resource Types

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UtlResource {
    /// Resource URI
    pub uri: String,

    /// Resource type
    pub resource_type: UtlResourceType,

    /// Resource data (JSON-serializable)
    pub data: serde_json::Value,

    /// Retrieval timestamp
    pub timestamp: DateTime<Utc>,

    /// Retrieval latency in microseconds
    pub latency_us: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum UtlResourceType {
    SessionState,
    CognitivePulse,
    LifecycleStatus,
}
```

### Session State Resource

```rust
/// Handler for utl://{session}/state
pub struct SessionStateHandler {
    storage: Arc<UtlStorage>,
}

impl SessionStateHandler {
    pub async fn get_state(&self, session_id: &str) -> Result<UtlState, ResourceError> {
        let start = Instant::now();

        // Validate session access
        self.validate_session_access(session_id)?;

        // Retrieve from storage
        let state = self.storage
            .get_utl_state(session_id)
            .await?
            .ok_or(ResourceError::NotFound)?;

        // Check latency target
        let latency = start.elapsed();
        if latency > Duration::from_millis(5) {
            tracing::warn!(
                latency_ms = latency.as_millis(),
                "UTL state retrieval exceeded 5ms target"
            );
        }

        Ok(state)
    }
}
```

### Cognitive Pulse Stream Resource

```rust
/// Handler for utl://current_session/pulse
pub struct CognitivePulseHandler {
    /// Broadcast channel for pulse updates
    pulse_tx: broadcast::Sender<CognitivePulse>,
}

impl CognitivePulseHandler {
    /// Subscribe to cognitive pulse stream
    pub async fn subscribe(&self) -> impl Stream<Item = CognitivePulse> {
        let rx = self.pulse_tx.subscribe();
        BroadcastStream::new(rx)
            .filter_map(|result| async move { result.ok() })
    }

    /// Emit new cognitive pulse to all subscribers
    pub fn emit_pulse(&self, pulse: CognitivePulse) {
        // Ignore send errors (no subscribers)
        let _ = self.pulse_tx.send(pulse);
    }
}
```

### Lifecycle Status Resource

```rust
/// Handler for utl://lifecycle/status
pub struct LifecycleStatusHandler {
    lifecycle_manager: Arc<LifecycleManager>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LifecycleStatus {
    /// Current lifecycle stage
    pub stage: LifecycleStage,

    /// Total interaction count
    pub interaction_count: u64,

    /// Current lambda weights
    pub lambda_weights: LambdaWeights,

    /// Time in current stage
    pub stage_duration: Duration,

    /// Progress to next stage (0.0 - 1.0)
    pub stage_progress: f32,

    /// Next transition threshold
    pub next_transition_at: Option<u64>,
}
```

### Session Isolation

```rust
impl SessionStateHandler {
    fn validate_session_access(&self, session_id: &str) -> Result<(), ResourceError> {
        // Get current session from context
        let current_session = self.get_current_session()?;

        // Check if accessing own session or has admin permission
        if session_id != current_session.id && !current_session.has_admin_permission() {
            return Err(ResourceError::AccessDenied {
                requested: session_id.to_string(),
                current: current_session.id,
            });
        }

        Ok(())
    }
}
```

### Resource Router

```rust
pub struct UtlResourceRouter {
    session_handler: SessionStateHandler,
    pulse_handler: CognitivePulseHandler,
    lifecycle_handler: LifecycleStatusHandler,
}

impl UtlResourceRouter {
    /// Route resource request to appropriate handler
    pub async fn handle_request(
        &self,
        uri: &str,
        method: ResourceMethod,
    ) -> Result<UtlResource, ResourceError> {
        let parsed = UtlResourceUri::parse(uri)?;

        match (parsed.resource_type, method) {
            (ResourceType::SessionState, ResourceMethod::Get) => {
                self.session_handler.get_state(&parsed.session_id).await
            }
            (ResourceType::CognitivePulse, ResourceMethod::Subscribe) => {
                self.pulse_handler.subscribe().await
            }
            (ResourceType::LifecycleStatus, _) => {
                self.lifecycle_handler.get_status().await
            }
            _ => Err(ResourceError::MethodNotAllowed),
        }
    }
}
```

### Performance Tracking

```rust
/// Wrapper that tracks retrieval latency
pub async fn with_latency_tracking<T, F, Fut>(
    operation: F,
    resource_type: &str,
) -> Result<(T, Duration), ResourceError>
where
    F: FnOnce() -> Fut,
    Fut: Future<Output = Result<T, ResourceError>>,
{
    let start = Instant::now();
    let result = operation().await?;
    let latency = start.elapsed();

    metrics::histogram!(
        "utl.resource.latency",
        latency.as_secs_f64(),
        "resource_type" => resource_type.to_string()
    );

    Ok((result, latency))
}
```

## Testing Requirements

1. **Unit Tests**
   - Test URI parsing
   - Test session state retrieval
   - Test lifecycle status formatting
   - Test session isolation

2. **Integration Tests**
   - Test full resource request flow
   - Test subscription streaming
   - Test cross-session access denial

3. **Performance Tests**
   - State retrieval < 5ms
   - Subscription setup < 10ms
   - Stream latency < 2ms per event

4. **Streaming Tests**
   - Test multiple subscribers
   - Test subscriber cleanup on disconnect
   - Test back-pressure handling

---

*Task specification generated for Module 05 - UTL Integration*
