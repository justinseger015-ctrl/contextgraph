# M05-T48: Implement Salience Update Algorithm

## Task Metadata
- **ID**: M05-T48
- **Title**: Implement Salience Update Algorithm
- **Module**: 05 - UTL Integration
- **Layer**: completion
- **Priority**: high
- **Estimated Hours**: 2

## Description

Implement salience update mechanism using learning magnitude to update node importance.
Per SPEC-UTL-005, salience_update_alpha = 0.3.

Algorithm:
1. After UTL computation, update node.importance via exponential moving average
2. new_importance = (1 - alpha) * old_importance + alpha * learning_magnitude
3. Clamp result to [0, 1]
4. Only update if learning_magnitude > salience_update_min (0.1)

Include update_node_salience(node, learning_signal) function.
Integrate with MemoryNode update path in KnowledgeGraph.

## File Path
`crates/context-graph-utl/src/salience.rs`

## Dependencies
- M05-T21: LearningSignal and UtlState
- M05-T29: MemoryNode UTL extension

## Acceptance Criteria
- [ ] update_node_salience() applies EMA correctly
- [ ] Salience update skipped if magnitude < threshold
- [ ] Result clamped to [0, 1]
- [ ] Integrates with MemoryNode storage
- [ ] Alpha value configurable

## Test File
`crates/context-graph-utl/tests/salience_tests.rs`

## Specification References
- SPEC-UTL-005 Section 9.2
- constitution.yaml utl.params

## Implementation Notes

### Configuration

```rust
/// Configuration for salience updates
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SalienceConfig {
    /// EMA smoothing factor for salience updates
    /// Default: 0.3 (per SPEC-UTL-005)
    #[serde(default = "default_alpha")]
    pub alpha: f32,

    /// Minimum learning magnitude to trigger update
    /// Default: 0.1
    #[serde(default = "default_min_magnitude")]
    pub min_magnitude_threshold: f32,

    /// Decay factor for unused nodes (per timestep)
    /// Default: 0.99
    #[serde(default = "default_decay")]
    pub decay_factor: f32,

    /// Minimum salience before node becomes candidate for pruning
    /// Default: 0.05
    #[serde(default = "default_prune_threshold")]
    pub prune_threshold: f32,
}

fn default_alpha() -> f32 { 0.3 }
fn default_min_magnitude() -> f32 { 0.1 }
fn default_decay() -> f32 { 0.99 }
fn default_prune_threshold() -> f32 { 0.05 }

impl Default for SalienceConfig {
    fn default() -> Self {
        Self {
            alpha: default_alpha(),
            min_magnitude_threshold: default_min_magnitude(),
            decay_factor: default_decay(),
            prune_threshold: default_prune_threshold(),
        }
    }
}
```

### Core Implementation

```rust
use crate::{LearningSignal, UtlError};

/// Manages salience updates for memory nodes
pub struct SalienceUpdater {
    config: SalienceConfig,
}

impl SalienceUpdater {
    /// Create a new salience updater with configuration
    pub fn new(config: SalienceConfig) -> Self {
        Self { config }
    }

    /// Update node salience based on learning signal
    ///
    /// # Algorithm
    /// Uses exponential moving average (EMA):
    /// `new_importance = (1 - alpha) * old_importance + alpha * learning_magnitude`
    ///
    /// # Arguments
    /// * `current_importance` - Current node importance [0, 1]
    /// * `learning_signal` - The computed learning signal
    ///
    /// # Returns
    /// * `Some(new_importance)` if update was applied
    /// * `None` if learning magnitude below threshold
    ///
    /// # Constraints
    /// * Output is always clamped to [0, 1]
    /// * Update only applied if learning_magnitude >= min_magnitude_threshold
    pub fn update_salience(
        &self,
        current_importance: f32,
        learning_signal: &LearningSignal,
    ) -> Option<f32> {
        // Check minimum threshold
        if learning_signal.learning_magnitude < self.config.min_magnitude_threshold {
            return None;
        }

        // Validate input
        let current = current_importance.clamp(0.0, 1.0);
        let magnitude = learning_signal.learning_magnitude.clamp(0.0, 1.0);

        // Apply EMA formula
        let alpha = self.config.alpha;
        let new_importance = (1.0 - alpha) * current + alpha * magnitude;

        // Clamp result
        Some(new_importance.clamp(0.0, 1.0))
    }

    /// Apply time-based decay to node salience
    ///
    /// Should be called periodically (e.g., during consolidation)
    ///
    /// # Arguments
    /// * `current_importance` - Current node importance
    /// * `timesteps_since_access` - Number of timesteps since last access
    ///
    /// # Returns
    /// The decayed importance value
    pub fn apply_decay(
        &self,
        current_importance: f32,
        timesteps_since_access: u64,
    ) -> f32 {
        let decay = self.config.decay_factor.powi(timesteps_since_access as i32);
        (current_importance * decay).clamp(0.0, 1.0)
    }

    /// Check if node is candidate for pruning based on salience
    pub fn is_prune_candidate(&self, importance: f32) -> bool {
        importance < self.config.prune_threshold
    }

    /// Get the current alpha value
    pub fn alpha(&self) -> f32 {
        self.config.alpha
    }

    /// Get the minimum magnitude threshold
    pub fn min_magnitude_threshold(&self) -> f32 {
        self.config.min_magnitude_threshold
    }
}
```

### Integration with MemoryNode

```rust
use context_graph_core::types::MemoryNode;
use crate::{LearningSignal, SalienceUpdater};

/// Extension trait for MemoryNode salience updates
pub trait MemoryNodeSalienceExt {
    /// Update the node's importance based on a learning signal
    fn update_salience(&mut self, signal: &LearningSignal, updater: &SalienceUpdater);

    /// Apply time-based decay
    fn apply_salience_decay(&mut self, timesteps: u64, updater: &SalienceUpdater);

    /// Check if node is candidate for pruning
    fn is_prune_candidate(&self, updater: &SalienceUpdater) -> bool;
}

impl MemoryNodeSalienceExt for MemoryNode {
    fn update_salience(&mut self, signal: &LearningSignal, updater: &SalienceUpdater) {
        if let Some(new_importance) = updater.update_salience(self.importance, signal) {
            self.importance = new_importance;
            self.last_salience_update = Some(std::time::SystemTime::now());
        }
    }

    fn apply_salience_decay(&mut self, timesteps: u64, updater: &SalienceUpdater) {
        self.importance = updater.apply_decay(self.importance, timesteps);
    }

    fn is_prune_candidate(&self, updater: &SalienceUpdater) -> bool {
        updater.is_prune_candidate(self.importance)
    }
}
```

### Batch Update for KnowledgeGraph

```rust
impl KnowledgeGraph {
    /// Update salience for multiple nodes based on retrieval
    pub fn update_retrieved_nodes_salience(
        &mut self,
        node_ids: &[NodeId],
        signals: &[LearningSignal],
        updater: &SalienceUpdater,
    ) -> Result<usize, GraphError> {
        let mut updated = 0;

        for (node_id, signal) in node_ids.iter().zip(signals.iter()) {
            if let Some(node) = self.get_node_mut(node_id) {
                node.update_salience(signal, updater);
                updated += 1;
            }
        }

        Ok(updated)
    }

    /// Apply decay to all nodes (call during consolidation)
    pub fn apply_global_salience_decay(
        &mut self,
        current_timestep: u64,
        updater: &SalienceUpdater,
    ) -> usize {
        let mut decayed = 0;

        for node in self.nodes_mut() {
            let timesteps_since = current_timestep.saturating_sub(node.last_access_timestep);
            if timesteps_since > 0 {
                node.apply_salience_decay(timesteps_since, updater);
                decayed += 1;
            }
        }

        decayed
    }

    /// Get nodes that are candidates for pruning
    pub fn get_prune_candidates(&self, updater: &SalienceUpdater) -> Vec<NodeId> {
        self.nodes()
            .filter(|node| node.is_prune_candidate(updater))
            .map(|node| node.id.clone())
            .collect()
    }
}
```

### Test Suite

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn ema_formula_correct() {
        let updater = SalienceUpdater::new(SalienceConfig {
            alpha: 0.3,
            ..Default::default()
        });

        let signal = LearningSignal {
            learning_magnitude: 0.8,
            ..Default::default()
        };

        // old: 0.5, new = 0.7 * 0.5 + 0.3 * 0.8 = 0.35 + 0.24 = 0.59
        let result = updater.update_salience(0.5, &signal).unwrap();
        assert!((result - 0.59).abs() < 0.001);
    }

    #[test]
    fn update_skipped_below_threshold() {
        let updater = SalienceUpdater::new(SalienceConfig {
            min_magnitude_threshold: 0.1,
            ..Default::default()
        });

        let signal = LearningSignal {
            learning_magnitude: 0.05, // Below threshold
            ..Default::default()
        };

        let result = updater.update_salience(0.5, &signal);
        assert!(result.is_none());
    }

    #[test]
    fn result_clamped_to_valid_range() {
        let updater = SalienceUpdater::new(SalienceConfig {
            alpha: 0.9,
            ..Default::default()
        });

        // High learning magnitude
        let signal = LearningSignal {
            learning_magnitude: 1.0,
            ..Default::default()
        };

        let result = updater.update_salience(0.9, &signal).unwrap();
        assert!(result <= 1.0);
        assert!(result >= 0.0);

        // Test with values that could exceed bounds
        let high_signal = LearningSignal {
            learning_magnitude: 1.5, // Would be clamped
            ..Default::default()
        };
        let result2 = updater.update_salience(0.9, &high_signal).unwrap();
        assert!(result2 <= 1.0);
    }

    #[test]
    fn decay_reduces_importance() {
        let updater = SalienceUpdater::new(SalienceConfig {
            decay_factor: 0.99,
            ..Default::default()
        });

        let initial = 0.8;
        let after_10 = updater.apply_decay(initial, 10);
        let after_100 = updater.apply_decay(initial, 100);

        assert!(after_10 < initial);
        assert!(after_100 < after_10);
    }

    #[test]
    fn prune_candidate_detection() {
        let updater = SalienceUpdater::new(SalienceConfig {
            prune_threshold: 0.05,
            ..Default::default()
        });

        assert!(updater.is_prune_candidate(0.01));
        assert!(updater.is_prune_candidate(0.04));
        assert!(!updater.is_prune_candidate(0.05));
        assert!(!updater.is_prune_candidate(0.5));
    }

    #[test]
    fn configurable_alpha() {
        let updater_low = SalienceUpdater::new(SalienceConfig {
            alpha: 0.1,
            ..Default::default()
        });

        let updater_high = SalienceUpdater::new(SalienceConfig {
            alpha: 0.9,
            ..Default::default()
        });

        let signal = LearningSignal {
            learning_magnitude: 1.0,
            ..Default::default()
        };

        let result_low = updater_low.update_salience(0.0, &signal).unwrap();
        let result_high = updater_high.update_salience(0.0, &signal).unwrap();

        // Higher alpha should move faster toward learning magnitude
        assert!(result_high > result_low);
    }
}
```

## Performance Targets
- Single salience update: <1μs
- Batch update (1000 nodes): <1ms
- Decay application: <500μs

## Related Tasks
- M05-T21: Provides LearningSignal
- M05-T29: MemoryNode extension

---
*Generated: 2026-01-04*
*Module: 05 - UTL Integration*
*Version: 1.0.0*
