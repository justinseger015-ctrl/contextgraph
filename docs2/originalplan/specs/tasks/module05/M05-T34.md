# M05-T34: Create UTL Configuration File (config/utl.yaml)

```yaml
task_id: M05-T34
title: "Create UTL Configuration File (config/utl.yaml)"
module: "module-05-utl-integration"
layer: "integration"
priority: "high"
status: "pending"
estimated_hours: 1.5
created: "2026-01-04"
dependencies:
  - M05-T01  # UtlConfig and UtlThresholds Structs
  - M05-T02  # SurpriseConfig for KL Divergence Parameters
  - M05-T03  # CoherenceConfig for Rolling Window Tracking
  - M05-T04  # EmotionalConfig for Valence/Arousal Parameters
  - M05-T32  # PhaseConfig Struct
  - M05-T33  # JohariConfig Struct
spec_refs:
  - "SPEC-UTL-005 Section 15.1"
file_path: "config/utl.yaml"
test_file: "crates/context-graph-utl/tests/config_loading_tests.rs"
```

---

## Description

Create the complete UTL configuration file (`config/utl.yaml`) following SPEC-UTL-005 Section 15.1. This file contains all configuration parameters for the Unified Theory of Learning (UTL) subsystem, organized into logical sections with comprehensive documentation.

The configuration file integrates with the config loading system from Module 2 and must be deserializable into the UtlConfig struct.

---

## Implementation Requirements

### File Location

```
contextgraph/
  config/
    utl.yaml  <- This file
```

### Complete Configuration File

```yaml
# =============================================================================
# UTL (Unified Theory of Learning) Configuration
# =============================================================================
# Configuration for the UTL subsystem that governs memory acquisition,
# prioritization, and consolidation based on the learning equation:
#   L = sigmoid((delta_s * delta_c) * w_e * cos(phi) * LEARNING_SCALE_FACTOR)
#
# Reference: SPEC-UTL-005, TECH-UTL-005
# =============================================================================

utl:
  # ---------------------------------------------------------------------------
  # Core UTL Parameters
  # ---------------------------------------------------------------------------

  # Learning scale factor multiplier for the UTL equation (default: 2.0)
  # Higher values increase learning magnitude sensitivity
  learning_scale_factor: 2.0

  # Alpha value for exponential moving average in salience updates (default: 0.3)
  # salience_new = alpha * L + (1 - alpha) * salience_old
  salience_update_alpha: 0.3

  # ---------------------------------------------------------------------------
  # Threshold Configuration
  # ---------------------------------------------------------------------------
  thresholds:
    # Minimum learning magnitude to trigger consolidation (default: 0.7)
    consolidation_trigger: 0.7

    # Minimum salience update to persist (default: 0.1)
    # Updates below this threshold are discarded
    salience_update_min: 0.1

    # Threshold for significant surprise detection (default: 0.6)
    # Used for alerting and special handling
    surprise_significant: 0.6

# =============================================================================
# Surprise Computation Configuration
# =============================================================================
# Controls how entropy/surprise (delta_s) is computed from embeddings
# using KL divergence and cosine distance methods.

surprise:
  # Weight for KL divergence component (default: 0.6)
  # Must sum with distance_weight to 1.0
  kl_weight: 0.6

  # Weight for cosine distance component (default: 0.4)
  distance_weight: 0.4

  # Number of recent embeddings to consider as context (default: 50)
  context_window_size: 50

  # Decay factor for older context entries (default: 0.95)
  # Applied exponentially: weight_i = decay^i
  context_decay: 0.95

  # Maximum surprise value when no context is available (default: 0.9)
  # New information with no baseline gets high but not maximum surprise
  max_surprise_no_context: 0.9

  # Minimum context entries required for KL computation (default: 3)
  # Falls back to distance method if below this threshold
  min_context_for_kl: 3

  # KL divergence specific parameters
  kl:
    # Small value to prevent log(0) (default: 1e-10)
    epsilon: 1.0e-10

    # Maximum KL value for normalization (default: 10.0)
    # KL values above this are clamped before normalization
    max_kl_value: 10.0

    # Temperature for softmax normalization (default: 1.0)
    # Lower values make distribution more peaked
    temperature: 1.0

# =============================================================================
# Coherence Tracking Configuration
# =============================================================================
# Controls how coherence (delta_c) is computed using rolling window
# of recent interactions and graph connectivity.

coherence:
  # Size of rolling window for coherence computation (default: 100)
  window_size: 100

  # Decay factor for recency weighting (default: 0.98)
  # More recent entries have higher weight
  recency_decay: 0.98

  # Weight for semantic similarity component (default: 0.6)
  # Must sum with structural_weight to 1.0
  semantic_weight: 0.6

  # Weight for graph structural component (default: 0.4)
  structural_weight: 0.4

  # Default coherence when window is empty (default: 0.5)
  # Used as neutral baseline for new sessions
  default_coherence_empty: 0.5

  # Default coherence when no concepts extracted (default: 0.4)
  default_coherence_no_concepts: 0.4

  # Contradiction detection parameters
  contradiction:
    # Number of similar nodes to search for contradictions (default: 20)
    search_k: 20

    # Similarity threshold for potential contradiction (default: 0.85)
    # Nodes above this similarity are checked for conflict
    similarity_threshold: 0.85

    # Maximum coherence penalty from contradictions (default: 0.5)
    # Final coherence = base_coherence * (1 - penalty)
    max_penalty: 0.5

# =============================================================================
# Emotional Weight Configuration
# =============================================================================
# Controls how emotional weight (w_e) is computed from content
# using valence/arousal model.

emotional:
  # Decay rate for emotional state blending (default: 0.1)
  # state_new = (1 - decay) * state_old + decay * state_input
  decay_rate: 0.1

  # Baseline emotional weight (default: 1.0)
  baseline_weight: 1.0

  # Weight for valence component (default: 0.6)
  # Must sum with arousal_weight to 1.0
  valence_weight: 0.6

  # Weight for arousal component (default: 0.4)
  arousal_weight: 0.4

  # Scaling factor for emotional intensity (default: 0.5)
  # intensity = valence_weight * |valence| + arousal_weight * arousal
  # weight = baseline + intensity * intensity_scale
  intensity_scale: 0.5

  # Arousal modifiers for punctuation/formatting
  punctuation:
    # Weight for exclamation marks (default: 0.3)
    exclamation_weight: 0.3

    # Weight for question marks (default: 0.2)
    question_weight: 0.2

    # Weight for ALL CAPS words (default: 0.2)
    caps_weight: 0.2

  # Output range constraints
  output:
    # Minimum emotional weight (default: 0.5)
    weight_min: 0.5

    # Maximum emotional weight (default: 1.5)
    weight_max: 1.5

# =============================================================================
# Phase Oscillator Configuration
# =============================================================================
# Controls the theta-inspired phase oscillator that determines
# encoding vs consolidation timing.

phase:
  # Base oscillation frequency in Hz (default: 0.1)
  # 0.1 Hz = 10 second full oscillation period
  base_frequency: 0.1

  # Modulation range for external control
  modulation:
    # Minimum modulation factor (default: 0.1)
    min: 0.1

    # Maximum modulation factor (default: 3.0)
    max: 3.0

  # Phase thresholds for mode determination (fractions of PI)
  thresholds:
    # Below this = Encoding phase (default: 0.33)
    encoding: 0.33

    # Above this = Consolidation phase (default: 0.67)
    consolidation: 0.67

  # Consolidation triggering parameters
  consolidation:
    # Phase angle threshold for consolidation (default: 2.1 radians)
    phase_threshold: 2.1

    # Minimum importance for consolidation consideration (default: 0.4)
    importance_threshold: 0.4

    # Staleness threshold in seconds (default: 300 = 5 minutes)
    staleness_seconds: 300

# =============================================================================
# Johari Window Classification Configuration
# =============================================================================
# Controls how memories are classified into the four Johari quadrants
# based on entropy and coherence values.

johari:
  # Entropy threshold for quadrant classification (default: 0.5)
  # Below = low entropy, Above = high entropy
  entropy_threshold: 0.5

  # Coherence threshold for quadrant classification (default: 0.5)
  # Below = low coherence, Above = high coherence
  coherence_threshold: 0.5

  # Per-quadrant retrieval strategies
  strategies:
    # Open: Low entropy, High coherence (well-understood)
    open:
      search_depth: 1
      include_neighbors: false
      confidence_threshold: 0.8
      max_results: 5

    # Blind: High entropy, Low coherence (surprising, inconsistent)
    blind:
      search_depth: 3
      include_neighbors: true
      confidence_threshold: 0.4
      max_results: 20

    # Hidden: Low entropy, Low coherence (familiar but disconnected)
    hidden:
      search_depth: 2
      include_neighbors: true
      confidence_threshold: 0.6
      max_results: 10

    # Unknown: High entropy, High coherence (novel but consistent)
    unknown:
      search_depth: 4
      include_neighbors: true
      confidence_threshold: 0.3
      max_results: 30

# =============================================================================
# Lifecycle Stage Configuration (Marblestone)
# =============================================================================
# Controls the dynamic learning rate modulation based on system maturity,
# inspired by Adam Marblestone's developmental learning work.

lifecycle:
  # Interaction count thresholds for stage transitions
  transitions:
    # Transition from Infancy to Growth (default: 50)
    infancy_to_growth: 50

    # Transition from Growth to Maturity (default: 500)
    growth_to_maturity: 500

  # Lambda weights for each lifecycle stage
  # lambda_novelty + lambda_consolidation = 1.0
  lambda_weights:
    infancy:
      # Infancy favors novelty/exploration
      novelty: 0.7
      consolidation: 0.3

    growth:
      # Growth is balanced
      novelty: 0.5
      consolidation: 0.5

    maturity:
      # Maturity favors consolidation/stability
      novelty: 0.3
      consolidation: 0.7

  # Per-stage configuration
  stages:
    infancy:
      # Higher entropy tolerance in infancy (explore more)
      entropy_trigger: 0.9
      coherence_trigger: 0.2
      min_importance_store: 0.1
      consolidation_threshold: 0.3

    growth:
      entropy_trigger: 0.7
      coherence_trigger: 0.4
      min_importance_store: 0.3
      consolidation_threshold: 0.5

    maturity:
      # Lower entropy tolerance in maturity (curate more)
      entropy_trigger: 0.6
      coherence_trigger: 0.5
      min_importance_store: 0.4
      consolidation_threshold: 0.6

# =============================================================================
# Performance Tuning
# =============================================================================
# Optional performance-related configuration

performance:
  # Enable parallel computation where possible
  parallel_computation: true

  # Cache size for surprise computation context
  context_cache_size: 1000

  # Batch size for coherence window updates
  coherence_batch_size: 10

  # Metrics collection interval in seconds
  metrics_interval_seconds: 60
```

---

## Config Loading Integration

The configuration file must integrate with the existing config loader from Module 2:

```rust
// In crates/context-graph-utl/src/config.rs

use std::path::Path;
use std::fs;

impl UtlConfig {
    /// Load configuration from YAML file
    pub fn from_yaml_file<P: AsRef<Path>>(path: P) -> Result<Self, ConfigError> {
        let content = fs::read_to_string(path)
            .map_err(|e| ConfigError::IoError(e.to_string()))?;
        Self::from_yaml_str(&content)
    }

    /// Parse configuration from YAML string
    pub fn from_yaml_str(yaml: &str) -> Result<Self, ConfigError> {
        let config: Self = serde_yaml::from_str(yaml)
            .map_err(|e| ConfigError::ParseError(e.to_string()))?;
        config.validate()?;
        Ok(config)
    }

    /// Load default configuration from embedded YAML
    pub fn load_default() -> Result<Self, ConfigError> {
        Self::from_yaml_file("config/utl.yaml")
    }
}
```

---

## Acceptance Criteria

- [ ] `config/utl.yaml` file exists at correct path
- [ ] All sections present: utl, surprise, coherence, emotional, phase, johari, lifecycle
- [ ] All default values match SPEC-UTL-005 specification
- [ ] YAML parses correctly into UtlConfig struct
- [ ] Every parameter has descriptive comment
- [ ] Config loader integration works
- [ ] Validation passes for default configuration
- [ ] Unit tests verify loading and parsing

---

## Test Cases

```rust
// crates/context-graph-utl/tests/config_loading_tests.rs

#[test]
fn test_load_utl_yaml() {
    let config = UtlConfig::from_yaml_file("config/utl.yaml").unwrap();
    assert!(config.validate().is_ok());
}

#[test]
fn test_default_values_match_spec() {
    let config = UtlConfig::from_yaml_file("config/utl.yaml").unwrap();

    // UTL core
    assert_eq!(config.learning_scale_factor, 2.0);
    assert_eq!(config.salience_update_alpha, 0.3);

    // Thresholds
    assert_eq!(config.thresholds.consolidation_trigger, 0.7);
    assert_eq!(config.thresholds.salience_update_min, 0.1);
    assert_eq!(config.thresholds.surprise_significant, 0.6);

    // Surprise
    assert_eq!(config.surprise.kl_weight, 0.6);
    assert_eq!(config.surprise.distance_weight, 0.4);
    assert_eq!(config.surprise.context_window_size, 50);

    // Coherence
    assert_eq!(config.coherence.window_size, 100);
    assert_eq!(config.coherence.semantic_weight, 0.6);

    // Emotional
    assert_eq!(config.emotional.baseline_weight, 1.0);
    assert_eq!(config.emotional.weight_min, 0.5);
    assert_eq!(config.emotional.weight_max, 1.5);

    // Phase
    assert_eq!(config.phase.base_frequency, 0.1);
    assert_eq!(config.phase.encoding_threshold, 0.33);
    assert_eq!(config.phase.consolidation_threshold, 0.67);

    // Johari
    assert_eq!(config.johari.entropy_threshold, 0.5);
    assert_eq!(config.johari.coherence_threshold, 0.5);

    // Lifecycle
    assert_eq!(config.lifecycle.infancy_threshold, 50);
    assert_eq!(config.lifecycle.growth_threshold, 500);
}

#[test]
fn test_lifecycle_lambda_weights_sum_to_one() {
    let config = UtlConfig::from_yaml_file("config/utl.yaml").unwrap();

    let infancy = &config.lifecycle.lambda_weights.infancy;
    assert!((infancy.novelty + infancy.consolidation - 1.0).abs() < 1e-6);

    let growth = &config.lifecycle.lambda_weights.growth;
    assert!((growth.novelty + growth.consolidation - 1.0).abs() < 1e-6);

    let maturity = &config.lifecycle.lambda_weights.maturity;
    assert!((maturity.novelty + maturity.consolidation - 1.0).abs() < 1e-6);
}

#[test]
fn test_weight_sums_to_one() {
    let config = UtlConfig::from_yaml_file("config/utl.yaml").unwrap();

    // KL + distance = 1.0
    assert!((config.surprise.kl_weight + config.surprise.distance_weight - 1.0).abs() < 1e-6);

    // Semantic + structural = 1.0
    assert!((config.coherence.semantic_weight + config.coherence.structural_weight - 1.0).abs() < 1e-6);

    // Valence + arousal = 1.0
    assert!((config.emotional.valence_weight + config.emotional.arousal_weight - 1.0).abs() < 1e-6);
}

#[test]
fn test_johari_strategies() {
    let config = UtlConfig::from_yaml_file("config/utl.yaml").unwrap();

    // Open has shallowest search
    let open = config.johari.get_strategy(JohariQuadrant::Open);
    assert_eq!(open.search_depth, 1);
    assert_eq!(open.max_results, 5);

    // Unknown has deepest search
    let unknown = config.johari.get_strategy(JohariQuadrant::Unknown);
    assert_eq!(unknown.search_depth, 4);
    assert_eq!(unknown.max_results, 30);
}
```

---

## File Structure

```
contextgraph/
  config/
    utl.yaml            <- Configuration file (this task)
  crates/
    context-graph-utl/
      src/
        config.rs       <- Struct definitions + loader
      tests/
        config_loading_tests.rs  <- Test file
```

---

## Dependencies

- `serde_yaml`: YAML parsing
- Module 2 config loading infrastructure

---

## Notes

- The configuration file serves as the single source of truth for UTL parameters
- All comments should explain the purpose and impact of each parameter
- The file should be human-readable and editable without code changes
- Environment-specific overrides can be implemented via additional config files
- Consider adding schema validation for YAML in future tasks
