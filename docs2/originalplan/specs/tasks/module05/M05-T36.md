# M05-T36: Implement UTL Steering Subsystem Hooks

```yaml
task_id: "M05-T36"
title: "Implement UTL Steering Subsystem Hooks"
module: "module-05"
layer: "integration"
priority: "medium"
estimated_hours: 3
status: "pending"
created: "2026-01-04"
updated: "2026-01-04"
```

---

## Description

Implement steering subsystem integration as per constitution.yaml steering section. Create SteeringHook trait for UTL-to-steering communication. Implement compute_steering_signal(utl_state) -> SteeringSignal. SteeringSignal contains entropy_direction, coherence_direction, and exploration_budget. Add lifecycle-aware steering adjustments (Infancy=explore, Maturity=exploit). Integrate with neuromodulation system (Acetylcholine learning rate modulation).

---

## File Paths

| Type | Path |
|------|------|
| Implementation | `crates/context-graph-utl/src/steering/hooks.rs` |
| Module | `crates/context-graph-utl/src/steering/mod.rs` |
| Test | `crates/context-graph-utl/tests/steering_tests.rs` |

---

## Dependencies

| Task ID | Title | Status |
|---------|-------|--------|
| M05-T19 | LifecycleManager State Machine | pending |
| M05-T22 | UtlProcessor Main Orchestrator | pending |

---

## Acceptance Criteria

- [ ] SteeringHook trait defined
- [ ] SteeringSignal struct with 3 fields (entropy_direction, coherence_direction, exploration_budget)
- [ ] compute_steering_signal() works correctly
- [ ] Lifecycle-aware adjustments implemented
- [ ] Interface ready for Module 10 neuromodulation

---

## Specification References

- constitution.yaml steering section
- constitution.yaml neuromodulation section

---

## Technical Notes

### SteeringSignal Structure

```rust
/// Signal from UTL to steering subsystem
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SteeringSignal {
    /// Direction for entropy: -1.0 (reduce), 0.0 (maintain), +1.0 (increase)
    pub entropy_direction: f32,

    /// Direction for coherence: -1.0 (reduce), 0.0 (maintain), +1.0 (increase)
    pub coherence_direction: f32,

    /// Exploration budget [0.0, 1.0]: how much exploration vs exploitation
    pub exploration_budget: f32,
}
```

### SteeringHook Trait

```rust
/// Trait for UTL-to-steering communication
pub trait SteeringHook: Send + Sync {
    /// Compute steering signal from current UTL state
    fn compute_steering_signal(&self, utl_state: &UtlState) -> SteeringSignal;

    /// Get current exploration/exploitation balance
    fn get_exploration_balance(&self) -> f32;

    /// Notify steering of UTL update
    fn on_utl_update(&self, learning_signal: &LearningSignal);
}
```

### Lifecycle-Aware Steering

| Lifecycle Stage | Entropy Direction | Coherence Direction | Exploration Budget |
|-----------------|-------------------|---------------------|-------------------|
| Infancy | +0.5 (increase) | 0.0 (neutral) | 0.8 (high exploration) |
| Growth | 0.0 (neutral) | 0.0 (neutral) | 0.5 (balanced) |
| Maturity | -0.3 (reduce) | +0.5 (increase) | 0.2 (low exploration) |

### Algorithm

```rust
pub fn compute_steering_signal(utl_state: &UtlState, lifecycle: LifecycleStage) -> SteeringSignal {
    let base_signal = match lifecycle {
        LifecycleStage::Infancy => SteeringSignal {
            entropy_direction: 0.5,
            coherence_direction: 0.0,
            exploration_budget: 0.8,
        },
        LifecycleStage::Growth => SteeringSignal {
            entropy_direction: 0.0,
            coherence_direction: 0.0,
            exploration_budget: 0.5,
        },
        LifecycleStage::Maturity => SteeringSignal {
            entropy_direction: -0.3,
            coherence_direction: 0.5,
            exploration_budget: 0.2,
        },
    };

    // Modulate based on current UTL state
    // High entropy -> reduce exploration
    // Low coherence -> increase coherence direction
    base_signal.modulate_by_state(utl_state)
}
```

### Neuromodulation Interface

The steering system interfaces with neuromodulation (Module 10):
- **Acetylcholine**: Modulates learning rate based on exploration budget
- Higher exploration budget -> higher Ach -> faster learning

```rust
/// Interface for neuromodulation integration
pub fn get_acetylcholine_modulation(&self, signal: &SteeringSignal) -> f32 {
    // Map exploration_budget to learning rate modulation
    // Range: [0.001, 0.002] as per constitution.yaml
    let base_lr = 0.001;
    let lr_range = 0.001;
    base_lr + (signal.exploration_budget * lr_range)
}
```

---

## Implementation Checklist

1. [ ] Create `crates/context-graph-utl/src/steering/mod.rs`
2. [ ] Create `crates/context-graph-utl/src/steering/hooks.rs`
3. [ ] Define `SteeringSignal` struct with 3 fields
4. [ ] Define `SteeringHook` trait with required methods
5. [ ] Implement `compute_steering_signal()` function
6. [ ] Add lifecycle-aware base signals
7. [ ] Implement state modulation logic
8. [ ] Add `get_acetylcholine_modulation()` for neuromod interface
9. [ ] Create default/stub implementation of SteeringHook
10. [ ] Update lib.rs exports
11. [ ] Write unit tests for all lifecycle stages
12. [ ] Write tests for signal modulation

---

## Test Cases

### Unit Tests

```rust
#[test]
fn test_steering_signal_infancy() {
    let state = UtlState::default();
    let signal = compute_steering_signal(&state, LifecycleStage::Infancy);

    assert!(signal.exploration_budget > 0.7);
    assert!(signal.entropy_direction > 0.0);
}

#[test]
fn test_steering_signal_maturity() {
    let state = UtlState::default();
    let signal = compute_steering_signal(&state, LifecycleStage::Maturity);

    assert!(signal.exploration_budget < 0.3);
    assert!(signal.coherence_direction > 0.0);
}

#[test]
fn test_high_entropy_reduces_exploration() {
    let state = UtlState { delta_s: 0.9, ..Default::default() };
    let signal = compute_steering_signal(&state, LifecycleStage::Growth);

    // High entropy should reduce exploration budget
    assert!(signal.exploration_budget < 0.5);
}

#[test]
fn test_acetylcholine_modulation_range() {
    let signal = SteeringSignal {
        exploration_budget: 0.5,
        ..Default::default()
    };

    let ach = get_acetylcholine_modulation(&signal);
    assert!(ach >= 0.001 && ach <= 0.002);
}

#[test]
fn test_steering_hook_trait_object() {
    // Verify trait object compatibility
    let hook: Box<dyn SteeringHook> = Box::new(DefaultSteeringHook::new());
    let signal = hook.compute_steering_signal(&UtlState::default());
    assert!(signal.exploration_budget >= 0.0 && signal.exploration_budget <= 1.0);
}
```

---

*Module: 05 - UTL Integration*
*Task: 36 of 57*
*Layer: Integration*
