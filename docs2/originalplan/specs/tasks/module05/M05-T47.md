# M05-T47: Implement UTL Validation Test Suite (Needle-Haystack, Dynamics)

## Task Metadata
- **ID**: M05-T47
- **Title**: Implement UTL Validation Test Suite (Needle-Haystack, Dynamics)
- **Module**: 05 - UTL Integration
- **Layer**: integration
- **Priority**: high
- **Estimated Hours**: 5

## Description

Implement validation test suite per constitution.yaml testing.types.validation.

Test categories:
1. Needle-haystack: UTL correctly prioritizes novel vs redundant
2. UTL dynamics: Learning magnitude correlates with importance (r>0.7)
3. Dream effectiveness: Post-dream coherence improvement
4. Lifecycle progression: Correct stage transitions at 50/500
5. Lambda weight application: Verify weighted computation
6. Johari classification accuracy: Matches spec truth table
7. Steering feedback correlation: Rewards align with UTL state

Tests use fixtures from tests/fixtures/ with known expected values.

## File Path
`tests/validation/utl_validation_tests.rs`

## Dependencies
- M05-T25: Integration tests and benchmarks
- M05-T22: UtlProcessor orchestrator
- M05-T19: LifecycleManager state machine

## Acceptance Criteria
- [ ] Needle-haystack test shows UTL prioritization
- [ ] Learning-importance correlation r > 0.7
- [ ] Lifecycle transitions at exact thresholds
- [ ] Lambda weights correctly applied
- [ ] Johari classification matches spec table
- [ ] All validation tests pass before Module 6
- [ ] Test fixtures version-controlled

## Test File
`tests/validation/utl_validation_tests.rs`

## Specification References
- constitution.yaml testing.types.validation
- SPEC-UTL-005 Section 12, 13

## Implementation Notes

### Test Fixture Structure

```
tests/
└── fixtures/
    └── utl/
        ├── needle_haystack/
        │   ├── haystack_embeddings.json      # 1000 similar embeddings
        │   ├── needle_embeddings.json        # 10 distinct embeddings
        │   └── expected_rankings.json        # Ground truth rankings
        ├── dynamics/
        │   ├── importance_scores.json        # Human-rated importance
        │   ├── test_content.json             # Content samples
        │   └── expected_correlation.json     # Expected r > 0.7
        ├── lifecycle/
        │   ├── interaction_sequence.json     # Sequence of interactions
        │   └── expected_transitions.json     # When transitions occur
        └── johari/
            ├── quadrant_cases.json           # Test cases for each quadrant
            └── expected_classifications.json # Ground truth
```

### Validation Test Suite

```rust
//! UTL Validation Test Suite
//!
//! Per constitution.yaml testing.types.validation, these tests verify
//! that UTL correctly prioritizes and classifies content.

use context_graph_utl::*;
use serde::Deserialize;
use std::path::Path;

mod fixtures {
    use super::*;

    pub fn load_fixture<T: for<'de> Deserialize<'de>>(path: &str) -> T {
        let fixture_path = Path::new("tests/fixtures/utl").join(path);
        let content = std::fs::read_to_string(fixture_path)
            .expect("Failed to read fixture");
        serde_json::from_str(&content).expect("Failed to parse fixture")
    }
}

mod needle_haystack_tests {
    use super::*;

    /// Test that UTL correctly identifies novel content (needles) among
    /// redundant content (haystack).
    #[test]
    fn needle_haystack_prioritization() {
        let processor = UtlProcessor::new(Default::default());

        // Load fixtures
        let haystack: Vec<Vec<f32>> = fixtures::load_fixture("needle_haystack/haystack_embeddings.json");
        let needles: Vec<Vec<f32>> = fixtures::load_fixture("needle_haystack/needle_embeddings.json");
        let expected: Vec<usize> = fixtures::load_fixture("needle_haystack/expected_rankings.json");

        // Build context from haystack
        let context: Vec<ContextEntry> = haystack.iter()
            .enumerate()
            .map(|(i, emb)| ContextEntry {
                embedding: emb.clone(),
                timestamp: i as u64,
                content: format!("haystack_{}", i),
            })
            .collect();

        // Compute UTL for all items (haystack + needles)
        let mut results: Vec<(usize, f32, bool)> = Vec::new();

        for (i, emb) in haystack.iter().enumerate() {
            let signal = processor.compute(&format!("haystack_{}", i), emb, &context);
            results.push((i, signal.learning_magnitude, false));
        }

        for (i, emb) in needles.iter().enumerate() {
            let signal = processor.compute(&format!("needle_{}", i), emb, &context);
            results.push((haystack.len() + i, signal.learning_magnitude, true));
        }

        // Sort by learning magnitude (descending)
        results.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap());

        // Verify needles appear in top 20
        let top_20: Vec<bool> = results.iter().take(20).map(|(_, _, is_needle)| *is_needle).collect();
        let needles_in_top_20 = top_20.iter().filter(|&&x| x).count();

        // At least 8 of 10 needles should be in top 20
        assert!(
            needles_in_top_20 >= 8,
            "Expected at least 8 needles in top 20, found {}",
            needles_in_top_20
        );
    }

    #[test]
    fn redundant_content_deprioritized() {
        let processor = UtlProcessor::new(Default::default());

        // Create highly redundant context
        let base_embedding = vec![0.5f32; 1536];
        let context: Vec<ContextEntry> = (0..100)
            .map(|i| {
                // Small perturbations
                let emb: Vec<f32> = base_embedding.iter()
                    .map(|v| v + (i as f32 * 0.001))
                    .collect();
                ContextEntry {
                    embedding: emb,
                    timestamp: i as u64,
                    content: format!("redundant_{}", i),
                }
            })
            .collect();

        // Compute UTL for another redundant item
        let redundant_signal = processor.compute(
            "redundant_new",
            &base_embedding,
            &context,
        );

        // Compute UTL for a novel item
        let novel_embedding: Vec<f32> = (0..1536).map(|i| (i as f32 / 1536.0)).collect();
        let novel_signal = processor.compute(
            "novel_new",
            &novel_embedding,
            &context,
        );

        // Novel should have higher learning magnitude
        assert!(
            novel_signal.learning_magnitude > redundant_signal.learning_magnitude,
            "Novel content should have higher learning magnitude"
        );
    }
}

mod dynamics_correlation_tests {
    use super::*;

    /// Test that learning magnitude correlates with human-rated importance.
    /// Per constitution.yaml, correlation r > 0.7 required.
    #[test]
    fn learning_importance_correlation() {
        let processor = UtlProcessor::new(Default::default());

        // Load fixtures with human-rated importance scores
        let test_content: Vec<ContentSample> = fixtures::load_fixture("dynamics/test_content.json");
        let importance_scores: Vec<f32> = fixtures::load_fixture("dynamics/importance_scores.json");

        assert_eq!(test_content.len(), importance_scores.len());

        // Compute UTL for each sample
        let mut learning_magnitudes: Vec<f32> = Vec::new();
        let context: Vec<ContextEntry> = Vec::new(); // Start with empty context

        for sample in &test_content {
            let signal = processor.compute(&sample.text, &sample.embedding, &context);
            learning_magnitudes.push(signal.learning_magnitude);
        }

        // Compute Pearson correlation coefficient
        let correlation = pearson_correlation(&learning_magnitudes, &importance_scores);

        assert!(
            correlation > 0.7,
            "Correlation between learning magnitude and importance must be > 0.7, got {}",
            correlation
        );
    }

    fn pearson_correlation(x: &[f32], y: &[f32]) -> f32 {
        let n = x.len() as f32;
        let sum_x: f32 = x.iter().sum();
        let sum_y: f32 = y.iter().sum();
        let sum_xy: f32 = x.iter().zip(y.iter()).map(|(a, b)| a * b).sum();
        let sum_x2: f32 = x.iter().map(|a| a * a).sum();
        let sum_y2: f32 = y.iter().map(|b| b * b).sum();

        let numerator = n * sum_xy - sum_x * sum_y;
        let denominator = ((n * sum_x2 - sum_x.powi(2)) * (n * sum_y2 - sum_y.powi(2))).sqrt();

        if denominator == 0.0 { 0.0 } else { numerator / denominator }
    }
}

mod lifecycle_transition_tests {
    use super::*;

    /// Verify lifecycle transitions occur at exact thresholds.
    #[test]
    fn infancy_to_growth_at_50() {
        let mut manager = LifecycleManager::new(Default::default());

        assert_eq!(manager.current_stage(), LifecycleStage::Infancy);

        // Record 49 interactions - should still be Infancy
        for _ in 0..49 {
            manager.record_interaction();
        }
        assert_eq!(manager.current_stage(), LifecycleStage::Infancy);

        // 50th interaction triggers transition
        manager.record_interaction();
        assert_eq!(manager.current_stage(), LifecycleStage::Growth);
    }

    #[test]
    fn growth_to_maturity_at_500() {
        let mut manager = LifecycleManager::new(Default::default());

        // Fast-forward to Growth
        for _ in 0..50 {
            manager.record_interaction();
        }
        assert_eq!(manager.current_stage(), LifecycleStage::Growth);

        // Record up to 499 total
        for _ in 0..449 {
            manager.record_interaction();
        }
        assert_eq!(manager.current_stage(), LifecycleStage::Growth);

        // 500th interaction triggers transition
        manager.record_interaction();
        assert_eq!(manager.current_stage(), LifecycleStage::Maturity);
    }

    #[test]
    fn lambda_weights_update_with_stage() {
        let mut manager = LifecycleManager::new(Default::default());

        // Infancy: high novelty weight
        let infancy_weights = manager.current_lambda_weights();
        assert!(infancy_weights.lambda_novelty > infancy_weights.lambda_consolidation);

        // Transition to Growth
        for _ in 0..50 {
            manager.record_interaction();
        }
        let growth_weights = manager.current_lambda_weights();
        assert!(
            (growth_weights.lambda_novelty - growth_weights.lambda_consolidation).abs() < 0.2,
            "Growth stage should have balanced weights"
        );

        // Transition to Maturity
        for _ in 0..450 {
            manager.record_interaction();
        }
        let maturity_weights = manager.current_lambda_weights();
        assert!(maturity_weights.lambda_consolidation > maturity_weights.lambda_novelty);
    }
}

mod johari_classification_tests {
    use super::*;

    /// Johari quadrant truth table from SPEC-UTL-005
    const JOHARI_TRUTH_TABLE: &[(f32, f32, JohariQuadrant)] = &[
        // (surprise, coherence, expected_quadrant)
        (0.3, 0.7, JohariQuadrant::Open),    // low surprise, high coherence
        (0.3, 0.3, JohariQuadrant::Hidden),  // low surprise, low coherence
        (0.7, 0.7, JohariQuadrant::Blind),   // high surprise, high coherence
        (0.7, 0.3, JohariQuadrant::Unknown), // high surprise, low coherence
    ];

    #[test]
    fn johari_matches_truth_table() {
        let classifier = JohariClassifier::new(JohariConfig {
            surprise_threshold: 0.5,
            coherence_threshold: 0.5,
        });

        for (surprise, coherence, expected) in JOHARI_TRUTH_TABLE {
            let result = classifier.classify(*surprise, *coherence);

            assert_eq!(
                result, *expected,
                "For surprise={}, coherence={}, expected {:?} but got {:?}",
                surprise, coherence, expected, result
            );
        }
    }

    #[test]
    fn johari_boundary_cases() {
        let classifier = JohariClassifier::new(JohariConfig {
            surprise_threshold: 0.5,
            coherence_threshold: 0.5,
        });

        // Exactly at threshold - should be deterministic
        let result1 = classifier.classify(0.5, 0.5);
        let result2 = classifier.classify(0.5, 0.5);
        assert_eq!(result1, result2);

        // Just below threshold
        let below = classifier.classify(0.49, 0.49);
        assert_eq!(below, JohariQuadrant::Hidden);

        // Just above threshold
        let above = classifier.classify(0.51, 0.51);
        assert_eq!(above, JohariQuadrant::Blind);
    }

    #[test]
    fn johari_extreme_values() {
        let classifier = JohariClassifier::new(Default::default());

        // Maximum confidence
        let max_conf = classifier.classify(0.0, 1.0);
        assert_eq!(max_conf, JohariQuadrant::Open);

        // Maximum uncertainty
        let max_unc = classifier.classify(1.0, 0.0);
        assert_eq!(max_unc, JohariQuadrant::Unknown);
    }
}

mod steering_feedback_tests {
    use super::*;

    #[test]
    fn steering_rewards_align_with_lifecycle() {
        let calculator = SteeringRewardCalculator::new();

        // Same signal, different lifecycle stages
        let signal = LearningSignal {
            learning_magnitude: 0.5,
            delta_s: 0.6,
            delta_c: 0.4,
            ..Default::default()
        };

        // Infancy: should reward novelty (delta_s)
        let infancy_reward = calculator.compute_base_reward(&signal, &LifecycleStage::Infancy);

        // Maturity: should reward coherence (delta_c)
        let maturity_reward = calculator.compute_base_reward(&signal, &LifecycleStage::Maturity);

        // With delta_s > delta_c, Infancy should give higher reward
        assert!(
            infancy_reward > maturity_reward,
            "Infancy should reward novelty more"
        );

        // Test opposite case
        let coherence_signal = LearningSignal {
            learning_magnitude: 0.5,
            delta_s: 0.4,
            delta_c: 0.6,
            ..Default::default()
        };

        let infancy_reward2 = calculator.compute_base_reward(&coherence_signal, &LifecycleStage::Infancy);
        let maturity_reward2 = calculator.compute_base_reward(&coherence_signal, &LifecycleStage::Maturity);

        // With delta_c > delta_s, Maturity should give higher reward
        assert!(
            maturity_reward2 > infancy_reward2,
            "Maturity should reward coherence more"
        );
    }

    #[test]
    fn universal_penalties_applied() {
        let calculator = SteeringRewardCalculator::new();

        let base_signal = LearningSignal::default();
        let lifecycle = LifecycleStage::Growth;

        // Test missing rationale penalty (-0.5)
        let reward_no_rationale = calculator.compute_reward(
            &base_signal,
            &lifecycle,
            false, // has_rationale
            Some(0.9),
            false,
        );

        let reward_with_rationale = calculator.compute_reward(
            &base_signal,
            &lifecycle,
            true, // has_rationale
            Some(0.9),
            false,
        );

        assert!(
            (reward_with_rationale.value - reward_no_rationale.value - 0.5).abs() < 0.01,
            "Missing rationale should apply -0.5 penalty"
        );

        // Test near-duplicate penalty (-0.4)
        let reward_duplicate = calculator.compute_reward(
            &base_signal,
            &lifecycle,
            true,
            Some(0.9),
            true, // is_near_duplicate
        );

        assert!(
            (reward_with_rationale.value - reward_duplicate.value - 0.4).abs() < 0.01,
            "Near-duplicate should apply -0.4 penalty"
        );
    }
}

mod dream_effectiveness_tests {
    use super::*;

    /// Verify that post-dream coherence improves.
    /// This is a placeholder for Module 6 dream implementation.
    #[test]
    #[ignore] // Enable after Module 6 implements dream
    fn post_dream_coherence_improvement() {
        let mut tracker = CoherenceTracker::new(Default::default());
        let mut processor = UtlProcessor::new(Default::default());

        // Add incoherent entries
        for i in 0..100 {
            tracker.add_entry(CoherenceEntry {
                similarity: (i as f32 % 10.0) / 10.0, // Oscillating
                timestamp: i as u64,
            });
        }

        let pre_dream_coherence = tracker.current_coherence();

        // Simulate dream consolidation (Module 6)
        // processor.trigger_dream_consolidation();

        let post_dream_coherence = tracker.current_coherence();

        assert!(
            post_dream_coherence > pre_dream_coherence,
            "Post-dream coherence should improve"
        );
    }
}

#[derive(Deserialize)]
struct ContentSample {
    text: String,
    embedding: Vec<f32>,
}
```

### Test Data Generation Script

```python
#!/usr/bin/env python3
"""Generate test fixtures for UTL validation tests."""

import json
import numpy as np
from pathlib import Path

FIXTURE_DIR = Path("tests/fixtures/utl")

def generate_needle_haystack():
    """Generate needle-in-haystack test data."""
    np.random.seed(42)

    # Haystack: 1000 similar embeddings
    base = np.random.randn(1536)
    base /= np.linalg.norm(base)

    haystack = []
    for _ in range(1000):
        noise = np.random.randn(1536) * 0.1
        emb = base + noise
        emb /= np.linalg.norm(emb)
        haystack.append(emb.tolist())

    # Needles: 10 distinct embeddings
    needles = []
    for _ in range(10):
        emb = np.random.randn(1536)
        emb /= np.linalg.norm(emb)
        needles.append(emb.tolist())

    # Expected rankings: needles should appear first
    expected = list(range(1000, 1010))  # Indices of needles

    output_dir = FIXTURE_DIR / "needle_haystack"
    output_dir.mkdir(parents=True, exist_ok=True)

    with open(output_dir / "haystack_embeddings.json", "w") as f:
        json.dump(haystack, f)
    with open(output_dir / "needle_embeddings.json", "w") as f:
        json.dump(needles, f)
    with open(output_dir / "expected_rankings.json", "w") as f:
        json.dump(expected, f)

if __name__ == "__main__":
    FIXTURE_DIR.mkdir(parents=True, exist_ok=True)
    generate_needle_haystack()
    # generate_dynamics_data()
    # generate_lifecycle_data()
    # generate_johari_cases()
```

## Performance Targets
- Needle-haystack test: <10s
- Correlation computation: <1s
- Lifecycle test: <100ms
- Johari test: <10ms

## Related Tasks
- M05-T22: UtlProcessor being validated
- M05-T19: LifecycleManager being validated
- M05-T25: Integration test foundation

---
*Generated: 2026-01-04*
*Module: 05 - UTL Integration*
*Version: 1.0.0*
