# M05-T26: Implement utl_status MCP Tool

```yaml
metadata:
  id: "M05-T26"
  title: "Implement utl_status MCP Tool"
  module: "module-05"
  module_name: "UTL Integration"
  layer: "integration"
  priority: "critical"
  estimated_hours: 3
  created: "2026-01-04"
  status: "pending"
  dependencies:
    - "M05-T22"  # UtlProcessor orchestrator (COMPLETED)
    - "M05-T24"  # UtlStatus/UtlStatusResponse structs (COMPLETED)
  spec_refs:
    - "SPEC-UTL-005 Section 10.1"
```

## Description

Implement the `utl_status` MCP tool that exposes UTL system state via the JSON-RPC 2.0 protocol. This tool enables external systems (Claude, AI agents, monitoring) to query the current learning system status.

**CRITICAL**: The types `UtlStatus`, `UtlStatusResponse`, and `ThresholdsResponse` already exist in `context-graph-utl/src/metrics.rs` and are exported via `context-graph-utl/src/lib.rs`. You MUST reuse these types - do NOT create duplicates.

## Source of Truth Files

Before implementing, READ these files to understand the current architecture:

| Purpose | File Path |
|---------|-----------|
| **Existing UtlStatus struct** | `crates/context-graph-utl/src/metrics.rs:418-439` |
| **Existing to_mcp_response()** | `crates/context-graph-utl/src/metrics.rs:503-515` |
| **Existing UtlStatusResponse** | `crates/context-graph-utl/src/metrics.rs:524-551` |
| **Existing ThresholdsResponse** | `crates/context-graph-utl/src/metrics.rs:554-570` |
| **UTL crate exports** | `crates/context-graph-utl/src/lib.rs:72-75` |
| **UtlProcessor trait** | `crates/context-graph-core/src/traits/utl_processor.rs` |
| **Tool definitions** | `crates/context-graph-mcp/src/tools.rs` |
| **Tool dispatch** | `crates/context-graph-mcp/src/handlers/tools.rs:62-74` |
| **Handlers struct** | `crates/context-graph-mcp/src/handlers/core.rs:12-24` |
| **Existing UTL handlers** | `crates/context-graph-mcp/src/handlers/utl.rs` |

## Implementation File Locations

| Type | Path | Action |
|------|------|--------|
| Tool definition | `crates/context-graph-mcp/src/tools.rs` | ADD tool to `get_tool_definitions()` |
| Tool name constant | `crates/context-graph-mcp/src/tools.rs` | ADD `UTL_STATUS` constant |
| Tool handler | `crates/context-graph-mcp/src/handlers/tools.rs` | ADD dispatch case + handler |
| Handler tests | `crates/context-graph-mcp/src/handlers/tests/utl_status_tests.rs` | CREATE |

## Existing Types (DO NOT DUPLICATE)

### UtlStatus (from context-graph-utl/src/metrics.rs:418-439)

```rust
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct UtlStatus {
    pub lifecycle_stage: LifecycleStage,      // Infancy | Growth | Maturity
    pub interaction_count: u64,                // Total interactions
    pub current_thresholds: StageThresholds,   // Stage-specific thresholds
    pub lambda_weights: LifecycleLambdaWeights, // Marblestone weights
    pub phase_angle: f32,                      // [0, PI]
    pub consolidation_phase: ConsolidationPhase, // NREM | REM | Wake
    pub metrics: UtlComputationMetrics,        // Aggregated metrics
}
```

### UtlStatusResponse (from context-graph-utl/src/metrics.rs:524-551)

```rust
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct UtlStatusResponse {
    pub lifecycle_phase: String,       // "Infancy" | "Growth" | "Maturity"
    pub interaction_count: u64,
    pub entropy: f32,                  // avg_delta_s [0, 1]
    pub coherence: f32,                // avg_delta_c [0, 1]
    pub learning_score: f32,           // avg_learning_magnitude [0, 1]
    pub johari_quadrant: String,       // "Open" | "Blind" | "Hidden" | "Unknown"
    pub consolidation_phase: String,   // "NREM" | "REM" | "Wake"
    pub phase_angle: f32,              // [0, PI]
    pub thresholds: ThresholdsResponse,
}
```

### Conversion Method (from context-graph-utl/src/metrics.rs:503-515)

```rust
impl UtlStatus {
    pub fn to_mcp_response(&self) -> UtlStatusResponse {
        UtlStatusResponse {
            lifecycle_phase: format!("{:?}", self.lifecycle_stage),
            interaction_count: self.interaction_count,
            entropy: self.metrics.avg_delta_s,
            coherence: self.metrics.avg_delta_c,
            learning_score: self.metrics.avg_learning_magnitude,
            johari_quadrant: format!("{:?}", self.metrics.dominant_quadrant()),
            consolidation_phase: format!("{:?}", self.consolidation_phase),
            phase_angle: self.phase_angle,
            thresholds: ThresholdsResponse::from(&self.current_thresholds),
        }
    }
}
```

## Implementation Steps

### Step 1: Add Tool Definition (tools.rs)

Add to `crates/context-graph-mcp/src/tools.rs`:

```rust
// In get_tool_definitions() vec![...]:
ToolDefinition::new(
    "utl_status",
    "Query current UTL (Unified Theory of Learning) system state including lifecycle phase, \
     entropy, coherence, learning score, Johari quadrant, and consolidation phase.",
    json!({
        "type": "object",
        "properties": {},
        "required": []
    }),
),

// In tool_names module:
pub const UTL_STATUS: &str = "utl_status";
```

### Step 2: Add Tool Dispatch (handlers/tools.rs)

Add to `crates/context-graph-mcp/src/handlers/tools.rs`:

```rust
// Add import at top:
use context_graph_utl::{UtlStatus, UtlStatusResponse};

// Add match arm in handle_tools_call() at line ~68:
tool_names::UTL_STATUS => self.call_utl_status(id).await,

// Add handler method:
/// utl_status tool implementation.
pub(super) async fn call_utl_status(&self, id: Option<JsonRpcId>) -> JsonRpcResponse {
    // Get current UTL status from processor
    let status = match self.utl_processor.get_status() {
        Some(s) => s,
        None => {
            // Return default status if no state yet
            UtlStatus::default()
        }
    };

    // Convert to MCP response format using existing method
    let response = status.to_mcp_response();

    Self::tool_result(id, serde_json::to_value(response).unwrap_or_default())
}
```

### Step 3: Extend UtlProcessor Trait (REQUIRED)

The `UtlProcessor` trait in `context-graph-core/src/traits/utl_processor.rs` must be extended:

```rust
/// Get current UTL system status.
fn get_status(&self) -> Option<UtlStatus>;
```

Then implement in `context-graph-utl/src/processor.rs`:

```rust
fn get_status(&self) -> Option<UtlStatus> {
    Some(UtlStatus {
        lifecycle_stage: self.lifecycle_manager.current_stage(),
        interaction_count: self.session.interaction_count,
        current_thresholds: self.lifecycle_manager.current_thresholds(),
        lambda_weights: self.lifecycle_manager.current_weights(),
        phase_angle: self.phase_oscillator.current_angle(),
        consolidation_phase: self.phase_detector.current_phase(),
        metrics: self.metrics.clone(),
    })
}
```

### Step 4: Update Test Count (tools.rs)

Update test in `tools.rs`:
```rust
#[test]
fn test_get_tool_definitions() {
    let tools = get_tool_definitions();
    assert_eq!(tools.len(), 6);  // Was 5, now 6 with utl_status
    // ...
    assert!(tool_names.contains(&"utl_status"));
}
```

## Acceptance Criteria

- [ ] `utl_status` tool registered in `get_tool_definitions()`
- [ ] `UTL_STATUS` constant added to `tool_names` module
- [ ] Tool dispatch case added in `handle_tools_call()`
- [ ] Handler method `call_utl_status()` implemented
- [ ] Uses existing `UtlStatus::to_mcp_response()` - NO DUPLICATED TYPES
- [ ] `UtlProcessor::get_status()` method added to trait
- [ ] Processor implements `get_status()` returning real data
- [ ] Response matches `UtlStatusResponse` schema exactly
- [ ] All tests pass with `cargo test -p context-graph-mcp`
- [ ] Integration test with real MCP JSON-RPC call works

## Test Cases (NO MOCK DATA)

Create `crates/context-graph-mcp/src/handlers/tests/utl_status_tests.rs`:

```rust
//! UTL status tool tests.
//!
//! CRITICAL: All tests use REAL implementations, not mocks.

use super::*;
use crate::handlers::Handlers;
use crate::protocol::{JsonRpcRequest, JsonRpcResponse};
use context_graph_utl::UtlProcessor as UtlProcessorImpl;
use std::sync::Arc;

/// Create real handlers with real implementations (NO MOCKS).
fn create_real_handlers() -> Handlers {
    let memory_store = Arc::new(context_graph_memory::InMemoryStore::new());
    let utl_processor = Arc::new(UtlProcessorImpl::new(Default::default()));
    Handlers::new(memory_store, utl_processor)
}

#[tokio::test]
async fn test_utl_status_returns_valid_response() {
    let handlers = create_real_handlers();

    let request = JsonRpcRequest {
        jsonrpc: "2.0".to_string(),
        id: Some(serde_json::json!(1)),
        method: "tools/call".to_string(),
        params: Some(serde_json::json!({
            "name": "utl_status",
            "arguments": {}
        })),
    };

    let response = handlers.dispatch(request).await;

    // FAIL FAST: Must be success, no silent failures
    assert!(response.error.is_none(), "Response should not have error: {:?}", response.error);

    let result = response.result.expect("Must have result");
    let content = result.get("content").expect("Must have content");
    let text = content[0].get("text").expect("Must have text").as_str().unwrap();
    let status: serde_json::Value = serde_json::from_str(text).expect("Must be valid JSON");

    // Verify all required fields present (fail fast)
    assert!(status.get("lifecycle_phase").is_some(), "Missing lifecycle_phase");
    assert!(status.get("interaction_count").is_some(), "Missing interaction_count");
    assert!(status.get("entropy").is_some(), "Missing entropy");
    assert!(status.get("coherence").is_some(), "Missing coherence");
    assert!(status.get("learning_score").is_some(), "Missing learning_score");
    assert!(status.get("johari_quadrant").is_some(), "Missing johari_quadrant");
    assert!(status.get("consolidation_phase").is_some(), "Missing consolidation_phase");
    assert!(status.get("phase_angle").is_some(), "Missing phase_angle");
    assert!(status.get("thresholds").is_some(), "Missing thresholds");
}

#[tokio::test]
async fn test_utl_status_value_ranges() {
    let handlers = create_real_handlers();

    let response = handlers.call_utl_status(Some(serde_json::json!(1))).await;

    // Extract and parse response
    let result = response.result.expect("Must have result");
    let text = result["content"][0]["text"].as_str().unwrap();
    let status: serde_json::Value = serde_json::from_str(text).expect("Valid JSON");

    // Validate ranges with FAIL FAST assertions
    let entropy = status["entropy"].as_f64().expect("entropy must be number") as f32;
    let coherence = status["coherence"].as_f64().expect("coherence must be number") as f32;
    let learning_score = status["learning_score"].as_f64().expect("learning_score must be number") as f32;
    let phase_angle = status["phase_angle"].as_f64().expect("phase_angle must be number") as f32;

    assert!(entropy >= 0.0 && entropy <= 1.0, "entropy {} out of [0,1]", entropy);
    assert!(coherence >= 0.0 && coherence <= 1.0, "coherence {} out of [0,1]", coherence);
    assert!(learning_score >= 0.0 && learning_score <= 1.0, "learning_score {} out of [0,1]", learning_score);
    assert!(phase_angle >= 0.0 && phase_angle <= std::f32::consts::PI, "phase_angle {} out of [0,PI]", phase_angle);

    // Validate lifecycle_phase is valid enum value
    let lifecycle = status["lifecycle_phase"].as_str().expect("lifecycle_phase must be string");
    assert!(
        ["Infancy", "Growth", "Maturity"].contains(&lifecycle),
        "Invalid lifecycle_phase: {}", lifecycle
    );

    // Validate johari_quadrant is valid enum value
    let quadrant = status["johari_quadrant"].as_str().expect("johari_quadrant must be string");
    assert!(
        ["Open", "Blind", "Hidden", "Unknown"].contains(&quadrant),
        "Invalid johari_quadrant: {}", quadrant
    );

    // Validate consolidation_phase is valid enum value
    let phase = status["consolidation_phase"].as_str().expect("consolidation_phase must be string");
    assert!(
        ["NREM", "REM", "Wake"].contains(&phase),
        "Invalid consolidation_phase: {}", phase
    );
}

#[tokio::test]
async fn test_utl_status_thresholds_structure() {
    let handlers = create_real_handlers();

    let response = handlers.call_utl_status(Some(serde_json::json!(1))).await;
    let result = response.result.expect("Must have result");
    let text = result["content"][0]["text"].as_str().unwrap();
    let status: serde_json::Value = serde_json::from_str(text).expect("Valid JSON");

    let thresholds = status.get("thresholds").expect("Must have thresholds");

    // FAIL FAST: All threshold fields required
    assert!(thresholds.get("entropy_trigger").is_some(), "Missing entropy_trigger");
    assert!(thresholds.get("coherence_trigger").is_some(), "Missing coherence_trigger");
    assert!(thresholds.get("min_importance_store").is_some(), "Missing min_importance_store");
    assert!(thresholds.get("consolidation_threshold").is_some(), "Missing consolidation_threshold");

    // Validate threshold ranges
    let entropy_trigger = thresholds["entropy_trigger"].as_f64().unwrap() as f32;
    let coherence_trigger = thresholds["coherence_trigger"].as_f64().unwrap() as f32;

    assert!(entropy_trigger >= 0.0 && entropy_trigger <= 1.0);
    assert!(coherence_trigger >= 0.0 && coherence_trigger <= 1.0);
}

#[tokio::test]
async fn test_utl_status_after_processing() {
    let handlers = create_real_handlers();

    // First, inject some context to change UTL state
    let inject_request = JsonRpcRequest {
        jsonrpc: "2.0".to_string(),
        id: Some(serde_json::json!(1)),
        method: "tools/call".to_string(),
        params: Some(serde_json::json!({
            "name": "inject_context",
            "arguments": {
                "content": "Machine learning uses neural networks for pattern recognition.",
                "rationale": "Test content for UTL processing"
            }
        })),
    };

    let _ = handlers.dispatch(inject_request).await;

    // Now check status reflects the interaction
    let response = handlers.call_utl_status(Some(serde_json::json!(2))).await;
    let result = response.result.expect("Must have result");
    let text = result["content"][0]["text"].as_str().unwrap();
    let status: serde_json::Value = serde_json::from_str(text).expect("Valid JSON");

    // Interaction count should have increased
    let count = status["interaction_count"].as_u64().expect("interaction_count must be u64");
    assert!(count >= 1, "interaction_count should be at least 1 after inject_context");
}
```

## Edge Case Tests

```rust
#[tokio::test]
async fn test_utl_status_boundary_phase_angle() {
    let handlers = create_real_handlers();

    let response = handlers.call_utl_status(Some(serde_json::json!(1))).await;
    let result = response.result.unwrap();
    let text = result["content"][0]["text"].as_str().unwrap();
    let status: serde_json::Value = serde_json::from_str(text).unwrap();

    let phase_angle = status["phase_angle"].as_f64().unwrap() as f32;

    // Phase angle must be exactly within [0, PI], not just close
    assert!(phase_angle >= 0.0, "phase_angle {} must be >= 0", phase_angle);
    assert!(phase_angle <= std::f32::consts::PI, "phase_angle {} must be <= PI", phase_angle);
}

#[tokio::test]
async fn test_utl_status_default_state() {
    // Test with fresh processor (no interactions)
    let handlers = create_real_handlers();

    let response = handlers.call_utl_status(Some(serde_json::json!(1))).await;
    let result = response.result.unwrap();
    let text = result["content"][0]["text"].as_str().unwrap();
    let status: serde_json::Value = serde_json::from_str(text).unwrap();

    // Default state should be Infancy with 0 interactions
    assert_eq!(status["lifecycle_phase"].as_str().unwrap(), "Infancy");
    assert_eq!(status["interaction_count"].as_u64().unwrap(), 0);
}

#[tokio::test]
async fn test_utl_status_serialization_roundtrip() {
    let handlers = create_real_handlers();

    let response = handlers.call_utl_status(Some(serde_json::json!(1))).await;
    let result = response.result.unwrap();
    let text = result["content"][0]["text"].as_str().unwrap();

    // Parse to UtlStatusResponse struct (not just Value)
    let status: context_graph_utl::UtlStatusResponse =
        serde_json::from_str(text).expect("Must deserialize to UtlStatusResponse");

    // Re-serialize and compare
    let re_serialized = serde_json::to_string(&status).expect("Must serialize");
    let re_parsed: context_graph_utl::UtlStatusResponse =
        serde_json::from_str(&re_serialized).expect("Must deserialize again");

    assert_eq!(status, re_parsed, "Roundtrip serialization must match");
}
```

## Verification Commands

```bash
# Build MCP crate
cargo build -p context-graph-mcp

# Run all MCP tests
cargo test -p context-graph-mcp

# Run specific utl_status tests
cargo test -p context-graph-mcp utl_status

# Test MCP tool manually via JSON-RPC
echo '{"jsonrpc":"2.0","method":"tools/call","params":{"name":"utl_status","arguments":{}},"id":1}' | \
  cargo run -p context-graph-mcp --bin context-graph-mcp

# Verify tool is registered
echo '{"jsonrpc":"2.0","method":"tools/list","id":1}' | \
  cargo run -p context-graph-mcp --bin context-graph-mcp | \
  jq '.result.tools[] | select(.name == "utl_status")'
```

## Full State Verification Protocol

### 1. Source of Truth Verification

Before starting implementation, verify these types exist and match:

```bash
# Verify UtlStatus exists
grep -n "pub struct UtlStatus" crates/context-graph-utl/src/metrics.rs

# Verify UtlStatusResponse exists
grep -n "pub struct UtlStatusResponse" crates/context-graph-utl/src/metrics.rs

# Verify to_mcp_response exists
grep -n "to_mcp_response" crates/context-graph-utl/src/metrics.rs

# Verify exports in lib.rs
grep "UtlStatus" crates/context-graph-utl/src/lib.rs
```

### 2. Execute & Inspect

After implementation, run comprehensive verification:

```bash
# All tests must pass (385+ existing + new)
cargo test -p context-graph-utl
cargo test -p context-graph-mcp

# JSON-RPC end-to-end test
RESPONSE=$(echo '{"jsonrpc":"2.0","method":"tools/call","params":{"name":"utl_status","arguments":{}},"id":1}' | \
  cargo run -p context-graph-mcp --bin context-graph-mcp 2>/dev/null)

# Verify response structure
echo "$RESPONSE" | jq -e '.result.content[0].text | fromjson |
  .lifecycle_phase and .interaction_count and .entropy and .coherence and
  .learning_score and .johari_quadrant and .consolidation_phase and
  .phase_angle and .thresholds'
```

### 3. Edge Case Audit

Test these specific scenarios:
- [ ] Fresh processor returns Infancy stage with 0 interactions
- [ ] After 100 inject_context calls, stage transitions to Growth
- [ ] All numeric values within documented ranges
- [ ] Invalid tool name returns proper error

### 4. Evidence of Success

Final verification checklist:
- [ ] `cargo test -p context-graph-mcp` shows 100% pass rate
- [ ] `tools/list` response includes `utl_status` with correct schema
- [ ] `tools/call` with `utl_status` returns valid `UtlStatusResponse` JSON
- [ ] Response values match ranges in constitution.yaml
- [ ] No duplicate type definitions exist

## Sherlock-Holmes Verification

After implementation is complete, spawn a sherlock-holmes subagent to perform forensic verification:

```
Task: Forensic verification of M05-T26 utl_status MCP tool implementation

Investigate:
1. Type duplication: Ensure UtlStatus, UtlStatusResponse, ThresholdsResponse are NOT duplicated
2. Import correctness: Verify imports come from context-graph-utl, not recreated
3. Response schema: Verify JSON response matches UtlStatusResponse exactly
4. Range validation: Confirm all numeric values are within documented ranges
5. Error handling: Check for proper error responses on edge cases
6. Test coverage: Verify tests use REAL implementations, not mocks

Evidence required:
- grep proof of single type definitions
- test output showing pass/fail
- JSON-RPC response samples
- Import statements verification
```

## Notes

- Session-scoped queries are NOT implemented in this task (future M05-T27)
- Global status only - returns aggregate UTL state
- Response schema is forward-compatible for future field additions
- Uses existing `UtlStatus::to_mcp_response()` method - NO DUPLICATION
