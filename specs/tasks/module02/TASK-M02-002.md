# TASK-M02-002: Define Modality Enum

```xml
<task_spec id="TASK-M02-002" version="1.0">
<metadata>
  <title>Define Modality Enum</title>
  <status>ready</status>
  <layer>foundation</layer>
  <module>module-02</module>
  <sequence>2</sequence>
  <priority>high</priority>
  <estimated_hours>1.5</estimated_hours>
  <implements>
    <item>TECH-CORE-002 Section 2.3: Metadata modality specification</item>
  </implements>
  <depends_on>
    <!-- No dependencies - this is a foundation task -->
  </depends_on>
  <estimated_complexity>low</estimated_complexity>
</metadata>

<context>
The Modality enum classifies the type of content stored in a MemoryNode. It enables modality-specific embedding strategies and content processing. The detect() method provides automatic content classification based on patterns, while file_extensions() supports file-based content ingestion.
</context>

<input_context_files>
  <file purpose="Constitution reference for naming conventions">docs2/constitution.yaml</file>
  <file purpose="PRD reference for embedding models per modality">docs2/contextprd.md</file>
</input_context_files>

<prerequisites>
  <check>crates/context-graph-core directory exists</check>
  <check>Cargo.toml for context-graph-core crate exists</check>
</prerequisites>

<scope>
  <in_scope>
    - Modality enum definition with 6 variants: Text, Code, Image, Audio, Structured, Mixed
    - detect() method for automatic content-based modality detection
    - file_extensions() method returning slice of extensions per modality
    - Default trait implementation (returns Text)
    - Display trait implementation
    - Serde Serialize/Deserialize derives
    - Clone, Copy, Debug, PartialEq, Eq, Hash derives
    - Unit tests for all methods
  </in_scope>
  <out_of_scope>
    - NodeMetadata struct (handled in TASK-M02-003)
    - Embedding model selection logic (handled in embedding crate)
  </out_of_scope>
</scope>

<definition_of_done>
  <signatures>
    <signature file="crates/context-graph-core/src/metadata.rs">
/// Represents the modality/type of content stored in a memory node.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum Modality {
    /// Plain text content
    Text,
    /// Source code content
    Code,
    /// Image content (base64 encoded or reference)
    Image,
    /// Audio content (base64 encoded or reference)
    Audio,
    /// Structured data (JSON, YAML, TOML)
    Structured,
    /// Mixed modality content
    Mixed,
}

impl Modality {
    /// Automatically detect modality from content string.
    /// Analyzes content patterns to determine the most likely modality.
    pub fn detect(content: &amp;str) -> Self;

    /// Returns common file extensions associated with this modality.
    pub fn file_extensions(&amp;self) -> &amp;'static [&amp;'static str];

    /// Returns the primary embedding model ID for this modality.
    pub fn primary_embedding_model(&amp;self) -> &amp;'static str;
}

impl Default for Modality {
    fn default() -> Self;
}

impl std::fmt::Display for Modality {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -> std::fmt::Result;
}
    </signature>
  </signatures>

  <constraints>
    - detect() must identify code patterns: fn, def, class, import, function, const, let, var, pub, async, impl
    - detect() must identify structured data: starts with { or [ (JSON), contains ": " patterns (YAML)
    - detect() must be case-sensitive for code keywords
    - File extensions must be lowercase without leading dots
    - Module file must not exceed 500 lines (excluding tests)
  </constraints>

  <verification>
    - cargo build --package context-graph-core compiles without errors
    - cargo test --package context-graph-core modality passes all tests
    - cargo clippy --package context-graph-core shows no warnings
  </verification>
</definition_of_done>

<pseudo_code>
metadata.rs:
  // Module documentation
  // Imports: serde

  // Modality enum with derives
  // Six variants: Text, Code, Image, Audio, Structured, Mixed

  impl Modality:
    fn detect(content: &amp;str):
      // Check for code patterns first (most specific)
      code_patterns = ["fn ", "def ", "class ", "import ", "function ",
                       "const ", "let ", "var ", "pub ", "async ", "impl "]
      if content contains any code_pattern:
        return Code

      // Check for structured data
      trimmed = content.trim()
      if trimmed.starts_with('{') or trimmed.starts_with('['):
        return Structured
      if content contains regex pattern "^\s*\w+:\s" (YAML-like):
        return Structured

      // Check for base64 image/audio markers
      if content.starts_with("data:image"):
        return Image
      if content.starts_with("data:audio"):
        return Audio

      // Default to text
      return Text

    fn file_extensions():
      match self:
        Text => ["txt", "md", "rst", "adoc"]
        Code => ["rs", "py", "js", "ts", "go", "java", "c", "cpp", "h"]
        Image => ["png", "jpg", "jpeg", "gif", "svg", "webp"]
        Audio => ["mp3", "wav", "ogg", "flac", "m4a"]
        Structured => ["json", "yaml", "yml", "toml", "xml"]
        Mixed => []

    fn primary_embedding_model():
      match self:
        Text => "E1_Semantic"
        Code => "E7_Code"
        Image => "E10_Multimodal"
        Audio => "E10_Multimodal"
        Structured => "E1_Semantic"
        Mixed => "E1_Semantic"

  impl Default: return Text
  impl Display: write modality name

#[cfg(test)]
mod tests:
  test_detect_code_rust()
  test_detect_code_python()
  test_detect_structured_json()
  test_detect_structured_yaml()
  test_detect_text()
  test_file_extensions()
  test_serde_roundtrip()
  test_default()
</pseudo_code>

<files_to_create>
  <file path="crates/context-graph-core/src/metadata.rs">Modality enum (NodeMetadata added in TASK-M02-003)</file>
</files_to_create>

<files_to_modify>
  <file path="crates/context-graph-core/src/lib.rs">Add pub mod metadata; and re-export Modality</file>
</files_to_modify>

<validation_criteria>
  <criterion>Modality enum compiles with 6 variants: Text, Code, Image, Audio, Structured, Mixed</criterion>
  <criterion>detect() correctly identifies Rust code (fn, impl, pub)</criterion>
  <criterion>detect() correctly identifies Python code (def, class, import)</criterion>
  <criterion>detect() correctly identifies JSON (starts with { or [)</criterion>
  <criterion>detect() correctly identifies YAML patterns</criterion>
  <criterion>detect() defaults to Text for plain text content</criterion>
  <criterion>file_extensions() returns non-empty slice for each modality (except Mixed)</criterion>
  <criterion>Default trait implementation returns Text</criterion>
  <criterion>Serde round-trip works correctly</criterion>
</validation_criteria>

<test_commands>
  <command>cargo build --package context-graph-core</command>
  <command>cargo test --package context-graph-core modality -- --nocapture</command>
  <command>cargo clippy --package context-graph-core -- -D warnings</command>
</test_commands>
</task_spec>
```

## Implementation Notes

### Code Detection Patterns
The detect() method should recognize common programming patterns:
- Rust: `fn `, `impl `, `pub `, `mod `, `use `, `struct `, `enum `
- Python: `def `, `class `, `import `, `from `, `async def`
- JavaScript/TypeScript: `function `, `const `, `let `, `var `, `export `
- Go: `func `, `package `, `import `

### Embedding Model Mapping (Reference from PRD)
| Modality | Primary Model | Dimension |
|----------|---------------|-----------|
| Text | E1_Semantic | 1024D |
| Code | E7_Code | 1536D |
| Image | E10_Multimodal | 1024D |
| Audio | E10_Multimodal | 1024D |
| Structured | E1_Semantic | 1024D |
| Mixed | E1_Semantic | 1024D |

---

*Task ID: TASK-M02-002*
*Module: 02 - Core Infrastructure*
*Layer: Foundation*
