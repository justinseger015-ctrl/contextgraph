# TASK-M02-002: Complete Modality Enum Implementation

## Status: READY (No blocking dependencies)

## Critical Context

**IMPORTANT**: The `Modality` enum already exists but is INCOMPLETE. It is defined in `crates/context-graph-core/src/types/johari.rs` starting at line 176. The current implementation has:
- 6 variants (Text, Code, Image, Audio, Structured, Mixed) ✅
- Default trait (returns Text) ✅
- Serialize/Deserialize derives ✅
- Clone, Copy, Debug, PartialEq, Eq, Hash derives ✅

**MISSING (this task must implement)**:
- `detect(&str) -> Self` method
- `file_extensions(&self) -> &'static [&'static str]` method
- `primary_embedding_model(&self) -> &'static str` method
- Display trait implementation
- Comprehensive unit tests for all methods

## File Locations

| File | Purpose | Action |
|------|---------|--------|
| `crates/context-graph-core/src/types/johari.rs` | Modality enum definition | MODIFY (add methods + tests) |
| `crates/context-graph-core/src/lib.rs` | Public exports | NO CHANGE (already exports via types module) |

**DO NOT create `metadata.rs`** - the original task spec was wrong. Modality lives in `johari.rs`.

## Exact Implementation Required

Add the following to `johari.rs` after the existing `Modality` enum definition (around line 190):

```rust
impl Modality {
    /// Detect modality from content string by analyzing patterns.
    ///
    /// # Detection Order (most specific first):
    /// 1. Code patterns (fn, def, class, import, etc.)
    /// 2. Structured data (JSON/YAML markers)
    /// 3. Data URIs (image/audio)
    /// 4. Default: Text
    ///
    /// # Examples
    /// ```
    /// use context_graph_core::types::Modality;
    /// assert_eq!(Modality::detect("fn main() {}"), Modality::Code);
    /// assert_eq!(Modality::detect("{\"key\": 1}"), Modality::Structured);
    /// assert_eq!(Modality::detect("Hello world"), Modality::Text);
    /// ```
    pub fn detect(content: &str) -> Self {
        // Code patterns - case-sensitive, must include space after keyword
        const CODE_PATTERNS: &[&str] = &[
            "fn ", "def ", "class ", "import ", "function ",
            "const ", "let ", "var ", "pub ", "async ", "impl ",
            "struct ", "enum ", "mod ", "use ", "package ",
            "func ", "export ", "from ", "#include", "#define",
        ];

        for pattern in CODE_PATTERNS {
            if content.contains(pattern) {
                return Self::Code;
            }
        }

        // Structured data detection
        let trimmed = content.trim();
        if trimmed.starts_with('{') || trimmed.starts_with('[') {
            return Self::Structured;
        }

        // YAML detection: lines starting with word followed by colon
        if content.lines().any(|line| {
            let t = line.trim();
            !t.is_empty() && !t.starts_with('#') && t.contains(": ")
        }) {
            return Self::Structured;
        }

        // Data URI detection
        if content.starts_with("data:image") {
            return Self::Image;
        }
        if content.starts_with("data:audio") {
            return Self::Audio;
        }

        Self::Text
    }

    /// Returns common file extensions for this modality (lowercase, no dots).
    ///
    /// # Returns
    /// Static slice of extension strings. Empty slice for Mixed modality.
    pub fn file_extensions(&self) -> &'static [&'static str] {
        match self {
            Self::Text => &["txt", "md", "rst", "adoc"],
            Self::Code => &["rs", "py", "js", "ts", "go", "java", "c", "cpp", "h", "rb", "php"],
            Self::Image => &["png", "jpg", "jpeg", "gif", "svg", "webp", "bmp"],
            Self::Audio => &["mp3", "wav", "ogg", "flac", "m4a", "aac"],
            Self::Structured => &["json", "yaml", "yml", "toml", "xml"],
            Self::Mixed => &[],
        }
    }

    /// Returns the primary embedding model ID per PRD spec.
    ///
    /// # Model Mapping (from constitution.yaml Section 12-MODEL EMBEDDING)
    /// - Text: E1_Semantic (1024D)
    /// - Code: E7_Code (1536D)
    /// - Image: E10_Multimodal (1024D)
    /// - Audio: E10_Multimodal (1024D)
    /// - Structured: E1_Semantic (1024D)
    /// - Mixed: E1_Semantic (1024D)
    pub fn primary_embedding_model(&self) -> &'static str {
        match self {
            Self::Text => "E1_Semantic",
            Self::Code => "E7_Code",
            Self::Image => "E10_Multimodal",
            Self::Audio => "E10_Multimodal",
            Self::Structured => "E1_Semantic",
            Self::Mixed => "E1_Semantic",
        }
    }

    /// Returns all modality variants as a fixed-size array.
    pub fn all() -> [Modality; 6] {
        [Self::Text, Self::Code, Self::Image, Self::Audio, Self::Structured, Self::Mixed]
    }
}

impl std::fmt::Display for Modality {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Text => write!(f, "Text"),
            Self::Code => write!(f, "Code"),
            Self::Image => write!(f, "Image"),
            Self::Audio => write!(f, "Audio"),
            Self::Structured => write!(f, "Structured"),
            Self::Mixed => write!(f, "Mixed"),
        }
    }
}
```

## Required Tests

Add these tests inside the existing `#[cfg(test)] mod tests` block in `johari.rs`:

```rust
// =========================================================================
// TASK-M02-002: Modality Enum Tests
// =========================================================================

#[test]
fn test_modality_detect_rust_code() {
    assert_eq!(Modality::detect("fn main() { println!(\"hello\"); }"), Modality::Code);
    assert_eq!(Modality::detect("pub struct Foo { bar: i32 }"), Modality::Code);
    assert_eq!(Modality::detect("impl Default for Foo {}"), Modality::Code);
    assert_eq!(Modality::detect("use std::collections::HashMap;"), Modality::Code);
}

#[test]
fn test_modality_detect_python_code() {
    assert_eq!(Modality::detect("def hello(): pass"), Modality::Code);
    assert_eq!(Modality::detect("class Foo: pass"), Modality::Code);
    assert_eq!(Modality::detect("import os"), Modality::Code);
    assert_eq!(Modality::detect("from typing import List"), Modality::Code);
    assert_eq!(Modality::detect("async def fetch(): pass"), Modality::Code);
}

#[test]
fn test_modality_detect_javascript_code() {
    assert_eq!(Modality::detect("function foo() {}"), Modality::Code);
    assert_eq!(Modality::detect("const x = 5;"), Modality::Code);
    assert_eq!(Modality::detect("let y = 10;"), Modality::Code);
    assert_eq!(Modality::detect("var z = 'hello';"), Modality::Code);
    assert_eq!(Modality::detect("export default function() {}"), Modality::Code);
}

#[test]
fn test_modality_detect_structured_json() {
    assert_eq!(Modality::detect("{\"key\": \"value\"}"), Modality::Structured);
    assert_eq!(Modality::detect("[1, 2, 3]"), Modality::Structured);
    assert_eq!(Modality::detect("  { \"nested\": { } }"), Modality::Structured);
}

#[test]
fn test_modality_detect_structured_yaml() {
    assert_eq!(Modality::detect("key: value\nother: data"), Modality::Structured);
    assert_eq!(Modality::detect("name: John\nage: 30"), Modality::Structured);
}

#[test]
fn test_modality_detect_data_uri() {
    assert_eq!(Modality::detect("data:image/png;base64,iVBORw0KGg..."), Modality::Image);
    assert_eq!(Modality::detect("data:audio/mp3;base64,SUQz..."), Modality::Audio);
}

#[test]
fn test_modality_detect_plain_text() {
    assert_eq!(Modality::detect("Hello, world!"), Modality::Text);
    assert_eq!(Modality::detect("This is just a sentence."), Modality::Text);
    assert_eq!(Modality::detect("The quick brown fox"), Modality::Text);
    assert_eq!(Modality::detect(""), Modality::Text);
}

#[test]
fn test_modality_file_extensions() {
    assert!(Modality::Text.file_extensions().contains(&"txt"));
    assert!(Modality::Text.file_extensions().contains(&"md"));

    assert!(Modality::Code.file_extensions().contains(&"rs"));
    assert!(Modality::Code.file_extensions().contains(&"py"));
    assert!(Modality::Code.file_extensions().contains(&"js"));

    assert!(Modality::Image.file_extensions().contains(&"png"));
    assert!(Modality::Image.file_extensions().contains(&"jpg"));

    assert!(Modality::Audio.file_extensions().contains(&"mp3"));
    assert!(Modality::Audio.file_extensions().contains(&"wav"));

    assert!(Modality::Structured.file_extensions().contains(&"json"));
    assert!(Modality::Structured.file_extensions().contains(&"yaml"));

    assert!(Modality::Mixed.file_extensions().is_empty());
}

#[test]
fn test_modality_file_extensions_no_dots() {
    for modality in Modality::all() {
        for ext in modality.file_extensions() {
            assert!(!ext.starts_with('.'), "Extension '{}' should not start with dot", ext);
            assert_eq!(*ext, ext.to_lowercase(), "Extension '{}' should be lowercase", ext);
        }
    }
}

#[test]
fn test_modality_primary_embedding_model() {
    assert_eq!(Modality::Text.primary_embedding_model(), "E1_Semantic");
    assert_eq!(Modality::Code.primary_embedding_model(), "E7_Code");
    assert_eq!(Modality::Image.primary_embedding_model(), "E10_Multimodal");
    assert_eq!(Modality::Audio.primary_embedding_model(), "E10_Multimodal");
    assert_eq!(Modality::Structured.primary_embedding_model(), "E1_Semantic");
    assert_eq!(Modality::Mixed.primary_embedding_model(), "E1_Semantic");
}

#[test]
fn test_modality_display() {
    assert_eq!(format!("{}", Modality::Text), "Text");
    assert_eq!(format!("{}", Modality::Code), "Code");
    assert_eq!(format!("{}", Modality::Image), "Image");
    assert_eq!(format!("{}", Modality::Audio), "Audio");
    assert_eq!(format!("{}", Modality::Structured), "Structured");
    assert_eq!(format!("{}", Modality::Mixed), "Mixed");
}

#[test]
fn test_modality_serde_roundtrip() {
    for modality in Modality::all() {
        let json = serde_json::to_string(&modality).expect("serialize failed");
        let parsed: Modality = serde_json::from_str(&json).expect("deserialize failed");
        assert_eq!(modality, parsed, "Roundtrip failed for {:?}", modality);
    }
}

#[test]
fn test_modality_all_variants() {
    let all = Modality::all();
    assert_eq!(all.len(), 6);
    assert!(all.contains(&Modality::Text));
    assert!(all.contains(&Modality::Code));
    assert!(all.contains(&Modality::Image));
    assert!(all.contains(&Modality::Audio));
    assert!(all.contains(&Modality::Structured));
    assert!(all.contains(&Modality::Mixed));
}

#[test]
fn test_modality_clone_copy() {
    let original = Modality::Code;
    let cloned = original.clone();
    let copied = original;
    assert_eq!(original, cloned);
    assert_eq!(original, copied);
}

#[test]
fn test_modality_hash_consistency() {
    use std::collections::HashSet;
    let mut set = HashSet::new();
    for modality in Modality::all() {
        assert!(set.insert(modality), "Duplicate hash for {:?}", modality);
    }
    assert_eq!(set.len(), 6);
}
```

## Validation Commands

Run these commands to verify implementation:

```bash
# Build - MUST succeed with no errors
cargo build --package context-graph-core

# Run modality-specific tests - ALL must pass
cargo test --package context-graph-core modality -- --nocapture

# Lint check - MUST have zero warnings
cargo clippy --package context-graph-core -- -D warnings
```

## Full State Verification Protocol

After implementing, you MUST perform the following verification:

### 1. Source of Truth Verification
The source of truth is the compiled Rust module. Verify by:
```bash
# Confirm the enum exports correctly
cargo doc --package context-graph-core --open
# Check for Modality in the generated docs
```

### 2. Execute & Inspect
```bash
# Run all modality tests with output
cargo test --package context-graph-core modality -- --nocapture 2>&1 | tee /tmp/modality_test_output.txt

# Verify the exact test count matches expected
grep -c "test types::johari::tests::test_modality" /tmp/modality_test_output.txt
# Expected: 16 modality tests
```

### 3. Boundary & Edge Case Audit

**Edge Case 1: Empty Input**
```rust
// Add and run this test
#[test]
fn test_modality_detect_empty_string() {
    // Empty string should return Text (default)
    assert_eq!(Modality::detect(""), Modality::Text);
    println!("BEFORE: empty string input");
    println!("AFTER: Modality::Text returned");
}
```

**Edge Case 2: Whitespace-Only Input**
```rust
#[test]
fn test_modality_detect_whitespace_only() {
    assert_eq!(Modality::detect("   \n\t  "), Modality::Text);
    println!("BEFORE: whitespace-only input");
    println!("AFTER: Modality::Text returned");
}
```

**Edge Case 3: Code Keywords Without Trailing Space**
```rust
#[test]
fn test_modality_detect_keyword_no_space() {
    // "function" without trailing space should NOT match
    // "functionality" is not code
    assert_eq!(Modality::detect("functionality test"), Modality::Text);
    println!("BEFORE: 'functionality test' (keyword embedded)");
    println!("AFTER: Modality::Text returned (not Code)");
}
```

### 4. Evidence of Success

After all tests pass, capture evidence:
```bash
# Capture full test output with timestamps
date && cargo test --package context-graph-core modality -- --nocapture 2>&1

# Verify clippy is clean
cargo clippy --package context-graph-core -- -D warnings 2>&1 | grep -E "(warning|error)" || echo "CLIPPY: No warnings"

# Show line count of johari.rs to verify under 500 lines
wc -l crates/context-graph-core/src/types/johari.rs
```

## Constraints from Constitution.yaml

- Files must use snake_case naming
- Functions must use snake_case_verb_first pattern (e.g., `detect()` not `detectModality()`)
- Max 500 lines per module (excluding tests) - current johari.rs is ~413 lines, adding ~100 lines for Modality impl
- Serde must use `#[serde(rename_all = "snake_case")]` for JSON serialization
- All public items require `///` doc comments
- Unit tests must be co-located via `#[cfg(test)]`
- No `unwrap()` in production code (tests are OK)

## ABSOLUTE REQUIREMENTS (NO EXCEPTIONS)

1. **NO BACKWARDS COMPATIBILITY HACKS** - If something breaks, it errors immediately
2. **NO MOCK DATA IN TESTS** - Tests use real Modality enum behavior
3. **FAIL FAST** - Any validation failure must error with clear message
4. **SHERLOCK VERIFICATION** - After completion, spawn sherlock-holmes agent to verify

## Final Verification Step

After implementation is complete, you MUST run:

```
Task(sherlock-holmes): Verify TASK-M02-002 completion by:
1. Read crates/context-graph-core/src/types/johari.rs
2. Verify Modality enum has detect(), file_extensions(), primary_embedding_model() methods
3. Verify Display trait is implemented
4. Run: cargo test --package context-graph-core modality -- --nocapture
5. Verify ALL tests pass (expect 16+ modality tests)
6. Run: cargo clippy --package context-graph-core -- -D warnings
7. Verify ZERO warnings
8. Report any issues found
```

## Dependencies

- **Depends On**: None (this is a foundation task)
- **Blocks**: TASK-M02-003 (NodeMetadata), TASK-M02-005 (MemoryNode)

---

*Task ID: TASK-M02-002*
*Module: 02 - Core Infrastructure*
*Layer: Foundation*
*Estimated Hours: 1.5*
*Last Updated: 2025-12-31*
