# TASK-M02-015: Define Column Family Descriptors

```xml
<task_spec id="TASK-M02-015" version="1.0">
<metadata>
  <title>Define Column Family Descriptors</title>
  <status>blocked</status>
  <layer>logic</layer>
  <module>module-02</module>
  <sequence>15</sequence>
  <priority>critical</priority>
  <estimated_hours>3</estimated_hours>
  <implements>
    <item>REQ-CORE-005: Storage requirements</item>
    <item>TECH-CORE-002 Section 3.1: Column families specification</item>
  </implements>
  <depends_on>
    <task_ref>TASK-M02-013</task_ref>
  </depends_on>
  <estimated_complexity>medium</estimated_complexity>
</metadata>

<context>
This task defines the RocksDB column family structure for the Context Graph storage layer. Column families provide logical separation of data types with optimized settings for each access pattern. The 12 column families cover nodes, edges, embeddings, metadata, Johari quadrant indexes, temporal indexes, tag indexes, source indexes, and system metadata.
</context>

<input_context_files>
  <file purpose="Storage crate structure">crates/context-graph-storage/src/lib.rs</file>
  <file purpose="JohariQuadrant for CF names">crates/context-graph-core/src/johari.rs</file>
  <file purpose="Constitution reference for CF specs">docs2/constitution.yaml</file>
</input_context_files>

<prerequisites>
  <check>TASK-M02-013 (Storage crate structure) is complete</check>
  <check>column_families.rs placeholder exists</check>
</prerequisites>

<scope>
  <in_scope>
    - cf_names module with all 12 column family name constants
    - Column family option configurations
    - get_column_family_descriptors() function
    - Optimized Options per CF type
    - Unit tests for CF configurations
  </in_scope>
  <out_of_scope>
    - Actual database creation (handled in TASK-M02-016)
    - Data operations (handled in subsequent tasks)
  </out_of_scope>
</scope>

<definition_of_done>
  <signatures>
    <signature file="crates/context-graph-storage/src/column_families.rs">
use rocksdb::{ColumnFamilyDescriptor, Options, BlockBasedOptions, Cache, SliceTransform};

/// Column family name constants.
pub mod cf_names {
    pub const NODES: &amp;str = "nodes";
    pub const EDGES: &amp;str = "edges";
    pub const EMBEDDINGS: &amp;str = "embeddings";
    pub const METADATA: &amp;str = "metadata";
    pub const JOHARI_OPEN: &amp;str = "johari_open";
    pub const JOHARI_HIDDEN: &amp;str = "johari_hidden";
    pub const JOHARI_BLIND: &amp;str = "johari_blind";
    pub const JOHARI_UNKNOWN: &amp;str = "johari_unknown";
    pub const TEMPORAL: &amp;str = "temporal";
    pub const TAGS: &amp;str = "tags";
    pub const SOURCES: &amp;str = "sources";
    pub const SYSTEM: &amp;str = "system";

    /// All column family names as a slice.
    pub const ALL: &amp;[&amp;str] = &amp;[
        NODES, EDGES, EMBEDDINGS, METADATA,
        JOHARI_OPEN, JOHARI_HIDDEN, JOHARI_BLIND, JOHARI_UNKNOWN,
        TEMPORAL, TAGS, SOURCES, SYSTEM,
    ];
}

/// Create options optimized for node storage (point lookups).
pub fn nodes_options(cache: &amp;Cache) -> Options;

/// Create options optimized for edge storage (range scans with prefix).
pub fn edges_options(cache: &amp;Cache) -> Options;

/// Create options optimized for embedding storage (large sequential reads).
pub fn embeddings_options(cache: &amp;Cache) -> Options;

/// Create options optimized for index column families.
pub fn index_options(cache: &amp;Cache) -> Options;

/// Create options for system metadata (small, infrequent access).
pub fn system_options() -> Options;

/// Get all column family descriptors with optimized options.
///
/// # Arguments
/// * `block_cache` - Shared block cache (recommended: 256MB)
pub fn get_column_family_descriptors(block_cache: &amp;Cache) -> Vec&lt;ColumnFamilyDescriptor&gt;;
    </signature>
  </signatures>

  <constraints>
    - Total of 12 column families
    - Nodes CF: 256MB cache allocation, bloom filter enabled
    - Edges CF: Prefix extractor for source_id lookups
    - Embeddings CF: Large block size for sequential reads
    - All CFs except system use LZ4 compression
    - Shared block cache across CFs (256MB recommended)
    - Bloom filter: 10 bits per key for nodes
  </constraints>

  <verification>
    - cargo build --package context-graph-storage compiles without errors
    - cargo test --package context-graph-storage column_families passes all tests
    - All 12 CF names are defined
  </verification>
</definition_of_done>

<pseudo_code>
column_families.rs:
  use rocksdb::{ColumnFamilyDescriptor, Options, BlockBasedOptions, Cache, SliceTransform};
  use rocksdb::DBCompressionType;

  pub mod cf_names {
    pub const NODES: &amp;str = "nodes";
    pub const EDGES: &amp;str = "edges";
    pub const EMBEDDINGS: &amp;str = "embeddings";
    pub const METADATA: &amp;str = "metadata";
    pub const JOHARI_OPEN: &amp;str = "johari_open";
    pub const JOHARI_HIDDEN: &amp;str = "johari_hidden";
    pub const JOHARI_BLIND: &amp;str = "johari_blind";
    pub const JOHARI_UNKNOWN: &amp;str = "johari_unknown";
    pub const TEMPORAL: &amp;str = "temporal";
    pub const TAGS: &amp;str = "tags";
    pub const SOURCES: &amp;str = "sources";
    pub const SYSTEM: &amp;str = "system";

    pub const ALL: &amp;[&amp;str] = &amp;[...];
  }

  pub fn nodes_options(cache: &amp;Cache) -> Options {
    let mut opts = Options::default();

    // Block-based table options
    let mut block_opts = BlockBasedOptions::default();
    block_opts.set_block_cache(cache);
    block_opts.set_bloom_filter(10.0, false);  // 10 bits per key
    block_opts.set_cache_index_and_filter_blocks(true);
    opts.set_block_based_table_factory(&amp;block_opts);

    // Compression
    opts.set_compression_type(DBCompressionType::Lz4);

    // Optimize for point lookups
    opts.optimize_for_point_lookup(256);  // 256MB

    opts
  }

  pub fn edges_options(cache: &amp;Cache) -> Options {
    let mut opts = Options::default();

    // Block-based table options
    let mut block_opts = BlockBasedOptions::default();
    block_opts.set_block_cache(cache);
    opts.set_block_based_table_factory(&amp;block_opts);

    // Prefix extractor for source_id (16 bytes UUID)
    opts.set_prefix_extractor(SliceTransform::create_fixed_prefix(16));

    // Compression
    opts.set_compression_type(DBCompressionType::Lz4);

    opts
  }

  pub fn embeddings_options(cache: &amp;Cache) -> Options {
    let mut opts = Options::default();

    // Large block size for sequential reads
    let mut block_opts = BlockBasedOptions::default();
    block_opts.set_block_cache(cache);
    block_opts.set_block_size(64 * 1024);  // 64KB blocks
    opts.set_block_based_table_factory(&amp;block_opts);

    // Compression
    opts.set_compression_type(DBCompressionType::Lz4);

    opts
  }

  pub fn index_options(cache: &amp;Cache) -> Options {
    let mut opts = Options::default();

    let mut block_opts = BlockBasedOptions::default();
    block_opts.set_block_cache(cache);
    opts.set_block_based_table_factory(&amp;block_opts);

    // Prefix extractor for index keys
    opts.set_prefix_extractor(SliceTransform::create_fixed_prefix(16));

    // Compression
    opts.set_compression_type(DBCompressionType::Lz4);

    opts
  }

  pub fn system_options() -> Options {
    let mut opts = Options::default();
    // No compression for small system data
    opts.set_compression_type(DBCompressionType::None);
    opts
  }

  pub fn get_column_family_descriptors(block_cache: &amp;Cache) -> Vec&lt;ColumnFamilyDescriptor&gt; {
    vec![
      ColumnFamilyDescriptor::new(cf_names::NODES, nodes_options(block_cache)),
      ColumnFamilyDescriptor::new(cf_names::EDGES, edges_options(block_cache)),
      ColumnFamilyDescriptor::new(cf_names::EMBEDDINGS, embeddings_options(block_cache)),
      ColumnFamilyDescriptor::new(cf_names::METADATA, nodes_options(block_cache)),
      ColumnFamilyDescriptor::new(cf_names::JOHARI_OPEN, index_options(block_cache)),
      ColumnFamilyDescriptor::new(cf_names::JOHARI_HIDDEN, index_options(block_cache)),
      ColumnFamilyDescriptor::new(cf_names::JOHARI_BLIND, index_options(block_cache)),
      ColumnFamilyDescriptor::new(cf_names::JOHARI_UNKNOWN, index_options(block_cache)),
      ColumnFamilyDescriptor::new(cf_names::TEMPORAL, index_options(block_cache)),
      ColumnFamilyDescriptor::new(cf_names::TAGS, index_options(block_cache)),
      ColumnFamilyDescriptor::new(cf_names::SOURCES, index_options(block_cache)),
      ColumnFamilyDescriptor::new(cf_names::SYSTEM, system_options()),
    ]
  }

#[cfg(test)]
mod tests:
  test_cf_names_count()
  test_all_contains_all_names()
  test_nodes_options_has_bloom_filter()
  test_edges_options_has_prefix_extractor()
  test_get_descriptors_returns_12()
</pseudo_code>

<files_to_create>
  <!-- File already exists as placeholder -->
</files_to_create>

<files_to_modify>
  <file path="crates/context-graph-storage/src/column_families.rs">Implement column family definitions</file>
  <file path="crates/context-graph-storage/src/lib.rs">Re-export column_families types</file>
</files_to_modify>

<validation_criteria>
  <criterion>cf_names module defines all 12 CF name constants</criterion>
  <criterion>get_column_family_descriptors() returns Vec with 12 descriptors</criterion>
  <criterion>nodes_options() enables bloom filter (10 bits)</criterion>
  <criterion>nodes_options() optimized for point lookups (256MB cache)</criterion>
  <criterion>edges_options() has prefix extractor for 16-byte UUID</criterion>
  <criterion>embeddings_options() uses 64KB block size</criterion>
  <criterion>All CFs use LZ4 compression except system CF</criterion>
</validation_criteria>

<test_commands>
  <command>cargo build --package context-graph-storage</command>
  <command>cargo test --package context-graph-storage column_families -- --nocapture</command>
</test_commands>
</task_spec>
```

## Implementation Notes

### Column Family Purpose Matrix
| CF Name | Purpose | Access Pattern | Optimization |
|---------|---------|----------------|--------------|
| nodes | Primary node data | Point lookups | Bloom filter, cache |
| edges | Edge data | Range scans by source | Prefix extractor |
| embeddings | Embedding vectors | Sequential read | Large blocks |
| metadata | Node metadata | Point lookups | Cache |
| johari_* | Quadrant indexes | Range scans | Prefix extractor |
| temporal | Time-based index | Range scans | Prefix extractor |
| tags | Tag index | Range scans | Prefix extractor |
| sources | Source index | Range scans | Prefix extractor |
| system | System metadata | Rare access | No compression |

### Shared Cache Recommendation
From constitution.yaml: "shared 256MB block cache with bloom filter"

The 256MB cache is shared across all column families to maximize hit rate while managing memory usage.

---

*Task ID: TASK-M02-015*
*Module: 02 - Core Infrastructure*
*Layer: Logic*
