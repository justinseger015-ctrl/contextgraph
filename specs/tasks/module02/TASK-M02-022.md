# TASK-M02-022: Implement CognitivePulse Methods

## Task Metadata
| Field | Value |
|-------|-------|
| Task ID | TASK-M02-022 |
| Status | **READY** |
| Layer | surface |
| Module | module-02 |
| Priority | critical |
| Estimated Hours | 2 |
| Depends On | TASK-M02-021 ✅ (CognitivePulse struct complete with 7 fields) |
| Implements | REQ-CORE-007, REQ-CORE-008, TECH-CORE-002 Section 2.4 |

---

## CRITICAL: Current State (Audited 2025-12-31)

**The CognitivePulse struct ALREADY EXISTS** with 7 fields and several methods. This task adds the **missing business logic methods**.

### Actual File Location
```
/home/cabdru/contextgraph/crates/context-graph-core/src/types/pulse.rs
```

### Current CognitivePulse Struct (lines 37-63)
```rust
pub struct CognitivePulse {
    pub entropy: f32,               // [0,1] uncertainty/novelty
    pub coherence: f32,             // [0,1] structural consistency
    pub coherence_delta: f32,       // [-1,1] change from previous
    pub emotional_weight: f32,      // [0,2] from EmotionalState
    pub suggested_action: SuggestedAction,
    pub source_layer: Option<LayerId>,
    pub timestamp: DateTime<Utc>,
}
```

### Existing Methods (ALREADY IMPLEMENTED - DO NOT MODIFY)
| Method | Signature | Status |
|--------|-----------|--------|
| `new()` | `fn new(entropy, coherence, coherence_delta, emotional_weight, suggested_action, source_layer) -> Self` | ✅ EXISTS |
| `computed()` | `fn computed(metrics: &UtlMetrics, source_layer: Option<LayerId>) -> Self` | ✅ EXISTS |
| `from_values()` | `fn from_values(entropy: f32, coherence: f32) -> Self` | ✅ EXISTS |
| `compute_action()` | `fn compute_action(entropy: f32, coherence: f32) -> SuggestedAction` | ✅ EXISTS (private) |
| `is_healthy()` | `fn is_healthy(&self) -> bool` | ✅ EXISTS |
| `with_emotion()` | `fn with_emotion(entropy, coherence, emotional_state, source_layer) -> Self` | ✅ EXISTS |
| `Default::default()` | `fn default() -> Self` | ✅ EXISTS |

### Methods To Implement (THIS TASK)
| Method | Purpose | Status |
|--------|---------|--------|
| `update()` | Modify entropy/coherence and recompute action | ❌ MISSING |
| `blend()` | Linear interpolation between two pulses | ❌ MISSING |

---

## Implementation Requirements

### 1. Add `update()` Method

Insert after `is_healthy()` method (around line 186):

```rust
/// Updates entropy and coherence by applying deltas.
///
/// Recomputes suggested_action based on new values.
/// All values are clamped to valid ranges.
///
/// # Arguments
/// * `delta_entropy` - Change to apply to entropy
/// * `delta_coherence` - Change to apply to coherence
///
/// # Example
/// ```rust
/// use context_graph_core::types::CognitivePulse;
///
/// let mut pulse = CognitivePulse::default();
/// assert_eq!(pulse.entropy, 0.5);
/// assert_eq!(pulse.coherence, 0.5);
///
/// pulse.update(0.2, -0.1);
/// assert_eq!(pulse.entropy, 0.7);
/// assert_eq!(pulse.coherence, 0.4);
/// ```
pub fn update(&mut self, delta_entropy: f32, delta_coherence: f32) {
    // Store old coherence for delta calculation
    let old_coherence = self.coherence;

    // Apply deltas with clamping
    self.entropy = (self.entropy + delta_entropy).clamp(0.0, 1.0);
    self.coherence = (self.coherence + delta_coherence).clamp(0.0, 1.0);

    // Update coherence_delta to reflect this change
    self.coherence_delta = (self.coherence - old_coherence).clamp(-1.0, 1.0);

    // Recompute suggested action
    self.suggested_action = Self::compute_action(self.entropy, self.coherence);

    // Update timestamp to now
    self.timestamp = Utc::now();
}
```

### 2. Add `blend()` Method

Insert after `update()` method:

```rust
/// Linearly interpolates between two pulses.
///
/// Creates a new pulse that is a blend of `self` and `other`.
/// The blend factor `t` determines the weight:
/// - t = 0.0 → result equals self
/// - t = 1.0 → result equals other
/// - t = 0.5 → result is midpoint
///
/// # Arguments
/// * `other` - The other pulse to blend with
/// * `t` - Blend factor clamped to [0.0, 1.0]
///
/// # Returns
/// A new CognitivePulse with interpolated values.
///
/// # Example
/// ```rust
/// use context_graph_core::types::CognitivePulse;
///
/// let pulse1 = CognitivePulse::from_values(0.2, 0.8);
/// let pulse2 = CognitivePulse::from_values(0.8, 0.2);
///
/// let blended = pulse1.blend(&pulse2, 0.5);
/// assert_eq!(blended.entropy, 0.5);  // (0.2 + 0.8) / 2
/// assert_eq!(blended.coherence, 0.5); // (0.8 + 0.2) / 2
/// ```
pub fn blend(&self, other: &CognitivePulse, t: f32) -> CognitivePulse {
    let t = t.clamp(0.0, 1.0);

    // Linear interpolation helper
    let lerp = |a: f32, b: f32| a + t * (b - a);

    // Interpolate numeric fields
    let entropy = lerp(self.entropy, other.entropy);
    let coherence = lerp(self.coherence, other.coherence);
    let coherence_delta = lerp(self.coherence_delta, other.coherence_delta);
    let emotional_weight = lerp(self.emotional_weight, other.emotional_weight);

    // For non-interpolatable fields, use threshold-based selection
    // t < 0.5 → use self, t >= 0.5 → use other
    let source_layer = if t < 0.5 {
        self.source_layer
    } else {
        other.source_layer
    };

    // Compute new action from blended values
    let suggested_action = Self::compute_action(entropy, coherence);

    CognitivePulse {
        entropy,
        coherence,
        coherence_delta,
        emotional_weight,
        suggested_action,
        source_layer,
        timestamp: Utc::now(),
    }
}
```

---

## Required Tests

Add these tests to the existing `#[cfg(test)] mod tests` block:

```rust
// =======================================================================
// CognitivePulse::update() Tests (TASK-M02-022)
// =======================================================================

#[test]
fn test_update_modifies_entropy_and_coherence() {
    let mut pulse = CognitivePulse::default();
    assert_eq!(pulse.entropy, 0.5);
    assert_eq!(pulse.coherence, 0.5);

    pulse.update(0.2, -0.1);

    assert_eq!(pulse.entropy, 0.7);
    assert_eq!(pulse.coherence, 0.4);
}

#[test]
fn test_update_clamps_values() {
    let mut pulse = CognitivePulse::default();

    // Try to exceed bounds
    pulse.update(1.0, 1.0);
    assert_eq!(pulse.entropy, 1.0);
    assert_eq!(pulse.coherence, 1.0);

    // Try to go below zero
    pulse.update(-2.0, -2.0);
    assert_eq!(pulse.entropy, 0.0);
    assert_eq!(pulse.coherence, 0.0);
}

#[test]
fn test_update_recomputes_action() {
    let mut pulse = CognitivePulse::from_values(0.5, 0.5);
    assert_eq!(pulse.suggested_action, SuggestedAction::Continue);

    // Push to high entropy, low coherence → Stabilize
    pulse.update(0.3, -0.2);
    assert_eq!(pulse.entropy, 0.8);
    assert_eq!(pulse.coherence, 0.3);
    assert_eq!(pulse.suggested_action, SuggestedAction::Stabilize);
}

#[test]
fn test_update_updates_coherence_delta() {
    let mut pulse = CognitivePulse::default();
    assert_eq!(pulse.coherence_delta, 0.0);

    pulse.update(0.0, 0.2);

    // coherence went from 0.5 to 0.7, so delta = 0.2
    assert!((pulse.coherence_delta - 0.2).abs() < 0.001);
}

#[test]
fn test_update_updates_timestamp() {
    let mut pulse = CognitivePulse::default();
    let original_timestamp = pulse.timestamp;

    std::thread::sleep(std::time::Duration::from_millis(10));
    pulse.update(0.1, 0.1);

    assert!(pulse.timestamp > original_timestamp);
}

// =======================================================================
// CognitivePulse::blend() Tests (TASK-M02-022)
// =======================================================================

#[test]
fn test_blend_at_zero_equals_self() {
    let pulse1 = CognitivePulse::from_values(0.2, 0.8);
    let pulse2 = CognitivePulse::from_values(0.8, 0.2);

    let blended = pulse1.blend(&pulse2, 0.0);

    assert_eq!(blended.entropy, 0.2);
    assert_eq!(blended.coherence, 0.8);
}

#[test]
fn test_blend_at_one_equals_other() {
    let pulse1 = CognitivePulse::from_values(0.2, 0.8);
    let pulse2 = CognitivePulse::from_values(0.8, 0.2);

    let blended = pulse1.blend(&pulse2, 1.0);

    assert_eq!(blended.entropy, 0.8);
    assert_eq!(blended.coherence, 0.2);
}

#[test]
fn test_blend_at_midpoint() {
    let pulse1 = CognitivePulse::from_values(0.2, 0.8);
    let pulse2 = CognitivePulse::from_values(0.8, 0.2);

    let blended = pulse1.blend(&pulse2, 0.5);

    assert_eq!(blended.entropy, 0.5);
    assert_eq!(blended.coherence, 0.5);
}

#[test]
fn test_blend_clamps_t() {
    let pulse1 = CognitivePulse::from_values(0.2, 0.8);
    let pulse2 = CognitivePulse::from_values(0.8, 0.2);

    // t > 1.0 should clamp to 1.0
    let blended = pulse1.blend(&pulse2, 2.0);
    assert_eq!(blended.entropy, 0.8);

    // t < 0.0 should clamp to 0.0
    let blended = pulse1.blend(&pulse2, -1.0);
    assert_eq!(blended.entropy, 0.2);
}

#[test]
fn test_blend_interpolates_all_numeric_fields() {
    let pulse1 = CognitivePulse::new(
        0.2, 0.8, 0.1, 1.0,
        SuggestedAction::Ready,
        Some(LayerId::Sensing),
    );
    let pulse2 = CognitivePulse::new(
        0.8, 0.2, -0.1, 1.4,
        SuggestedAction::Explore,
        Some(LayerId::Coherence),
    );

    let blended = pulse1.blend(&pulse2, 0.5);

    assert_eq!(blended.entropy, 0.5);
    assert_eq!(blended.coherence, 0.5);
    assert_eq!(blended.coherence_delta, 0.0);  // (0.1 + -0.1) / 2
    assert_eq!(blended.emotional_weight, 1.2); // (1.0 + 1.4) / 2
}

#[test]
fn test_blend_source_layer_threshold() {
    let pulse1 = CognitivePulse::new(
        0.5, 0.5, 0.0, 1.0,
        SuggestedAction::Continue,
        Some(LayerId::Sensing),
    );
    let pulse2 = CognitivePulse::new(
        0.5, 0.5, 0.0, 1.0,
        SuggestedAction::Continue,
        Some(LayerId::Coherence),
    );

    // t < 0.5 → use self's source_layer
    let blended = pulse1.blend(&pulse2, 0.49);
    assert_eq!(blended.source_layer, Some(LayerId::Sensing));

    // t >= 0.5 → use other's source_layer
    let blended = pulse1.blend(&pulse2, 0.5);
    assert_eq!(blended.source_layer, Some(LayerId::Coherence));
}

#[test]
fn test_blend_recomputes_action() {
    let pulse1 = CognitivePulse::from_values(0.2, 0.9);  // Ready
    let pulse2 = CognitivePulse::from_values(0.9, 0.2);  // Stabilize

    // Midpoint should compute a new action
    let blended = pulse1.blend(&pulse2, 0.5);

    // entropy=0.55, coherence=0.55 → should compute appropriate action
    // Not testing specific action, just that it computes something
    assert!(matches!(
        blended.suggested_action,
        SuggestedAction::Continue | SuggestedAction::Explore | SuggestedAction::Review
    ));
}

#[test]
fn test_blend_creates_new_timestamp() {
    let pulse1 = CognitivePulse::default();
    std::thread::sleep(std::time::Duration::from_millis(10));
    let pulse2 = CognitivePulse::default();
    std::thread::sleep(std::time::Duration::from_millis(10));

    let blended = pulse1.blend(&pulse2, 0.5);

    // Blended timestamp should be newest
    assert!(blended.timestamp >= pulse2.timestamp);
}
```

---

## Verification Commands

```bash
# 1. Build check
cargo build --package context-graph-core

# 2. Run all pulse tests (expect 35+ tests after adding new ones)
cargo test --package context-graph-core pulse -- --nocapture

# 3. Run specific new tests
cargo test --package context-graph-core test_update -- --nocapture
cargo test --package context-graph-core test_blend -- --nocapture

# 4. Clippy check (0 warnings required)
cargo clippy --package context-graph-core -- -D warnings

# 5. Format check
cargo fmt --package context-graph-core --check
```

---

## Full State Verification Protocol

### 1. Source of Truth
- **File**: `crates/context-graph-core/src/types/pulse.rs`
- **Compilation**: `cargo build` success
- **Tests**: `cargo test` output

### 2. Execute & Inspect

After implementation:
```bash
# Prove methods exist and compile
cargo build --package context-graph-core 2>&1 | grep -E "(error|warning|Compiling)"

# Count test results
cargo test --package context-graph-core pulse 2>&1 | grep -E "^test result"

# Verify method signatures exist
grep -n "pub fn update" crates/context-graph-core/src/types/pulse.rs
grep -n "pub fn blend" crates/context-graph-core/src/types/pulse.rs
```

### 3. Boundary & Edge Case Audit

**MANDATORY: Test these 3 edge cases with before/after state logging:**

**Edge Case 1: update() with extreme deltas**
```rust
#[test]
fn edge_case_update_extreme_deltas() {
    let mut pulse = CognitivePulse::from_values(0.5, 0.5);

    println!("BEFORE: entropy={}, coherence={}", pulse.entropy, pulse.coherence);

    pulse.update(100.0, -100.0);

    println!("AFTER: entropy={}, coherence={}", pulse.entropy, pulse.coherence);

    assert_eq!(pulse.entropy, 1.0, "Extreme positive delta should clamp to 1.0");
    assert_eq!(pulse.coherence, 0.0, "Extreme negative delta should clamp to 0.0");
}
```

**Edge Case 2: blend() with identical pulses**
```rust
#[test]
fn edge_case_blend_identical_pulses() {
    let pulse = CognitivePulse::from_values(0.6, 0.7);

    println!("ORIGINAL: entropy={}, coherence={}", pulse.entropy, pulse.coherence);

    let blended = pulse.blend(&pulse, 0.5);

    println!("BLENDED: entropy={}, coherence={}", blended.entropy, blended.coherence);

    assert_eq!(blended.entropy, pulse.entropy);
    assert_eq!(blended.coherence, pulse.coherence);
}
```

**Edge Case 3: update() action transition**
```rust
#[test]
fn edge_case_update_action_transition() {
    let mut pulse = CognitivePulse::from_values(0.35, 0.75);

    println!("STATE 1: entropy={}, coherence={}, action={:?}",
             pulse.entropy, pulse.coherence, pulse.suggested_action);

    // Low entropy + high coherence = Ready
    assert_eq!(pulse.suggested_action, SuggestedAction::Ready);

    pulse.update(0.5, -0.5);

    println!("STATE 2: entropy={}, coherence={}, action={:?}",
             pulse.entropy, pulse.coherence, pulse.suggested_action);

    // High entropy + low coherence = Stabilize
    assert_eq!(pulse.suggested_action, SuggestedAction::Stabilize);
}
```

### 4. Evidence of Success

Create this verification log after all tests pass:

```
=== TASK-M02-022 Verification Report ===
Date: [YYYY-MM-DD HH:MM:SS UTC]
Commit: [git hash]

1. BUILD: cargo build --package context-graph-core
   Result: [SUCCESS/FAIL]

2. TESTS: cargo test --package context-graph-core pulse
   Result: [X passed, Y failed]

3. CLIPPY: cargo clippy --package context-graph-core -- -D warnings
   Result: [0 warnings / X warnings]

4. METHOD VERIFICATION:
   - update() exists and compiles: [YES/NO]
   - blend() exists and compiles: [YES/NO]
   - update() modifies entropy: [PASS/FAIL]
   - update() modifies coherence: [PASS/FAIL]
   - update() clamps values: [PASS/FAIL]
   - update() recomputes action: [PASS/FAIL]
   - update() updates timestamp: [PASS/FAIL]
   - blend() at t=0 equals self: [PASS/FAIL]
   - blend() at t=1 equals other: [PASS/FAIL]
   - blend() interpolates correctly: [PASS/FAIL]

5. EDGE CASES:
   - Extreme deltas clamping: [PASS/FAIL]
   - Identical pulse blend: [PASS/FAIL]
   - Action transition: [PASS/FAIL]

=== TASK-M02-022 [COMPLETE/INCOMPLETE] ===
```

---

## Final Verification: Sherlock-Holmes Agent

**MANDATORY**: After completing implementation and tests, spawn the `sherlock-holmes` subagent:

```
Task(
  "Forensic verification of TASK-M02-022 CognitivePulse methods",
  "INVESTIGATE crates/context-graph-core/src/types/pulse.rs

   VERIFY THESE FACTS:
   1. Method update(&mut self, delta_entropy: f32, delta_coherence: f32) exists
   2. Method blend(&self, other: &CognitivePulse, t: f32) -> CognitivePulse exists
   3. update() clamps entropy to [0,1]
   4. update() clamps coherence to [0,1]
   5. update() recomputes suggested_action
   6. update() updates timestamp
   7. blend() clamps t to [0,1]
   8. blend() interpolates all numeric fields
   9. All tests pass: cargo test --package context-graph-core pulse
   10. No clippy warnings: cargo clippy --package context-graph-core -- -D warnings

   PROVE WITH EVIDENCE:
   - Show the actual method implementations
   - Run tests and show output
   - Show clippy output

   This code is GUILTY UNTIL PROVEN INNOCENT.",
  "sherlock-holmes"
)
```

Fix any issues Sherlock identifies before marking complete.

---

## NOT In Scope (Explicitly Excluded)

| Item | Reason |
|------|--------|
| Modifying existing `new()` | Already works correctly |
| Modifying existing `computed()` | Already works correctly |
| Adding `to_json()` | Serialize derive already handles this |
| Changing struct fields | Struct is complete |
| Backwards compatibility | NO - fail fast if broken |

---

## Anti-Patterns to AVOID (from constitution.yaml)

- **AP-001**: Do NOT use `unwrap()` - use `expect()` with context
- **AP-009**: Do NOT allow NaN/Infinity - clamp to valid range
- **AP-007**: Do NOT use stub/mock data in tests - test real behavior
- **NO BACKWARDS COMPATIBILITY**: If something breaks, error with clear message

---

## Call Sites That Use CognitivePulse::new()

These files call `CognitivePulse::new()` and may need updates if signature changes (but we're NOT changing the signature):

| File | Usage |
|------|-------|
| `crates/context-graph-core/src/stubs/layers.rs` | 5 call sites in stub layers |
| `crates/context-graph-core/tests/edge_case_tests.rs` | 1 call site in edge case test |

**No changes needed** - the existing signature is:
```rust
pub fn new(
    entropy: f32,
    coherence: f32,
    coherence_delta: f32,
    emotional_weight: f32,
    suggested_action: SuggestedAction,
    source_layer: Option<LayerId>,
) -> Self
```

---

## Manual Output Verification

After implementing, **YOU MUST** manually verify outputs exist:

### Trigger Event: Calling `update()`
**Expected Output**: Modified pulse with new values

```rust
let mut pulse = CognitivePulse::from_values(0.5, 0.5);
pulse.update(0.2, -0.1);

// VERIFY: Read back the values and print them
println!("VERIFICATION - update() output:");
println!("  entropy: {} (expected: 0.7)", pulse.entropy);
println!("  coherence: {} (expected: 0.4)", pulse.coherence);
println!("  action: {:?}", pulse.suggested_action);
```

### Trigger Event: Calling `blend()`
**Expected Output**: New pulse with interpolated values

```rust
let pulse1 = CognitivePulse::from_values(0.2, 0.8);
let pulse2 = CognitivePulse::from_values(0.8, 0.2);
let result = pulse1.blend(&pulse2, 0.5);

// VERIFY: Check the blended values
println!("VERIFICATION - blend() output:");
println!("  entropy: {} (expected: 0.5)", result.entropy);
println!("  coherence: {} (expected: 0.5)", result.coherence);
```

---

*Task ID: TASK-M02-022*
*Module: 02 - Core Infrastructure*
*Layer: Surface*
*Last Updated: 2025-12-31*
*Audited Against: Commit fa0ebf2, pulse.rs with 7-field struct*
