# TASK-M02-016: Implement RocksDB Backend Open/Close

```xml
<task_spec id="TASK-M02-016" version="1.0">
<metadata>
  <title>Implement RocksDB Backend Open/Close</title>
  <status>blocked</status>
  <layer>logic</layer>
  <module>module-02</module>
  <sequence>16</sequence>
  <priority>critical</priority>
  <estimated_hours>3</estimated_hours>
  <implements>
    <item>TECH-CORE-002 Section 3.2: RocksDB backend specification</item>
  </implements>
  <depends_on>
    <task_ref>TASK-M02-014</task_ref>
    <task_ref>TASK-M02-015</task_ref>
  </depends_on>
  <estimated_complexity>medium</estimated_complexity>
</metadata>

<context>
This task implements the RocksDbMemex struct which provides the core RocksDB database connection management. It handles database opening with all 12 column families, configures the shared block cache, sets up WAL, and ensures proper resource cleanup on drop. This is the foundation for all storage operations.
</context>

<input_context_files>
  <file purpose="Column family definitions">crates/context-graph-storage/src/column_families.rs</file>
  <file purpose="Constitution reference for DB config">docs2/constitution.yaml</file>
</input_context_files>

<prerequisites>
  <check>TASK-M02-014 (Serialization) is complete</check>
  <check>TASK-M02-015 (Column families) is complete</check>
</prerequisites>

<scope>
  <in_scope>
    - RocksDbMemex struct definition
    - RocksDbMemex::open() method
    - RocksDbMemex::open_with_options() method for custom configuration
    - Proper Drop implementation for cleanup
    - get_cf() helper for column family access
    - Database path management
    - Unit tests with tempdir
  </in_scope>
  <out_of_scope>
    - CRUD operations (handled in TASK-M02-017, TASK-M02-018)
    - Memex trait implementation (handled in TASK-M02-026)
  </out_of_scope>
</scope>

<definition_of_done>
  <signatures>
    <signature file="crates/context-graph-storage/src/rocksdb_backend.rs">
use rocksdb::{DB, Cache, ColumnFamily, Options};
use std::path::Path;
use std::sync::Arc;
use tokio::sync::RwLock;

use crate::column_families::{cf_names, get_column_family_descriptors};

/// Configuration options for RocksDbMemex.
#[derive(Debug, Clone)]
pub struct RocksDbConfig {
    /// Maximum open files (default: 1000).
    pub max_open_files: i32,
    /// Block cache size in bytes (default: 256MB).
    pub block_cache_size: usize,
    /// Enable WAL (default: true).
    pub enable_wal: bool,
    /// Create database if missing (default: true).
    pub create_if_missing: bool,
}

impl Default for RocksDbConfig {
    fn default() -> Self;
}

/// RocksDB-backed storage implementation.
///
/// Provides persistent storage for MemoryNodes and GraphEdges with
/// optimized column families for different access patterns.
///
/// # Thread Safety
/// This struct is safe to share across threads via Arc.
/// Uses RwLock for interior mutability where needed.
pub struct RocksDbMemex {
    /// The RocksDB database instance.
    db: DB,
    /// Shared block cache.
    cache: Cache,
    /// Database path for reference.
    path: String,
}

impl RocksDbMemex {
    /// Open a RocksDB database at the specified path with default configuration.
    ///
    /// Creates the database and all column families if they don't exist.
    ///
    /// # Arguments
    /// * `path` - Path to the database directory
    ///
    /// # Errors
    /// Returns error if database cannot be opened or created.
    pub fn open&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -> Result&lt;Self, StorageError&gt;;

    /// Open a RocksDB database with custom configuration.
    pub fn open_with_config&lt;P: AsRef&lt;Path&gt;&gt;(
        path: P,
        config: RocksDbConfig,
    ) -> Result&lt;Self, StorageError&gt;;

    /// Get a reference to a column family by name.
    ///
    /// # Panics
    /// Panics if the column family doesn't exist (should never happen).
    pub fn get_cf(&amp;self, name: &amp;str) -> &amp;ColumnFamily;

    /// Get the database path.
    pub fn path(&amp;self) -> &amp;str;

    /// Check if the database is healthy.
    pub fn health_check(&amp;self) -> Result&lt;(), StorageError&gt;;

    /// Flush all column families to disk.
    pub fn flush_all(&amp;self) -> Result&lt;(), StorageError&gt;;
}

// DB is closed automatically when RocksDbMemex is dropped
</signature>
  </signatures>

  <constraints>
    - create_if_missing must be true by default
    - max_open_files default is 1000
    - Block cache default is 256MB (268,435,456 bytes)
    - WAL must be enabled by default for durability
    - All 12 column families must be created/opened
    - Database must close cleanly on drop
    - Thread-safe access to column families
  </constraints>

  <verification>
    - cargo build --package context-graph-storage compiles without errors
    - cargo test --package context-graph-storage rocksdb passes all tests
    - Database opens and closes without leaks
  </verification>
</definition_of_done>

<pseudo_code>
rocksdb_backend.rs:
  use rocksdb::{DB, Cache, ColumnFamily, Options, DBCompressionType};
  use std::path::Path;

  use crate::column_families::{cf_names, get_column_family_descriptors};
  use crate::StorageError;

  const DEFAULT_CACHE_SIZE: usize = 256 * 1024 * 1024;  // 256MB
  const DEFAULT_MAX_OPEN_FILES: i32 = 1000;

  #[derive(Debug, Clone)]
  pub struct RocksDbConfig {
    pub max_open_files: i32,
    pub block_cache_size: usize,
    pub enable_wal: bool,
    pub create_if_missing: bool,
  }

  impl Default for RocksDbConfig {
    fn default() -> Self {
      Self {
        max_open_files: DEFAULT_MAX_OPEN_FILES,
        block_cache_size: DEFAULT_CACHE_SIZE,
        enable_wal: true,
        create_if_missing: true,
      }
    }
  }

  pub struct RocksDbMemex {
    db: DB,
    cache: Cache,
    path: String,
  }

  impl RocksDbMemex {
    pub fn open&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -> Result&lt;Self, StorageError&gt; {
      Self::open_with_config(path, RocksDbConfig::default())
    }

    pub fn open_with_config&lt;P: AsRef&lt;Path&gt;&gt;(path: P, config: RocksDbConfig) -> Result&lt;Self, StorageError&gt; {
      let path_str = path.as_ref().to_string_lossy().to_string();

      // Create shared cache
      let cache = Cache::new_lru_cache(config.block_cache_size);

      // Create DB options
      let mut db_opts = Options::default();
      db_opts.create_if_missing(config.create_if_missing);
      db_opts.create_missing_column_families(true);
      db_opts.set_max_open_files(config.max_open_files);

      if !config.enable_wal {
        db_opts.set_wal_dir("");  // Disable WAL
      }

      // Get column family descriptors
      let cf_descriptors = get_column_family_descriptors(&amp;cache);

      // Open database with column families
      let db = DB::open_cf_descriptors(&amp;db_opts, &amp;path_str, cf_descriptors)
        .map_err(|e| StorageError::OpenFailed(e.to_string()))?;

      Ok(Self { db, cache, path: path_str })
    }

    pub fn get_cf(&amp;self, name: &amp;str) -> &amp;ColumnFamily {
      self.db.cf_handle(name)
        .expect(&amp;format!("Column family '{}' not found", name))
    }

    pub fn path(&amp;self) -> &amp;str {
      &amp;self.path
    }

    pub fn health_check(&amp;self) -> Result&lt;(), StorageError&gt; {
      // Try to get stats from each CF
      for cf_name in cf_names::ALL {
        let _cf = self.get_cf(cf_name);
      }
      Ok(())
    }

    pub fn flush_all(&amp;self) -> Result&lt;(), StorageError&gt; {
      for cf_name in cf_names::ALL {
        let cf = self.get_cf(cf_name);
        self.db.flush_cf(cf)
          .map_err(|e| StorageError::WriteFailed(e.to_string()))?;
      }
      Ok(())
    }
  }

  // DB is automatically closed when dropped (RocksDB Drop impl)

#[cfg(test)]
mod tests:
  use tempfile::TempDir;

  test_open_creates_database()
  test_open_with_custom_config()
  test_get_cf_returns_valid_handle()
  test_health_check_passes()
  test_flush_all_succeeds()
  test_reopen_preserves_data()
</pseudo_code>

<files_to_create>
  <!-- File already exists as placeholder -->
</files_to_create>

<files_to_modify>
  <file path="crates/context-graph-storage/src/rocksdb_backend.rs">Implement RocksDbMemex open/close</file>
  <file path="crates/context-graph-storage/src/lib.rs">Re-export RocksDbMemex, RocksDbConfig</file>
</files_to_modify>

<validation_criteria>
  <criterion>open() creates DB with all 12 column families</criterion>
  <criterion>Missing CFs are created automatically</criterion>
  <criterion>WAL directory is configured by default</criterion>
  <criterion>Block cache is shared across CFs (256MB default)</criterion>
  <criterion>Bloom filter enabled for nodes CF</criterion>
  <criterion>Database closes cleanly on drop</criterion>
  <criterion>Reopening existing database preserves data</criterion>
  <criterion>health_check() verifies all CFs accessible</criterion>
</validation_criteria>

<test_commands>
  <command>cargo build --package context-graph-storage</command>
  <command>cargo test --package context-graph-storage rocksdb -- --nocapture</command>
</test_commands>
</task_spec>
```

## Implementation Notes

### Constitution Reference
From constitution.yaml:
```yaml
rules:
  - "Lock order: inner → faiss_index (prevents deadlock)"
```

For RocksDB, the lock order would be: db_lock → cf operations

### Default Configuration
| Setting | Default | Rationale |
|---------|---------|-----------|
| max_open_files | 1000 | Balance between memory and file handles |
| block_cache_size | 256MB | As specified in constitution |
| enable_wal | true | Durability by default |
| create_if_missing | true | Convenience for new installations |

### Thread Safety
RocksDB's DB type is thread-safe for concurrent reads and writes. The RocksDbMemex struct can be shared across threads via Arc without additional synchronization.

---

*Task ID: TASK-M02-016*
*Module: 02 - Core Infrastructure*
*Layer: Logic*
