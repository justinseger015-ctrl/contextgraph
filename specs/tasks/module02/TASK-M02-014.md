# TASK-M02-014: Implement Bincode Serialization

## Task Metadata
| Field | Value |
|-------|-------|
| **ID** | TASK-M02-014 |
| **Status** | ready |
| **Layer** | logic |
| **Module** | module-02 |
| **Priority** | critical |
| **Depends On** | TASK-M02-013 (VERIFIED COMPLETE) |
| **Estimated Hours** | 2.5 |

## Prerequisite Verification

**BEFORE STARTING, VERIFY:**
```bash
# 1. Storage crate exists and builds
cargo build --package context-graph-storage
# Expected: Compiles successfully

# 2. Placeholder file exists
ls -la crates/context-graph-storage/src/serialization.rs
# Expected: File exists (currently has TODO comments)

# 3. Core types are accessible
grep -l "MemoryNode\|GraphEdge" crates/context-graph-core/src/types/*.rs
# Expected: memory_node.rs, graph_edge.rs
```

## Context

This task implements bincode serialization for persistent storage of `MemoryNode`, `GraphEdge`, and `EmbeddingVector` types. Bincode is chosen for:
- Compact binary format (smaller than JSON)
- High performance (<100Î¼s serialization target)
- Native Rust type support via serde

**CRITICAL**: All types already have `#[derive(Serialize, Deserialize)]` - you are adding wrapper functions, NOT modifying the types.

## Exact File Paths (VERIFIED 2025-12-31)

### Files to READ (do NOT modify):
| File | Purpose | Key Exports |
|------|---------|-------------|
| `crates/context-graph-core/src/types/memory_node.rs` | MemoryNode struct | `MemoryNode`, `NodeMetadata`, `NodeId`, `EmbeddingVector`, `DEFAULT_EMBEDDING_DIM` |
| `crates/context-graph-core/src/types/graph_edge.rs` | GraphEdge struct | `GraphEdge`, `EdgeId` |
| `crates/context-graph-core/src/marblestone.rs` | Marblestone types | `Domain`, `EdgeType`, `NeurotransmitterWeights` |
| `crates/context-graph-storage/src/lib.rs` | Storage crate root | Re-exports from `context_graph_core` |

### File to MODIFY:
| File | Action |
|------|--------|
| `crates/context-graph-storage/src/serialization.rs` | Replace TODO placeholder with implementation |
| `crates/context-graph-storage/src/lib.rs` | Add re-exports for serialization types |

## Current Codebase State (VERIFIED)

### MemoryNode Fields (10 fields):
```rust
pub struct MemoryNode {
    pub id: NodeId,                        // Uuid
    pub content: String,                   // max 1MB
    pub embedding: EmbeddingVector,        // Vec<f32>, 1536 dim default
    pub quadrant: JohariQuadrant,
    pub importance: f32,                   // [0.0, 1.0]
    pub emotional_valence: f32,            // [-1.0, 1.0]
    pub created_at: DateTime<Utc>,
    pub accessed_at: DateTime<Utc>,
    pub access_count: u64,
    pub metadata: NodeMetadata,
}
```

### GraphEdge Fields (13 fields - Marblestone):
```rust
pub struct GraphEdge {
    pub id: EdgeId,                                    // Uuid
    pub source_id: NodeId,                             // Uuid
    pub target_id: NodeId,                             // Uuid
    pub edge_type: EdgeType,                           // Semantic|Temporal|Causal|Hierarchical
    pub weight: f32,                                   // [0.0, 1.0]
    pub confidence: f32,                               // [0.0, 1.0]
    pub domain: Domain,                                // Code|Legal|Medical|Creative|Research|General
    pub neurotransmitter_weights: NeurotransmitterWeights,
    pub is_amortized_shortcut: bool,
    pub steering_reward: f32,                          // [-1.0, 1.0]
    pub traversal_count: u64,
    pub created_at: DateTime<Utc>,
    pub last_traversed_at: Option<DateTime<Utc>>,
}
```

### EmbeddingVector Type:
```rust
pub type EmbeddingVector = Vec<f32>;
pub const DEFAULT_EMBEDDING_DIM: usize = 1536;
```

## Implementation Requirements

### 1. SerializationError Enum
```rust
use thiserror::Error;

#[derive(Debug, Error, Clone, PartialEq)]
pub enum SerializationError {
    #[error("Serialization failed: {0}")]
    SerializeFailed(String),

    #[error("Deserialization failed: {0}")]
    DeserializeFailed(String),

    #[error("Invalid embedding size: expected {expected} bytes, got {actual}")]
    InvalidEmbeddingSize { expected: usize, actual: usize },

    #[error("Invalid UUID bytes: expected 16 bytes, got {actual}")]
    InvalidUuidSize { actual: usize },
}
```

**NOTE**: bincode::Error does not implement Clone, so store the error message as String.

### 2. Required Functions (8 total)

```rust
/// Serialize a MemoryNode to bincode bytes.
/// Returns ~6.5KB for node with 1536D embedding.
pub fn serialize_node(node: &MemoryNode) -> Result<Vec<u8>, SerializationError>;

/// Deserialize bincode bytes to MemoryNode.
pub fn deserialize_node(bytes: &[u8]) -> Result<MemoryNode, SerializationError>;

/// Serialize a GraphEdge to bincode bytes.
/// Returns ~200 bytes.
pub fn serialize_edge(edge: &GraphEdge) -> Result<Vec<u8>, SerializationError>;

/// Deserialize bincode bytes to GraphEdge.
pub fn deserialize_edge(bytes: &[u8]) -> Result<GraphEdge, SerializationError>;

/// Serialize embedding to raw f32 bytes (little-endian).
/// Returns dim * 4 bytes (6144 bytes for 1536D).
/// Infallible - no Result wrapper.
pub fn serialize_embedding(embedding: &EmbeddingVector) -> Vec<u8>;

/// Deserialize raw f32 bytes to embedding vector.
/// bytes.len() must be divisible by 4.
pub fn deserialize_embedding(bytes: &[u8]) -> Result<EmbeddingVector, SerializationError>;

/// Serialize UUID to exactly 16 bytes.
pub fn serialize_uuid(id: &uuid::Uuid) -> [u8; 16];

/// Deserialize 16 bytes to UUID.
pub fn deserialize_uuid(bytes: &[u8; 16]) -> uuid::Uuid;
```

### 3. Implementation Details

**For bincode serialization (node/edge):**
```rust
pub fn serialize_node(node: &MemoryNode) -> Result<Vec<u8>, SerializationError> {
    bincode::serialize(node)
        .map_err(|e| SerializationError::SerializeFailed(e.to_string()))
}

pub fn deserialize_node(bytes: &[u8]) -> Result<MemoryNode, SerializationError> {
    bincode::deserialize(bytes)
        .map_err(|e| SerializationError::DeserializeFailed(e.to_string()))
}
```

**For embedding serialization (raw bytes, NOT bincode):**
```rust
pub fn serialize_embedding(embedding: &EmbeddingVector) -> Vec<u8> {
    let mut bytes = Vec::with_capacity(embedding.len() * 4);
    for &value in embedding {
        bytes.extend_from_slice(&value.to_le_bytes());
    }
    bytes
}

pub fn deserialize_embedding(bytes: &[u8]) -> Result<EmbeddingVector, SerializationError> {
    if bytes.len() % 4 != 0 {
        return Err(SerializationError::InvalidEmbeddingSize {
            expected: ((bytes.len() / 4) + 1) * 4,
            actual: bytes.len(),
        });
    }
    let mut embedding = Vec::with_capacity(bytes.len() / 4);
    for chunk in bytes.chunks_exact(4) {
        let arr: [u8; 4] = chunk.try_into().expect("chunk is exactly 4 bytes");
        embedding.push(f32::from_le_bytes(arr));
    }
    Ok(embedding)
}
```

**For UUID serialization:**
```rust
pub fn serialize_uuid(id: &uuid::Uuid) -> [u8; 16] {
    *id.as_bytes()
}

pub fn deserialize_uuid(bytes: &[u8; 16]) -> uuid::Uuid {
    uuid::Uuid::from_bytes(*bytes)
}
```

### 4. Update lib.rs Re-exports

Add to `crates/context-graph-storage/src/lib.rs`:
```rust
pub use serialization::{
    SerializationError,
    serialize_node, deserialize_node,
    serialize_edge, deserialize_edge,
    serialize_embedding, deserialize_embedding,
    serialize_uuid, deserialize_uuid,
};
```

## Required Tests (Use REAL Data, No Mocks)

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use chrono::Utc;
    use uuid::Uuid;

    // Helper: Create a valid normalized embedding
    fn create_normalized_embedding(dim: usize) -> EmbeddingVector {
        let val = 1.0 / (dim as f32).sqrt();
        vec![val; dim]
    }

    // Helper: Create a valid MemoryNode
    fn create_test_node() -> MemoryNode {
        use context_graph_core::types::{MemoryNode, JohariQuadrant, NodeMetadata, Modality};

        let embedding = create_normalized_embedding(1536);
        let mut node = MemoryNode::new("Test content".to_string(), embedding);
        node.importance = 0.75;
        node.emotional_valence = 0.5;
        node.quadrant = JohariQuadrant::Open;
        node.metadata = NodeMetadata::new()
            .with_source("test-source")
            .with_language("en");
        node
    }

    // Helper: Create a valid GraphEdge
    fn create_test_edge() -> GraphEdge {
        use context_graph_core::marblestone::{Domain, EdgeType};

        GraphEdge::new(
            Uuid::new_v4(),
            Uuid::new_v4(),
            EdgeType::Semantic,
            Domain::Code,
        )
    }

    #[test]
    fn test_node_roundtrip() {
        let node = create_test_node();
        let bytes = serialize_node(&node).expect("serialize failed");
        let restored = deserialize_node(&bytes).expect("deserialize failed");
        assert_eq!(node, restored, "Round-trip must preserve all fields");
    }

    #[test]
    fn test_node_size_reasonable() {
        let node = create_test_node();
        let bytes = serialize_node(&node).unwrap();
        // 1536 * 4 = 6144 bytes for embedding alone
        // Total should be ~6.5KB with other fields
        assert!(bytes.len() > 6000, "Node should be at least 6KB");
        assert!(bytes.len() < 8000, "Node should be less than 8KB");
    }

    #[test]
    fn test_edge_roundtrip() {
        let edge = create_test_edge();
        let bytes = serialize_edge(&edge).expect("serialize failed");
        let restored = deserialize_edge(&bytes).expect("deserialize failed");
        assert_eq!(edge, restored, "Round-trip must preserve all fields");
    }

    #[test]
    fn test_edge_size_reasonable() {
        let edge = create_test_edge();
        let bytes = serialize_edge(&edge).unwrap();
        assert!(bytes.len() > 100, "Edge should be at least 100 bytes");
        assert!(bytes.len() < 500, "Edge should be less than 500 bytes");
    }

    #[test]
    fn test_embedding_roundtrip() {
        let embedding = create_normalized_embedding(1536);
        let bytes = serialize_embedding(&embedding);
        let restored = deserialize_embedding(&bytes).expect("deserialize failed");

        assert_eq!(embedding.len(), restored.len());
        for (orig, rest) in embedding.iter().zip(restored.iter()) {
            assert_eq!(*orig, *rest, "f32 values must be exactly preserved");
        }
    }

    #[test]
    fn test_embedding_size_exact() {
        let embedding = vec![0.5_f32; 1536];
        let bytes = serialize_embedding(&embedding);
        assert_eq!(bytes.len(), 1536 * 4, "Embedding should be dim * 4 bytes");
    }

    #[test]
    fn test_embedding_invalid_size() {
        let bytes = vec![0u8; 13]; // Not divisible by 4
        let result = deserialize_embedding(&bytes);
        assert!(matches!(result, Err(SerializationError::InvalidEmbeddingSize { .. })));
    }

    #[test]
    fn test_embedding_empty() {
        let embedding: EmbeddingVector = vec![];
        let bytes = serialize_embedding(&embedding);
        assert!(bytes.is_empty());
        let restored = deserialize_embedding(&bytes).unwrap();
        assert!(restored.is_empty());
    }

    #[test]
    fn test_uuid_roundtrip() {
        let id = Uuid::new_v4();
        let bytes = serialize_uuid(&id);
        assert_eq!(bytes.len(), 16);
        let restored = deserialize_uuid(&bytes);
        assert_eq!(id, restored);
    }

    #[test]
    fn test_uuid_nil() {
        let nil = Uuid::nil();
        let bytes = serialize_uuid(&nil);
        let restored = deserialize_uuid(&bytes);
        assert_eq!(nil, restored);
    }

    #[test]
    fn test_node_with_all_metadata() {
        use serde_json::json;

        let mut node = create_test_node();
        node.metadata.add_tag("important");
        node.metadata.add_tag("verified");
        node.metadata.set_custom("priority", json!(5));
        node.metadata.mark_consolidated();
        node.metadata.rationale = Some("Testing serialization".to_string());

        let bytes = serialize_node(&node).unwrap();
        let restored = deserialize_node(&bytes).unwrap();

        assert_eq!(node.metadata.tags, restored.metadata.tags);
        assert_eq!(node.metadata.get_custom("priority"), restored.metadata.get_custom("priority"));
        assert!(restored.metadata.consolidated);
        assert_eq!(node.metadata.rationale, restored.metadata.rationale);
    }

    #[test]
    fn test_edge_with_all_marblestone_fields() {
        use context_graph_core::marblestone::{Domain, EdgeType, NeurotransmitterWeights};

        let mut edge = create_test_edge();
        edge.is_amortized_shortcut = true;
        edge.steering_reward = 0.75;
        edge.traversal_count = 42;
        edge.confidence = 0.9;
        edge.neurotransmitter_weights = NeurotransmitterWeights::for_domain(Domain::Medical);
        edge.record_traversal();

        let bytes = serialize_edge(&edge).unwrap();
        let restored = deserialize_edge(&bytes).unwrap();

        assert_eq!(edge.is_amortized_shortcut, restored.is_amortized_shortcut);
        assert_eq!(edge.steering_reward, restored.steering_reward);
        assert_eq!(edge.traversal_count, restored.traversal_count);
        assert_eq!(edge.neurotransmitter_weights, restored.neurotransmitter_weights);
        assert!(restored.last_traversed_at.is_some());
    }

    #[test]
    fn test_deserialization_invalid_bytes() {
        let garbage = vec![0xFF, 0x00, 0xAB, 0xCD];
        let node_result = deserialize_node(&garbage);
        assert!(node_result.is_err());

        let edge_result = deserialize_edge(&garbage);
        assert!(edge_result.is_err());
    }

    #[test]
    fn test_deserialization_empty_bytes() {
        let empty: Vec<u8> = vec![];
        let node_result = deserialize_node(&empty);
        assert!(node_result.is_err());

        let edge_result = deserialize_edge(&empty);
        assert!(edge_result.is_err());
    }
}
```

## Edge Case Tests (REQUIRED)

You MUST test these edge cases with printed before/after state:

### Edge Case 1: Empty Content
```rust
#[test]
fn edge_case_empty_content() {
    let mut node = create_test_node();
    node.content = String::new();

    println!("BEFORE: content.len() = {}", node.content.len());
    let bytes = serialize_node(&node).unwrap();
    let restored = deserialize_node(&bytes).unwrap();
    println!("AFTER: content.len() = {}", restored.content.len());

    assert_eq!(node.content, restored.content);
}
```

### Edge Case 2: Maximum Content Size
```rust
#[test]
fn edge_case_max_content() {
    use context_graph_core::types::MAX_CONTENT_SIZE;

    let mut node = create_test_node();
    node.content = "x".repeat(MAX_CONTENT_SIZE);

    println!("BEFORE: content.len() = {}", node.content.len());
    let bytes = serialize_node(&node).unwrap();
    println!("SERIALIZED: bytes.len() = {}", bytes.len());
    let restored = deserialize_node(&bytes).unwrap();
    println!("AFTER: content.len() = {}", restored.content.len());

    assert_eq!(node.content.len(), restored.content.len());
}
```

### Edge Case 3: Extreme Float Values
```rust
#[test]
fn edge_case_extreme_floats() {
    let extremes = vec![
        f32::MIN_POSITIVE,
        f32::MAX,
        f32::MIN,
        1e-38_f32,
        1e38_f32,
        0.0_f32,
        -0.0_f32,
    ];

    let bytes = serialize_embedding(&extremes);
    println!("BEFORE: {:?}", extremes);
    let restored = deserialize_embedding(&bytes).unwrap();
    println!("AFTER: {:?}", restored);

    for (i, (orig, rest)) in extremes.iter().zip(restored.iter()).enumerate() {
        assert_eq!(orig.to_bits(), rest.to_bits(), "Value {} differs", i);
    }
}
```

## Verification Commands

```bash
# Build the storage crate
cargo build --package context-graph-storage

# Run serialization tests with output
cargo test --package context-graph-storage serialization -- --nocapture

# Verify no clippy warnings
cargo clippy --package context-graph-storage -- -D warnings

# Check that all re-exports resolve
cargo doc --package context-graph-storage --no-deps
```

## Source of Truth Verification

After implementing, verify the serialization module is correctly integrated:

```bash
# 1. Verify re-exports work from lib.rs
cargo check --package context-graph-storage 2>&1 | grep -i "error"
# Expected: No output (no errors)

# 2. Test round-trip with actual data
cargo test --package context-graph-storage test_node_roundtrip -- --nocapture

# 3. Verify error types are accessible
grep "SerializationError" crates/context-graph-storage/src/lib.rs
# Expected: Shows re-export line
```

## Full State Verification Protocol

After completing implementation, you MUST:

1. **Identify Source of Truth**: The serialized bytes and deserialized structs
2. **Execute & Inspect**: Run each round-trip test and verify byte counts
3. **Edge Case Audit**: Run all 3 edge cases with printed output
4. **Evidence of Success**: Capture test output showing all assertions pass

### Required Evidence Log
```
============ SERIALIZATION VERIFICATION ============
Node Round-Trip: PASS (6547 bytes)
Edge Round-Trip: PASS (234 bytes)
Embedding Round-Trip: PASS (6144 bytes)
UUID Round-Trip: PASS (16 bytes)

Edge Case 1 (Empty Content): PASS
Edge Case 2 (Max Content): PASS
Edge Case 3 (Extreme Floats): PASS

Total Tests: 15/15 PASS
Clippy Warnings: 0
================================================
```

## Definition of Done

- [ ] `SerializationError` enum implemented with all 4 variants
- [ ] All 8 functions implemented and documented
- [ ] `lib.rs` re-exports added
- [ ] `cargo build --package context-graph-storage` succeeds
- [ ] All 15+ tests pass with `--nocapture`
- [ ] 0 clippy warnings
- [ ] 3 edge cases tested with printed before/after state
- [ ] Full verification log captured

## FINAL VERIFICATION STEP

**YOU MUST** invoke the `sherlock-holmes` subagent to verify task completion:

```
Task: Verify TASK-M02-014 implementation is complete and correct.

Checklist:
1. All 8 functions exist in serialization.rs
2. SerializationError enum has 4 variants
3. lib.rs re-exports all public items
4. All tests pass
5. No clippy warnings
6. Edge cases verified with output
7. Round-trip serialization preserves ALL fields for both MemoryNode and GraphEdge
```

The sherlock-holmes agent will audit the implementation and identify any issues that must be fixed before marking this task complete.

---
*Task ID: TASK-M02-014*
*Module: 02 - Core Infrastructure*
*Layer: Logic*
*Last Updated: 2025-12-31*
*Audited Against: Codebase commit 6132f93*
