# TASK-M02-014: Implement Bincode Serialization

```xml
<task_spec id="TASK-M02-014" version="1.0">
<metadata>
  <title>Implement Bincode Serialization</title>
  <status>blocked</status>
  <layer>logic</layer>
  <module>module-02</module>
  <sequence>14</sequence>
  <priority>critical</priority>
  <estimated_hours>2.5</estimated_hours>
  <implements>
    <item>TECH-CORE-002 Section 3: Serialization specification</item>
  </implements>
  <depends_on>
    <task_ref>TASK-M02-013</task_ref>
  </depends_on>
  <estimated_complexity>medium</estimated_complexity>
</metadata>

<context>
This task implements the serialization module providing efficient binary serialization for all storage types using bincode. The module provides serialize/deserialize functions for MemoryNode, GraphEdge, and embedding vectors. Bincode is chosen for its compact binary format and high performance, essential for meeting the latency targets.
</context>

<input_context_files>
  <file purpose="Storage crate structure">crates/context-graph-storage/src/lib.rs</file>
  <file purpose="MemoryNode definition">crates/context-graph-core/src/memory_node.rs</file>
  <file purpose="GraphEdge definition">crates/context-graph-core/src/marblestone.rs</file>
</input_context_files>

<prerequisites>
  <check>TASK-M02-013 (Storage crate structure) is complete</check>
  <check>serialization.rs placeholder exists</check>
</prerequisites>

<scope>
  <in_scope>
    - SerializationError type (or use StorageError)
    - serialize_node() function
    - deserialize_node() function
    - serialize_edge() function
    - deserialize_edge() function
    - serialize_embedding() function
    - deserialize_embedding() function
    - Unit tests for round-trip serialization
  </in_scope>
  <out_of_scope>
    - Custom serialization formats (use bincode defaults)
    - Compression (handled at column family level)
  </out_of_scope>
</scope>

<definition_of_done>
  <signatures>
    <signature file="crates/context-graph-storage/src/serialization.rs">
use bincode::{deserialize, serialize};
use thiserror::Error;

use crate::{EmbeddingVector, GraphEdge, MemoryNode};

/// Errors that can occur during serialization/deserialization.
#[derive(Debug, Error)]
pub enum SerializationError {
    #[error("Serialization failed: {0}")]
    SerializeFailed(#[from] bincode::Error),

    #[error("Deserialization failed: {0}")]
    DeserializeFailed(String),

    #[error("Invalid embedding data: expected {expected} bytes, got {actual}")]
    InvalidEmbeddingSize { expected: usize, actual: usize },
}

/// Serialize a MemoryNode to bytes.
///
/// Uses bincode for compact binary serialization.
/// Average output size: ~6.5KB for a node with 1536D embedding.
pub fn serialize_node(node: &amp;MemoryNode) -> Result&lt;Vec&lt;u8&gt;, SerializationError&gt;;

/// Deserialize bytes to a MemoryNode.
pub fn deserialize_node(bytes: &amp;[u8]) -> Result&lt;MemoryNode, SerializationError&gt;;

/// Serialize a GraphEdge to bytes.
///
/// Average output size: ~200 bytes.
pub fn serialize_edge(edge: &amp;GraphEdge) -> Result&lt;Vec&lt;u8&gt;, SerializationError&gt;;

/// Deserialize bytes to a GraphEdge.
pub fn deserialize_edge(bytes: &amp;[u8]) -> Result&lt;GraphEdge, SerializationError&gt;;

/// Serialize an embedding vector to bytes.
///
/// Uses raw f32 bytes for efficiency (no bincode overhead).
/// Output size: dim * 4 bytes (6144 bytes for 1536D).
pub fn serialize_embedding(embedding: &amp;EmbeddingVector) -> Vec&lt;u8&gt;;

/// Deserialize bytes to an embedding vector.
///
/// Expects raw f32 bytes.
pub fn deserialize_embedding(bytes: &amp;[u8]) -> Result&lt;EmbeddingVector, SerializationError&gt;;

/// Serialize a UUID to 16 bytes.
pub fn serialize_uuid(id: &amp;uuid::Uuid) -> [u8; 16];

/// Deserialize 16 bytes to a UUID.
pub fn deserialize_uuid(bytes: &amp;[u8; 16]) -> uuid::Uuid;
    </signature>
  </signatures>

  <constraints>
    - Use bincode with default config for nodes and edges
    - Use raw f32 bytes for embeddings (more efficient)
    - Embedding serialization must handle endianness consistently (use native or little-endian)
    - All functions must be infallible for valid inputs
    - Error messages must be descriptive
    - Performance target: <100μs for node serialization
  </constraints>

  <verification>
    - cargo build --package context-graph-storage compiles without errors
    - cargo test --package context-graph-storage serialization passes all tests
    - Round-trip serialization preserves all data
  </verification>
</definition_of_done>

<pseudo_code>
serialization.rs:
  use bincode;
  use thiserror::Error;

  // SerializationError enum

  pub fn serialize_node(node: &amp;MemoryNode) -> Result&lt;Vec&lt;u8&gt;, SerializationError&gt; {
    bincode::serialize(node).map_err(SerializationError::SerializeFailed)
  }

  pub fn deserialize_node(bytes: &amp;[u8]) -> Result&lt;MemoryNode, SerializationError&gt; {
    bincode::deserialize(bytes)
      .map_err(|e| SerializationError::DeserializeFailed(e.to_string()))
  }

  pub fn serialize_edge(edge: &amp;GraphEdge) -> Result&lt;Vec&lt;u8&gt;, SerializationError&gt; {
    bincode::serialize(edge).map_err(SerializationError::SerializeFailed)
  }

  pub fn deserialize_edge(bytes: &amp;[u8]) -> Result&lt;GraphEdge, SerializationError&gt; {
    bincode::deserialize(bytes)
      .map_err(|e| SerializationError::DeserializeFailed(e.to_string()))
  }

  pub fn serialize_embedding(embedding: &amp;EmbeddingVector) -> Vec&lt;u8&gt; {
    // Convert f32 slice to bytes directly
    let mut bytes = Vec::with_capacity(embedding.len() * 4);
    for f in embedding {
      bytes.extend_from_slice(&amp;f.to_le_bytes());
    }
    bytes
  }

  pub fn deserialize_embedding(bytes: &amp;[u8]) -> Result&lt;EmbeddingVector, SerializationError&gt; {
    if bytes.len() % 4 != 0 {
      return Err(SerializationError::InvalidEmbeddingSize {
        expected: (bytes.len() / 4 + 1) * 4,
        actual: bytes.len(),
      });
    }
    let mut embedding = Vec::with_capacity(bytes.len() / 4);
    for chunk in bytes.chunks(4) {
      let arr: [u8; 4] = chunk.try_into().unwrap();
      embedding.push(f32::from_le_bytes(arr));
    }
    Ok(embedding)
  }

  pub fn serialize_uuid(id: &amp;Uuid) -> [u8; 16] {
    *id.as_bytes()
  }

  pub fn deserialize_uuid(bytes: &amp;[u8; 16]) -> Uuid {
    Uuid::from_bytes(*bytes)
  }

#[cfg(test)]
mod tests:
  test_node_roundtrip()
  test_edge_roundtrip()
  test_embedding_roundtrip()
  test_embedding_preserves_values()
  test_uuid_roundtrip()
  test_node_size_is_reasonable()
  test_edge_size_is_reasonable()
</pseudo_code>

<files_to_create>
  <!-- File already exists as placeholder -->
</files_to_create>

<files_to_modify>
  <file path="crates/context-graph-storage/src/serialization.rs">Implement serialization functions</file>
  <file path="crates/context-graph-storage/src/lib.rs">Re-export serialization types</file>
</files_to_modify>

<validation_criteria>
  <criterion>serialize_node() produces compact bincode bytes</criterion>
  <criterion>Round-trip serialization preserves all MemoryNode fields</criterion>
  <criterion>Embedding serialization is efficient (~6KB for 1536D)</criterion>
  <criterion>GraphEdge serialization preserves Marblestone fields</criterion>
  <criterion>Error handling returns appropriate SerializationError variants</criterion>
  <criterion>UUID serialization uses exactly 16 bytes</criterion>
</validation_criteria>

<test_commands>
  <command>cargo build --package context-graph-storage</command>
  <command>cargo test --package context-graph-storage serialization -- --nocapture</command>
</test_commands>
</task_spec>
```

## Implementation Notes

### Bincode Configuration
Using bincode with default configuration provides:
- Compact binary format
- Varint encoding for sizes
- Compatible with serde derives

### Embedding Serialization Strategy
For embeddings, we bypass bincode and use raw f32 bytes for efficiency:
- 1536 dimensions × 4 bytes = 6144 bytes
- No overhead from bincode metadata
- Little-endian for consistency

### Size Estimates
| Type | Serialized Size |
|------|-----------------|
| MemoryNode | ~6.5KB (dominated by embedding) |
| GraphEdge | ~200 bytes |
| Embedding (1536D) | 6144 bytes |
| UUID | 16 bytes |

### Performance Considerations
- serialize_embedding() is allocation-heavy; consider reusing buffers
- For batch operations, consider serializing directly to writer

---

*Task ID: TASK-M02-014*
*Module: 02 - Core Infrastructure*
*Layer: Logic*
