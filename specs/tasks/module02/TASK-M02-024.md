# TASK-M02-024: Implement Embedding Storage Operations

```xml
<task_spec id="TASK-M02-024" version="2.0">
<metadata>
  <title>Implement Embedding Storage Operations</title>
  <status>ready</status>
  <layer>surface</layer>
  <module>module-02</module>
  <sequence>24</sequence>
  <priority>high</priority>
  <estimated_hours>2</estimated_hours>
  <implements>
    <item>TECH-CORE-002 Section 3: Storage specification</item>
    <item>REQ-CORE-005: Storage requirements</item>
  </implements>
  <depends_on>
    <task_ref status="complete">TASK-M02-014</task_ref>
    <task_ref status="complete">TASK-M02-016</task_ref>
  </depends_on>
  <estimated_complexity>medium</estimated_complexity>
</metadata>
```

## Critical Context for AI Agent

**This task is READY.** All dependencies are complete:
- TASK-M02-014 (Bincode Serialization) ✅ COMPLETE - 41/41 tests pass
- TASK-M02-016 (RocksDB Backend Open/Close) ✅ COMPLETE - 31/31 tests pass
- TASK-M02-017 (Node CRUD Operations) ✅ COMPLETE - stores embeddings as part of `store_node()`

### What This Task Does

This task adds **direct embedding storage/retrieval methods** to `RocksDbMemex`. While `store_node()` already stores embeddings as part of node storage (in the `embeddings` CF), these new methods provide:

1. **`store_embedding()`** - Store/update an embedding independently of the full node
2. **`get_embedding()`** - Retrieve a single embedding by node ID
3. **`batch_get_embeddings()`** - Retrieve multiple embeddings efficiently in one call

These are needed for:
- Vector similarity search preparation (loading embeddings for FAISS indexing)
- Batch operations for bulk embedding retrieval
- Independent embedding updates without full node serialization

### Current Codebase State (as of 2025-12-31)

**Serialization functions ALREADY EXIST** in `crates/context-graph-storage/src/serialization.rs`:
- `serialize_embedding(&[f32]) -> Vec<u8>` - Raw little-endian f32 bytes ✅
- `deserialize_embedding(&[u8]) -> Result<Vec<f32>, SerializationError>` - Round-trip ✅

**RocksDB structure** is:
```
crates/context-graph-storage/src/rocksdb_backend/
├── mod.rs           # Exports: RocksDbMemex, StorageError, RocksDbConfig
├── config.rs        # RocksDbConfig struct
├── error.rs         # StorageError enum
├── core.rs          # RocksDbMemex struct with open(), get_cf(), etc.
├── helpers.rs       # Key formatting utilities
├── node_ops.rs      # store_node(), get_node(), update_node(), delete_node()
├── edge_ops.rs      # Edge CRUD operations
├── index_ops.rs     # Secondary index queries (get_nodes_by_quadrant, etc.)
└── tests_*.rs       # Test files
```

**Column families** defined in `column_families.rs`:
- `cf_names::EMBEDDINGS` = `"embeddings"` - stores embedding vectors keyed by NodeId

**Key format** for embeddings CF: 16-byte raw UUID (`serialize_uuid(&node_id)`)

## Implementation Requirements

### File to Create: `crates/context-graph-storage/src/rocksdb_backend/embedding_ops.rs`

```rust
//! Embedding storage operations for RocksDB backend.
//!
//! Provides direct access to embedding vectors stored in the `embeddings` CF.
//! While embeddings are stored as part of `store_node()`, these methods allow:
//! - Independent embedding updates without full node serialization
//! - Batch retrieval for vector search preparation
//! - Single embedding retrieval for similarity calculations
//!
//! # Performance
//! - Single embedding: ~6KB read (1536D × 4 bytes/f32)
//! - Batch retrieval uses RocksDB `multi_get_cf` for efficiency
//!
//! # Key Format
//! Embeddings are keyed by 16-byte raw UUID (same as nodes CF)

use crate::column_families::cf_names;
use crate::serialization::{deserialize_embedding, serialize_embedding, serialize_uuid};
use context_graph_core::types::{EmbeddingVector, NodeId};

use super::core::RocksDbMemex;
use super::error::StorageError;

impl RocksDbMemex {
    /// Stores an embedding vector for a node.
    ///
    /// This is typically called as part of `store_node()`, but can be
    /// used to update embeddings independently when:
    /// - Embeddings are regenerated (new model, re-encoding)
    /// - Only embedding needs updating without full node overhead
    ///
    /// # Arguments
    /// * `node_id` - The node ID to associate the embedding with
    /// * `embedding` - The embedding vector (typically 1536 dimensions)
    ///
    /// # Returns
    /// * `Ok(())` - Embedding stored successfully
    /// * `Err(StorageError::WriteFailed)` - RocksDB write error
    /// * `Err(StorageError::ColumnFamilyNotFound)` - CF missing (should never happen)
    ///
    /// # Performance
    /// ~6KB write for 1536-dimensional vector
    ///
    /// # Example
    /// ```rust,ignore
    /// let embedding = vec![0.1_f32; 1536];
    /// db.store_embedding(&node_id, &embedding)?;
    /// ```
    pub fn store_embedding(
        &self,
        node_id: &NodeId,
        embedding: &EmbeddingVector,
    ) -> Result<(), StorageError> {
        let cf_embeddings = self.get_cf(cf_names::EMBEDDINGS)?;
        let key = serialize_uuid(node_id);
        let value = serialize_embedding(embedding);

        self.db
            .put_cf(cf_embeddings, key.as_slice(), &value)
            .map_err(|e| StorageError::WriteFailed(e.to_string()))?;

        Ok(())
    }

    /// Retrieves an embedding vector by node ID.
    ///
    /// # Arguments
    /// * `node_id` - The node ID to retrieve the embedding for
    ///
    /// # Returns
    /// * `Ok(Vec<f32>)` - The embedding vector
    /// * `Err(StorageError::NotFound)` - No embedding exists for this node
    /// * `Err(StorageError::Serialization)` - Corrupted embedding data
    /// * `Err(StorageError::ReadFailed)` - RocksDB read error
    ///
    /// # Example
    /// ```rust,ignore
    /// let embedding = db.get_embedding(&node_id)?;
    /// assert_eq!(embedding.len(), 1536);
    /// ```
    pub fn get_embedding(&self, node_id: &NodeId) -> Result<EmbeddingVector, StorageError> {
        let cf_embeddings = self.get_cf(cf_names::EMBEDDINGS)?;
        let key = serialize_uuid(node_id);

        let value = self
            .db
            .get_cf(cf_embeddings, key.as_slice())
            .map_err(|e| StorageError::ReadFailed(e.to_string()))?
            .ok_or_else(|| StorageError::NotFound {
                id: node_id.to_string(),
            })?;

        deserialize_embedding(&value).map_err(StorageError::from)
    }

    /// Retrieves multiple embeddings in a single batch operation.
    ///
    /// Returns a Vec of Option<Vec<f32>> in the same order as input IDs.
    /// None indicates the embedding was not found for that ID.
    ///
    /// More efficient than multiple `get_embedding()` calls because:
    /// 1. Single RocksDB batch operation
    /// 2. Better cache utilization
    /// 3. Reduced lock contention
    ///
    /// # Arguments
    /// * `node_ids` - Slice of node IDs to retrieve embeddings for
    ///
    /// # Returns
    /// * `Ok(Vec<Option<Vec<f32>>>)` - Embeddings in same order as input IDs
    ///   - `Some(embedding)` if found
    ///   - `None` if not found for that ID
    /// * `Err(StorageError::Serialization)` - If any found embedding is corrupted
    /// * `Err(StorageError::ReadFailed)` - RocksDB batch read error
    ///
    /// # Example
    /// ```rust,ignore
    /// let ids = vec![node1_id, node2_id, node3_id];
    /// let embeddings = db.batch_get_embeddings(&ids)?;
    ///
    /// for (i, maybe_emb) in embeddings.iter().enumerate() {
    ///     match maybe_emb {
    ///         Some(emb) => println!("Node {}: {} dimensions", i, emb.len()),
    ///         None => println!("Node {}: not found", i),
    ///     }
    /// }
    /// ```
    pub fn batch_get_embeddings(
        &self,
        node_ids: &[NodeId],
    ) -> Result<Vec<Option<EmbeddingVector>>, StorageError> {
        if node_ids.is_empty() {
            return Ok(Vec::new());
        }

        let cf_embeddings = self.get_cf(cf_names::EMBEDDINGS)?;

        // Build keys for multi_get
        let keys: Vec<[u8; 16]> = node_ids.iter().map(serialize_uuid).collect();

        // Create CF references for multi_get_cf
        let cf_key_pairs: Vec<(&rocksdb::ColumnFamily, &[u8])> = keys
            .iter()
            .map(|k| (cf_embeddings, k.as_slice()))
            .collect();

        // Execute batch read
        let results = self.db.multi_get_cf(cf_key_pairs);

        // Process results, preserving order
        let mut embeddings = Vec::with_capacity(node_ids.len());
        for result in results {
            match result {
                Ok(Some(bytes)) => {
                    let embedding = deserialize_embedding(&bytes)?;
                    embeddings.push(Some(embedding));
                }
                Ok(None) => {
                    embeddings.push(None);
                }
                Err(e) => {
                    return Err(StorageError::ReadFailed(e.to_string()));
                }
            }
        }

        Ok(embeddings)
    }

    /// Deletes an embedding for a node.
    ///
    /// NOTE: This is typically called as part of `delete_node()`.
    /// Use this only for independent embedding cleanup.
    ///
    /// # Arguments
    /// * `node_id` - The node ID whose embedding to delete
    ///
    /// # Returns
    /// * `Ok(())` - Embedding deleted (or didn't exist)
    /// * `Err(StorageError::WriteFailed)` - RocksDB delete error
    pub fn delete_embedding(&self, node_id: &NodeId) -> Result<(), StorageError> {
        let cf_embeddings = self.get_cf(cf_names::EMBEDDINGS)?;
        let key = serialize_uuid(node_id);

        self.db
            .delete_cf(cf_embeddings, key.as_slice())
            .map_err(|e| StorageError::WriteFailed(e.to_string()))?;

        Ok(())
    }

    /// Checks if an embedding exists for a node.
    ///
    /// More efficient than `get_embedding()` when you only need existence check.
    ///
    /// # Arguments
    /// * `node_id` - The node ID to check
    ///
    /// # Returns
    /// * `Ok(true)` - Embedding exists
    /// * `Ok(false)` - No embedding for this node
    /// * `Err(StorageError::ReadFailed)` - RocksDB read error
    pub fn embedding_exists(&self, node_id: &NodeId) -> Result<bool, StorageError> {
        let cf_embeddings = self.get_cf(cf_names::EMBEDDINGS)?;
        let key = serialize_uuid(node_id);

        // Use key_may_exist for bloom filter optimization, then verify
        // This is faster than get_cf when embedding doesn't exist
        match self.db.get_cf(cf_embeddings, key.as_slice()) {
            Ok(Some(_)) => Ok(true),
            Ok(None) => Ok(false),
            Err(e) => Err(StorageError::ReadFailed(e.to_string())),
        }
    }
}
```

### File to Create: `crates/context-graph-storage/src/rocksdb_backend/tests_embedding.rs`

```rust
//! Embedding storage operation tests.
//!
//! Tests use REAL data stored in RocksDB - NO mocks per constitution.yaml.
//! Each test stores embeddings via embedding_ops methods and verifies actual DB state.

use tempfile::TempDir;
use uuid::Uuid;

use super::core::RocksDbMemex;
use context_graph_core::types::{EmbeddingVector, NodeId, DEFAULT_EMBEDDING_DIM};

// =========================================================================
// Test Helpers (NO MOCKS - REAL DATA)
// =========================================================================

/// Create a temp database for testing.
fn create_temp_db() -> (TempDir, RocksDbMemex) {
    let tmp = TempDir::new().expect("create temp dir");
    let db = RocksDbMemex::open(tmp.path()).expect("open db");
    (tmp, db)
}

/// Create a normalized embedding vector (magnitude ~= 1.0).
fn create_normalized_embedding(dim: usize) -> EmbeddingVector {
    let val = 1.0 / (dim as f32).sqrt();
    vec![val; dim]
}

/// Create an embedding with specific values for precision testing.
fn create_precision_embedding() -> EmbeddingVector {
    let mut embedding = Vec::with_capacity(DEFAULT_EMBEDDING_DIM);
    for i in 0..DEFAULT_EMBEDDING_DIM {
        let value = (i as f32 / DEFAULT_EMBEDDING_DIM as f32) * std::f32::consts::PI;
        embedding.push(value);
    }
    embedding
}

// =========================================================================
// store_embedding Tests
// =========================================================================

#[test]
fn test_store_embedding_basic() {
    println!("=== TEST: store_embedding basic operation ===");
    let (_tmp, db) = create_temp_db();

    let node_id = Uuid::new_v4();
    let embedding = create_normalized_embedding(DEFAULT_EMBEDDING_DIM);

    println!("BEFORE: No embedding exists for node {}", node_id);

    let result = db.store_embedding(&node_id, &embedding);

    assert!(result.is_ok(), "store_embedding should succeed");

    // VERIFY: Check the source of truth (embeddings CF)
    let retrieved = db.get_embedding(&node_id).expect("get after store");
    assert_eq!(retrieved.len(), DEFAULT_EMBEDDING_DIM);

    println!(
        "AFTER: Embedding stored, {} dimensions verified in DB",
        retrieved.len()
    );
    println!("RESULT: PASS");
}

#[test]
fn test_store_embedding_overwrites() {
    println!("=== TEST: store_embedding overwrites existing ===");
    let (_tmp, db) = create_temp_db();

    let node_id = Uuid::new_v4();
    let embedding1 = vec![0.1_f32; DEFAULT_EMBEDDING_DIM];
    let embedding2 = vec![0.9_f32; DEFAULT_EMBEDDING_DIM];

    db.store_embedding(&node_id, &embedding1).unwrap();
    println!("BEFORE: First embedding stored (all 0.1)");

    db.store_embedding(&node_id, &embedding2).unwrap();
    println!("ACTION: Second embedding stored (all 0.9)");

    let retrieved = db.get_embedding(&node_id).unwrap();
    assert!(
        (retrieved[0] - 0.9).abs() < 0.0001,
        "Should have second embedding value"
    );

    println!("AFTER: Retrieved value = {}, expected 0.9", retrieved[0]);
    println!("RESULT: PASS - Overwrite successful");
}

// =========================================================================
// get_embedding Tests
// =========================================================================

#[test]
fn test_get_embedding_not_found() {
    println!("=== TEST: get_embedding returns NotFound for missing ===");
    let (_tmp, db) = create_temp_db();

    let nonexistent_id = Uuid::new_v4();

    let result = db.get_embedding(&nonexistent_id);

    assert!(result.is_err());
    let err = result.unwrap_err();
    assert!(
        err.to_string().contains("not found"),
        "Error should indicate not found: {}",
        err
    );

    println!("RESULT: PASS - NotFound error for missing embedding");
}

#[test]
fn test_get_embedding_roundtrip_precision() {
    println!("=== TEST: get_embedding preserves exact f32 precision ===");
    let (_tmp, db) = create_temp_db();

    let node_id = Uuid::new_v4();
    let embedding = create_precision_embedding();

    db.store_embedding(&node_id, &embedding).unwrap();
    let retrieved = db.get_embedding(&node_id).unwrap();

    assert_eq!(embedding.len(), retrieved.len());

    for (i, (orig, rest)) in embedding.iter().zip(retrieved.iter()).enumerate() {
        assert_eq!(
            orig.to_bits(),
            rest.to_bits(),
            "Value at index {} differs: {} vs {} (bits: {:032b} vs {:032b})",
            i,
            orig,
            rest,
            orig.to_bits(),
            rest.to_bits()
        );
    }

    println!(
        "RESULT: PASS - All {} values preserved exactly",
        embedding.len()
    );
}

// =========================================================================
// batch_get_embeddings Tests
// =========================================================================

#[test]
fn test_batch_get_embeddings_empty() {
    println!("=== TEST: batch_get_embeddings with empty input ===");
    let (_tmp, db) = create_temp_db();

    let result = db.batch_get_embeddings(&[]);

    assert!(result.is_ok());
    assert!(result.unwrap().is_empty());

    println!("RESULT: PASS - Empty input returns empty output");
}

#[test]
fn test_batch_get_embeddings_all_found() {
    println!("=== TEST: batch_get_embeddings all IDs found ===");
    let (_tmp, db) = create_temp_db();

    // Store 3 embeddings
    let ids: Vec<NodeId> = (0..3).map(|_| Uuid::new_v4()).collect();
    for (i, id) in ids.iter().enumerate() {
        let embedding = vec![(i as f32) * 0.1; DEFAULT_EMBEDDING_DIM];
        db.store_embedding(id, &embedding).unwrap();
    }

    println!("BEFORE: Stored 3 embeddings");

    let result = db.batch_get_embeddings(&ids).unwrap();

    assert_eq!(result.len(), 3);
    for (i, maybe_emb) in result.iter().enumerate() {
        assert!(maybe_emb.is_some(), "Embedding {} should be found", i);
        let emb = maybe_emb.as_ref().unwrap();
        assert_eq!(emb.len(), DEFAULT_EMBEDDING_DIM);
        // Verify first value matches what we stored
        let expected = (i as f32) * 0.1;
        assert!(
            (emb[0] - expected).abs() < 0.0001,
            "Embedding {} first value should be {}, got {}",
            i,
            expected,
            emb[0]
        );
    }

    println!("AFTER: Retrieved 3/3 embeddings with correct values");
    println!("RESULT: PASS");
}

#[test]
fn test_batch_get_embeddings_some_missing() {
    println!("=== TEST: batch_get_embeddings with some IDs missing ===");
    let (_tmp, db) = create_temp_db();

    let id1 = Uuid::new_v4();
    let id2 = Uuid::new_v4(); // NOT stored
    let id3 = Uuid::new_v4();

    db.store_embedding(&id1, &vec![0.1_f32; DEFAULT_EMBEDDING_DIM])
        .unwrap();
    db.store_embedding(&id3, &vec![0.3_f32; DEFAULT_EMBEDDING_DIM])
        .unwrap();

    println!("BEFORE: Stored embeddings for id1, id3 (NOT id2)");

    let result = db.batch_get_embeddings(&[id1, id2, id3]).unwrap();

    assert_eq!(result.len(), 3);
    assert!(result[0].is_some(), "id1 should be found");
    assert!(result[1].is_none(), "id2 should be None (not stored)");
    assert!(result[2].is_some(), "id3 should be found");

    println!(
        "AFTER: result[0]=Some, result[1]=None, result[2]=Some - order preserved"
    );
    println!("RESULT: PASS");
}

#[test]
fn test_batch_get_embeddings_all_missing() {
    println!("=== TEST: batch_get_embeddings with all IDs missing ===");
    let (_tmp, db) = create_temp_db();

    let ids: Vec<NodeId> = (0..3).map(|_| Uuid::new_v4()).collect();

    let result = db.batch_get_embeddings(&ids).unwrap();

    assert_eq!(result.len(), 3);
    for maybe_emb in result.iter() {
        assert!(maybe_emb.is_none());
    }

    println!("RESULT: PASS - All None for nonexistent IDs");
}

#[test]
fn test_batch_get_embeddings_preserves_order() {
    println!("=== TEST: batch_get_embeddings preserves input order ===");
    let (_tmp, db) = create_temp_db();

    // Store with distinguishing values
    let id1 = Uuid::new_v4();
    let id2 = Uuid::new_v4();
    let id3 = Uuid::new_v4();

    db.store_embedding(&id1, &vec![1.0_f32; DEFAULT_EMBEDDING_DIM])
        .unwrap();
    db.store_embedding(&id2, &vec![2.0_f32; DEFAULT_EMBEDDING_DIM])
        .unwrap();
    db.store_embedding(&id3, &vec![3.0_f32; DEFAULT_EMBEDDING_DIM])
        .unwrap();

    // Request in different order
    let result = db.batch_get_embeddings(&[id3, id1, id2]).unwrap();

    assert!(
        (result[0].as_ref().unwrap()[0] - 3.0).abs() < 0.0001,
        "First result should be id3's embedding (3.0)"
    );
    assert!(
        (result[1].as_ref().unwrap()[0] - 1.0).abs() < 0.0001,
        "Second result should be id1's embedding (1.0)"
    );
    assert!(
        (result[2].as_ref().unwrap()[0] - 2.0).abs() < 0.0001,
        "Third result should be id2's embedding (2.0)"
    );

    println!("RESULT: PASS - Order matches input IDs");
}

// =========================================================================
// delete_embedding Tests
// =========================================================================

#[test]
fn test_delete_embedding_basic() {
    println!("=== TEST: delete_embedding removes from DB ===");
    let (_tmp, db) = create_temp_db();

    let node_id = Uuid::new_v4();
    let embedding = create_normalized_embedding(DEFAULT_EMBEDDING_DIM);

    db.store_embedding(&node_id, &embedding).unwrap();
    assert!(db.embedding_exists(&node_id).unwrap());
    println!("BEFORE: Embedding exists");

    db.delete_embedding(&node_id).unwrap();

    assert!(!db.embedding_exists(&node_id).unwrap());
    println!("AFTER: Embedding deleted");
    println!("RESULT: PASS");
}

#[test]
fn test_delete_embedding_nonexistent_ok() {
    println!("=== TEST: delete_embedding on nonexistent is OK ===");
    let (_tmp, db) = create_temp_db();

    let node_id = Uuid::new_v4();

    let result = db.delete_embedding(&node_id);

    assert!(
        result.is_ok(),
        "Deleting nonexistent embedding should succeed"
    );
    println!("RESULT: PASS - No error for deleting nonexistent");
}

// =========================================================================
// embedding_exists Tests
// =========================================================================

#[test]
fn test_embedding_exists() {
    println!("=== TEST: embedding_exists checks correctly ===");
    let (_tmp, db) = create_temp_db();

    let node_id = Uuid::new_v4();

    assert!(!db.embedding_exists(&node_id).unwrap());
    println!("BEFORE: embedding_exists = false");

    db.store_embedding(&node_id, &vec![0.5_f32; DEFAULT_EMBEDDING_DIM])
        .unwrap();

    assert!(db.embedding_exists(&node_id).unwrap());
    println!("AFTER: embedding_exists = true");
    println!("RESULT: PASS");
}

// =========================================================================
// Edge Case Tests (REQUIRED - with before/after state printing)
// =========================================================================

#[test]
fn edge_case_empty_embedding() {
    println!("=== EDGE CASE 1: Empty embedding vector ===");
    let (_tmp, db) = create_temp_db();

    let node_id = Uuid::new_v4();
    let empty: EmbeddingVector = vec![];

    println!("BEFORE: Storing empty embedding");

    db.store_embedding(&node_id, &empty).unwrap();
    let retrieved = db.get_embedding(&node_id).unwrap();

    println!("AFTER: Retrieved embedding length = {}", retrieved.len());
    assert!(retrieved.is_empty());
    println!("RESULT: PASS - Empty embedding preserved");
}

#[test]
fn edge_case_extreme_float_values() {
    println!("=== EDGE CASE 2: Extreme float values ===");
    let (_tmp, db) = create_temp_db();

    let node_id = Uuid::new_v4();
    let extremes = vec![
        f32::MIN_POSITIVE,
        f32::MAX,
        f32::MIN,
        1e-38_f32,
        1e38_f32,
        0.0_f32,
        -0.0_f32,
    ];

    println!("BEFORE: {:?}", extremes);

    db.store_embedding(&node_id, &extremes).unwrap();
    let retrieved = db.get_embedding(&node_id).unwrap();

    println!("AFTER: {:?}", retrieved);

    for (i, (orig, rest)) in extremes.iter().zip(retrieved.iter()).enumerate() {
        assert_eq!(
            orig.to_bits(),
            rest.to_bits(),
            "Value {} differs: {} vs {}",
            i,
            orig,
            rest
        );
    }
    println!("RESULT: PASS - All extreme values preserved exactly");
}

#[test]
fn edge_case_1536d_size_verification() {
    println!("=== EDGE CASE 3: 1536D embedding size verification ===");
    let (_tmp, db) = create_temp_db();

    let node_id = Uuid::new_v4();
    let embedding = create_normalized_embedding(1536);

    println!("BEFORE: embedding.len() = {}", embedding.len());

    db.store_embedding(&node_id, &embedding).unwrap();
    let retrieved = db.get_embedding(&node_id).unwrap();

    println!(
        "AFTER: retrieved.len() = {}, expected 1536",
        retrieved.len()
    );

    assert_eq!(retrieved.len(), 1536);
    // Verify byte size: 1536 * 4 = 6144 bytes
    let byte_size = 1536 * 4;
    println!(
        "Embedding byte size: {} bytes (~{:.1}KB)",
        byte_size,
        byte_size as f64 / 1024.0
    );
    println!("RESULT: PASS - 1536D = 6144 bytes");
}

// =========================================================================
// Integration with store_node (verify consistency)
// =========================================================================

#[test]
fn test_embedding_consistent_with_store_node() {
    println!("=== TEST: Embedding consistent between store_node and get_embedding ===");
    let (_tmp, db) = create_temp_db();

    use context_graph_core::types::MemoryNode;

    // Create and store a node (which stores embedding via store_node)
    let embedding = create_normalized_embedding(DEFAULT_EMBEDDING_DIM);
    let node = MemoryNode::new("Test content".to_string(), embedding.clone());
    let node_id = node.id;

    // Store via node_ops (this writes to embeddings CF)
    db.store_node(&node).expect("store_node");

    // Retrieve via embedding_ops
    let retrieved = db.get_embedding(&node_id).unwrap();

    assert_eq!(retrieved.len(), embedding.len());
    for (i, (orig, rest)) in embedding.iter().zip(retrieved.iter()).enumerate() {
        assert_eq!(
            orig.to_bits(),
            rest.to_bits(),
            "Value at {} differs",
            i
        );
    }

    println!("RESULT: PASS - store_node and get_embedding are consistent");
}

#[test]
fn test_store_embedding_updates_store_node_embedding() {
    println!("=== TEST: store_embedding updates embedding stored by store_node ===");
    let (_tmp, db) = create_temp_db();

    use context_graph_core::types::MemoryNode;

    // Store node with original embedding
    let original = create_normalized_embedding(DEFAULT_EMBEDDING_DIM);
    let node = MemoryNode::new("Test".to_string(), original);
    let node_id = node.id;
    db.store_node(&node).unwrap();

    // Update embedding independently
    let updated = vec![0.999_f32; DEFAULT_EMBEDDING_DIM];
    db.store_embedding(&node_id, &updated).unwrap();

    // Verify via get_embedding
    let retrieved = db.get_embedding(&node_id).unwrap();
    assert!(
        (retrieved[0] - 0.999).abs() < 0.0001,
        "Should have updated value"
    );

    println!("RESULT: PASS - Independent embedding update works");
}

// =========================================================================
// Boundary & Edge Case Audit (REQUIRED per task spec)
// =========================================================================

#[test]
fn boundary_audit_max_batch_size() {
    println!("=== BOUNDARY AUDIT: Large batch retrieval ===");
    let (_tmp, db) = create_temp_db();

    // Store 100 embeddings
    let mut ids = Vec::new();
    for i in 0..100 {
        let id = Uuid::new_v4();
        let embedding = vec![(i as f32) * 0.01; DEFAULT_EMBEDDING_DIM];
        db.store_embedding(&id, &embedding).unwrap();
        ids.push(id);
    }

    println!("BEFORE: 100 embeddings stored");

    let result = db.batch_get_embeddings(&ids).unwrap();

    assert_eq!(result.len(), 100);
    let found_count = result.iter().filter(|e| e.is_some()).count();
    assert_eq!(found_count, 100);

    println!("AFTER: Retrieved 100/100 embeddings in batch");
    println!("RESULT: PASS");
}

#[test]
fn boundary_audit_various_dimensions() {
    println!("=== BOUNDARY AUDIT: Various embedding dimensions ===");
    let (_tmp, db) = create_temp_db();

    for dim in [1, 10, 128, 512, 768, 1024, 1536] {
        let node_id = Uuid::new_v4();
        let embedding = create_normalized_embedding(dim);

        println!("Testing dim={}", dim);

        db.store_embedding(&node_id, &embedding).unwrap();
        let retrieved = db.get_embedding(&node_id).unwrap();

        assert_eq!(retrieved.len(), dim);
    }

    println!("RESULT: PASS - All dimensions work correctly");
}
```

### Files to Modify

**1. `crates/context-graph-storage/src/rocksdb_backend/mod.rs`**

Add to the module declarations (after `mod index_ops;`):
```rust
mod embedding_ops;
```

Add to the test modules:
```rust
#[cfg(test)]
mod tests_embedding;
```

## Verification Commands

```bash
# Build verification (MUST pass)
cargo build --package context-graph-storage

# Run embedding tests specifically
cargo test --package context-graph-storage embedding -- --nocapture

# Run all storage tests (MUST not regress)
cargo test --package context-graph-storage -- --nocapture

# Clippy (0 warnings required)
cargo clippy --package context-graph-storage -- -D warnings
```

## Full State Verification (REQUIRED)

After implementation, you MUST verify:

### 1. Source of Truth
The embeddings are stored in RocksDB `embeddings` column family:
- Key: 16-byte raw UUID (`serialize_uuid(&node_id)`)
- Value: Raw little-endian f32 bytes (`serialize_embedding(&embedding)`)

### 2. Execute & Inspect
After each write, verify actual RocksDB contents:
```rust
// After store_embedding:
let cf = db.get_cf(cf_names::EMBEDDINGS)?;
let exists = db.db().get_cf(cf, &serialize_uuid(&node_id))?.is_some();
assert!(exists, "Embedding MUST exist in embeddings CF after store");
```

### 3. Boundary & Edge Case Audit

**Edge Case 1: Empty Embedding**
- BEFORE: No embedding for node
- ACTION: `store_embedding(&id, &vec![])`
- AFTER: Empty Vec stored and retrievable

**Edge Case 2: Maximum Dimension (1536D)**
- BEFORE: Standard 1536D embedding
- ACTION: Store and retrieve
- AFTER: Exactly 6144 bytes (1536 × 4), all values preserved

**Edge Case 3: Missing in Batch**
- BEFORE: Store 2 of 3 requested IDs
- ACTION: `batch_get_embeddings(&[id1, id2, id3])`
- AFTER: `[Some(_), None, Some(_)]` - order preserved

### 4. Evidence of Success

Print statements in tests show:
```
=== TEST: batch_get_embeddings all IDs found ===
BEFORE: Stored 3 embeddings
AFTER: Retrieved 3/3 embeddings with correct values
RESULT: PASS
```

## Constraints (MUST Follow)

1. **NO async** - RocksDbMemex methods are synchronous
2. **NO mocks in tests** - Use real `store_embedding()` then verify with `get_embedding()`
3. **Raw f32 bytes** - Use existing `serialize_embedding`/`deserialize_embedding` (NO bincode for vectors)
4. **Preserve f32 bit patterns** - Use `to_bits()` comparison for precision tests
5. **Return None for missing** - `batch_get_embeddings` returns `None` for missing IDs, NOT error
6. **Fail fast** - Return `StorageError::NotFound` from `get_embedding()` for missing IDs

## Final Verification Step (MANDATORY)

After completing implementation, you MUST:

1. Run `cargo test --package context-graph-storage -- --nocapture`
2. Run `cargo clippy --package context-graph-storage -- -D warnings`
3. **Spawn a `sherlock-holmes` subagent** to verify:
   - All tests pass (no failures)
   - Zero clippy warnings
   - Embedding roundtrip preserves exact f32 values
   - Batch operations return correct order
   - Missing embeddings return None (not error)
   - No regressions in existing tests (163 tests should still pass)

---

*Task ID: TASK-M02-024*
*Module: 02 - Core Infrastructure*
*Layer: Surface*
*Last Updated: 2025-12-31 - Complete audit and rewrite with accurate file paths, existing function references, and verification requirements*
