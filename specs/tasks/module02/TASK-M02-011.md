# TASK-M02-011: Implement GraphEdge Methods

```xml
<task_spec id="TASK-M02-011" version="1.0">
<metadata>
  <title>Implement GraphEdge Methods</title>
  <status>blocked</status>
  <layer>foundation</layer>
  <module>module-02</module>
  <sequence>11</sequence>
  <priority>critical</priority>
  <estimated_hours>2.5</estimated_hours>
  <implements>
    <item>TECH-CORE-002 Section 2.5: GraphEdge methods specification</item>
    <item>Marblestone Integration Spec: Modulated weight calculation</item>
  </implements>
  <depends_on>
    <task_ref>TASK-M02-010</task_ref>
  </depends_on>
  <estimated_complexity>medium</estimated_complexity>
</metadata>

<context>
This task implements all methods for the GraphEdge struct including constructors, modulated weight calculation using neurotransmitter weights, steering reward application, traversal recording, and shortcut identification. These methods enable the core Marblestone architecture behaviors for context-aware graph traversal.
</context>

<input_context_files>
  <file purpose="GraphEdge struct definition">crates/context-graph-core/src/marblestone.rs</file>
  <file purpose="Constitution reference for formulas">docs2/constitution.yaml</file>
  <file purpose="PRD reference for edge behavior">docs2/contextprd.md</file>
</input_context_files>

<prerequisites>
  <check>TASK-M02-010 (GraphEdge struct) is complete</check>
</prerequisites>

<scope>
  <in_scope>
    - GraphEdge::new() constructor
    - GraphEdge::get_modulated_weight() method
    - GraphEdge::apply_steering_reward() method
    - GraphEdge::decay_steering() method
    - GraphEdge::record_traversal() method
    - GraphEdge::is_reliable_shortcut() method
    - GraphEdge::mark_as_shortcut() method
    - Default trait implementation
    - Comprehensive unit tests
  </in_scope>
  <out_of_scope>
    - Persistence/storage (handled in storage tasks)
    - Dream layer shortcut creation logic (handled in dream module)
  </out_of_scope>
</scope>

<definition_of_done>
  <signatures>
    <signature file="crates/context-graph-core/src/marblestone.rs">
impl GraphEdge {
    /// Create a new edge with default values.
    ///
    /// # Arguments
    /// * `source_id` - Source node ID
    /// * `target_id` - Target node ID
    /// * `edge_type` - Type of relationship
    /// * `domain` - Knowledge domain (determines NT weights)
    pub fn new(
        source_id: NodeId,
        target_id: NodeId,
        edge_type: EdgeType,
        domain: Domain,
    ) -> Self;

    /// Create a new edge with explicit weight and confidence.
    pub fn with_weight(
        source_id: NodeId,
        target_id: NodeId,
        edge_type: EdgeType,
        domain: Domain,
        weight: f32,
        confidence: f32,
    ) -> Self;

    /// Get the modulated weight considering neurotransmitter weights and steering reward.
    ///
    /// Formula: (nt_factor * (1 + steering_reward * 0.2)).clamp(0.0, 1.0)
    /// Where nt_factor = neurotransmitter_weights.compute_effective_weight(weight)
    pub fn get_modulated_weight(&amp;self) -> f32;

    /// Apply a steering reward signal from the Steering Subsystem.
    /// The reward is clamped to [-1.0, 1.0].
    pub fn apply_steering_reward(&amp;mut self, reward: f32);

    /// Decay the steering reward by a factor.
    /// Used to gradually reduce the influence of old rewards.
    pub fn decay_steering(&amp;mut self, decay_factor: f32);

    /// Record a traversal of this edge.
    /// Updates traversal_count and last_traversed_at.
    pub fn record_traversal(&amp;mut self);

    /// Check if this edge is a reliable amortized shortcut.
    ///
    /// An edge is a reliable shortcut if:
    /// - is_amortized_shortcut is true
    /// - traversal_count >= 3
    /// - steering_reward > 0.3
    /// - confidence >= 0.7
    pub fn is_reliable_shortcut(&amp;self) -> bool;

    /// Mark this edge as an amortized shortcut.
    /// Sets is_amortized_shortcut to true.
    pub fn mark_as_shortcut(&amp;mut self);

    /// Get the age of this edge in seconds since creation.
    pub fn age_seconds(&amp;self) -> i64;
}

impl Default for GraphEdge {
    fn default() -> Self;
}
    </signature>
  </signatures>

  <constraints>
    - new() creates edge with domain-appropriate NT weights via NeurotransmitterWeights::for_domain()
    - Weight and confidence default to edge_type.default_weight() and 0.5 respectively
    - apply_steering_reward() clamps to [-1.0, 1.0]
    - decay_steering() multiplies current reward by decay_factor
    - record_traversal() uses saturating_add for traversal_count
    - is_reliable_shortcut() checks all 4 conditions
    - Default creates edge with new UUIDs and General domain
  </constraints>

  <verification>
    - cargo build --package context-graph-core compiles without errors
    - cargo test --package context-graph-core graph_edge passes all tests
    - cargo clippy --package context-graph-core shows no warnings
  </verification>
</definition_of_done>

<pseudo_code>
marblestone.rs (append after GraphEdge struct):
  impl GraphEdge:
    fn new(source_id, target_id, edge_type, domain):
      let now = Utc::now();
      Self {
        id: Uuid::new_v4(),
        source_id,
        target_id,
        edge_type,
        weight: edge_type.default_weight(),
        confidence: 0.5,
        domain,
        neurotransmitter_weights: NeurotransmitterWeights::for_domain(domain),
        is_amortized_shortcut: false,
        steering_reward: 0.0,
        traversal_count: 0,
        created_at: now,
        last_traversed_at: None,
      }

    fn with_weight(source_id, target_id, edge_type, domain, weight, confidence):
      let mut edge = Self::new(source_id, target_id, edge_type, domain);
      edge.weight = weight.clamp(0.0, 1.0);
      edge.confidence = confidence.clamp(0.0, 1.0);
      edge

    fn get_modulated_weight(&amp;self):
      // Apply NT weights to base weight
      let nt_factor = self.neurotransmitter_weights.compute_effective_weight(self.weight);
      // Apply steering reward influence
      (nt_factor * (1.0 + self.steering_reward * 0.2)).clamp(0.0, 1.0)

    fn apply_steering_reward(&amp;mut self, reward):
      self.steering_reward = (self.steering_reward + reward).clamp(-1.0, 1.0);

    fn decay_steering(&amp;mut self, decay_factor):
      self.steering_reward *= decay_factor;

    fn record_traversal(&amp;mut self):
      self.traversal_count = self.traversal_count.saturating_add(1);
      self.last_traversed_at = Some(Utc::now());

    fn is_reliable_shortcut(&amp;self):
      self.is_amortized_shortcut
        &amp;&amp; self.traversal_count >= 3
        &amp;&amp; self.steering_reward > 0.3
        &amp;&amp; self.confidence >= 0.7

    fn mark_as_shortcut(&amp;mut self):
      self.is_amortized_shortcut = true;

    fn age_seconds(&amp;self):
      (Utc::now() - self.created_at).num_seconds()

  impl Default:
    fn default():
      Self::new(
        Uuid::nil(),
        Uuid::nil(),
        EdgeType::default(),
        Domain::default(),
      )

#[cfg(test)]
mod graph_edge_method_tests:
  test_new_sets_domain_nt_weights()
  test_new_uses_edge_type_default_weight()
  test_with_weight_clamps_values()
  test_get_modulated_weight_applies_nt()
  test_get_modulated_weight_applies_steering()
  test_apply_steering_reward_clamps()
  test_decay_steering()
  test_record_traversal_increments()
  test_record_traversal_updates_timestamp()
  test_is_reliable_shortcut_all_conditions()
  test_is_reliable_shortcut_fails_not_shortcut()
  test_is_reliable_shortcut_fails_low_traversal()
  test_mark_as_shortcut()
  test_default()
</pseudo_code>

<files_to_create>
  <!-- File already exists -->
</files_to_create>

<files_to_modify>
  <file path="crates/context-graph-core/src/marblestone.rs">Add GraphEdge methods and Default implementation</file>
</files_to_modify>

<validation_criteria>
  <criterion>new() creates edge with domain-appropriate neurotransmitter weights</criterion>
  <criterion>new() uses edge_type.default_weight() for initial weight</criterion>
  <criterion>get_modulated_weight() applies NT weights via compute_effective_weight()</criterion>
  <criterion>get_modulated_weight() applies steering reward with 0.2 factor</criterion>
  <criterion>get_modulated_weight() always returns value in [0.0, 1.0]</criterion>
  <criterion>apply_steering_reward() clamps result to [-1.0, 1.0]</criterion>
  <criterion>decay_steering() multiplies by decay factor</criterion>
  <criterion>record_traversal() increments count and updates timestamp</criterion>
  <criterion>is_reliable_shortcut() checks: is_amortized=true, traversal>=3, reward>0.3, confidence>=0.7</criterion>
  <criterion>Default creates edge with nil UUIDs, Semantic type, General domain</criterion>
</validation_criteria>

<test_commands>
  <command>cargo build --package context-graph-core</command>
  <command>cargo test --package context-graph-core graph_edge -- --nocapture</command>
  <command>cargo clippy --package context-graph-core -- -D warnings</command>
</test_commands>
</task_spec>
```

## Implementation Notes

### Modulated Weight Formula
From the task specification:
```
modulated_weight = (nt_factor * (1 + steering_reward * 0.2)).clamp(0, 1)
```

Where `nt_factor = neurotransmitter_weights.compute_effective_weight(weight)`

### Reliable Shortcut Conditions
An edge is considered a reliable shortcut when all conditions are met:
1. `is_amortized_shortcut == true` - Was created during dream consolidation
2. `traversal_count >= 3` - Has been used multiple times
3. `steering_reward > 0.3` - Has received positive feedback
4. `confidence >= 0.7` - Has sufficient confidence

### Steering Subsystem Integration
The `steering_reward` field receives signals from:
- **Gardener**: Cross-session curation quality
- **Curator**: Per-domain content quality
- **Assessor**: Per-interaction quality

Per constitution.yaml:
```yaml
dopamine: { pos: "+=r×0.2", neg: "-=|r|×0.1" }
```

---

*Task ID: TASK-M02-011*
*Module: 02 - Core Infrastructure*
*Layer: Foundation*
