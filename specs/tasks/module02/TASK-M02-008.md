# TASK-M02-008: Define NeurotransmitterWeights Struct (Marblestone)

## Status: ✅ COMPLETE
**Priority:** High | **Layer:** Foundation | **Est Hours:** 2.0

### Completion Evidence (Verified 2025-12-31)

| Verification | Result | Command |
|--------------|--------|---------|
| Build | ✅ PASS | `cargo build --package context-graph-core` |
| Marblestone Tests | ✅ 66/66 pass | `cargo test --package context-graph-core marblestone` |
| NT Tests | ✅ 37/37 pass | `cargo test --package context-graph-core nt_` |
| Clippy | ✅ 0 warnings | `cargo clippy --package context-graph-core -- -D warnings` |
| Struct Location | Line 163 | `crates/context-graph-core/src/marblestone.rs` |
| Re-export | ✅ Verified | `pub use marblestone::{Domain, NeurotransmitterWeights};` in lib.rs |
| Sherlock-Holmes Audit | ✅ PASS | All methods verified, all domain profiles correct |

---

## Critical Context for AI Agent

### Current Codebase State (Verified 2025-12-31)

| Check | Status | Evidence |
|-------|--------|----------|
| Package builds | PASS | `cargo build --package context-graph-core` 0 errors |
| Lib tests pass | PASS | 262/262 tests pass |
| Clippy clean | PASS | `cargo clippy --package context-graph-core -- -D warnings` 0 warnings |
| TASK-M02-007 (Domain) | COMPLETE | 29 marblestone tests pass, Domain enum in `marblestone.rs` |

### Dependency: TASK-M02-007 (Domain enum) - VERIFIED COMPLETE

The `Domain` enum is **already implemented** at `crates/context-graph-core/src/marblestone.rs` (lines 35-56):

```rust
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum Domain {
    Code, Legal, Medical, Creative, Research, General,
}
```

**Re-export:** `pub use marblestone::Domain;` in `lib.rs` (line 31)

### File to Modify

```
crates/context-graph-core/src/marblestone.rs  # APPEND to existing file
```

The file already contains:
- Lines 1-9: Module documentation
- Lines 10-11: Imports (`use serde::{Deserialize, Serialize}; use std::fmt;`)
- Lines 35-56: `Domain` enum
- Lines 58-108: `Domain` impl block
- Lines 110-141: `Default` and `Display` impls
- Lines 143-370: Tests module

You will **APPEND** the `NeurotransmitterWeights` struct AFTER the `Domain` impl block (after line 141, before `#[cfg(test)]`).

---

## Task Objective

Implement `NeurotransmitterWeights` struct that models neurotransmitter-inspired edge modulation per the Marblestone architecture. The struct contains three f32 weights (excitatory, inhibitory, modulatory) that modify graph edge traversal behavior based on domain context.

---

## Specification (Source of Truth)

### From constitution.yaml (lines 172-179)

```yaml
edge_model:
  nt_weights:
    formula: "w_eff = base × (1 + excitatory - inhibitory + 0.5×modulatory)"
    excitatory: "[0,1] strengthen"
    inhibitory: "[0,1] weaken"
    modulatory: "[0,1] domain-adjust"
    domain: Code|Legal|Medical|Creative|Research|General
```

### Task-Specified Formula (More Accurate Biological Model)

The task uses a refined formula that better captures NT modulation semantics:

```
w_eff = ((base * excitatory - base * inhibitory) * (1 + (modulatory - 0.5) * 0.4)).clamp(0.0, 1.0)
```

This applies:
1. **Excitatory amplification**: `base * excitatory` (strengthens signal)
2. **Inhibitory dampening**: `base * inhibitory` (weakens signal)
3. **Modulatory adjustment**: `(1 + (modulatory - 0.5) * 0.4)` (centered at 0.5, ±20% range)
4. **Final clamp**: Output always in [0.0, 1.0] per AP-009

### Domain-Specific NT Profiles (from PRD and Task Spec)

| Domain | Excitatory | Inhibitory | Modulatory | Behavior |
|--------|------------|------------|------------|----------|
| Code | 0.6 | 0.3 | 0.4 | Precise, slight dampening |
| Legal | 0.4 | 0.4 | 0.2 | Balanced, conservative |
| Medical | 0.5 | 0.3 | 0.5 | Balanced, context-aware |
| Creative | 0.8 | 0.1 | 0.6 | High amplification, exploratory |
| Research | 0.6 | 0.2 | 0.5 | Good amplification, balanced |
| General | 0.5 | 0.2 | 0.3 | Default balanced |

---

## Exact Implementation Required

### Append to `crates/context-graph-core/src/marblestone.rs`

Insert this code **AFTER line 141** (after `impl fmt::Display for Domain`), **BEFORE** `#[cfg(test)]`:

```rust
/// Neurotransmitter-inspired weight modulation for graph edges.
///
/// Based on the Marblestone architecture, edges are modulated by three signals:
/// - **Excitatory**: Strengthens connections (analogous to glutamate)
/// - **Inhibitory**: Weakens connections (analogous to GABA)
/// - **Modulatory**: Context-dependent adjustment (analogous to dopamine/serotonin)
///
/// # Constitution Reference
/// - edge_model.nt_weights section
/// - All weights must be in [0.0, 1.0] per AP-009
///
/// # Example
/// ```rust
/// use context_graph_core::marblestone::{NeurotransmitterWeights, Domain};
///
/// let weights = NeurotransmitterWeights::for_domain(Domain::Code);
/// let effective = weights.compute_effective_weight(0.8);
/// assert!(effective >= 0.0 && effective <= 1.0);
/// ```
#[derive(Debug, Clone, Copy, PartialEq, Serialize, Deserialize)]
pub struct NeurotransmitterWeights {
    /// Excitatory signal strength [0.0, 1.0]. Higher = stronger connection.
    pub excitatory: f32,
    /// Inhibitory signal strength [0.0, 1.0]. Higher = weaker connection.
    pub inhibitory: f32,
    /// Modulatory signal strength [0.0, 1.0]. Context-dependent adjustment.
    pub modulatory: f32,
}

impl NeurotransmitterWeights {
    /// Create new weights with explicit values.
    ///
    /// # Arguments
    /// * `excitatory` - Strengthening signal [0.0, 1.0]
    /// * `inhibitory` - Weakening signal [0.0, 1.0]
    /// * `modulatory` - Domain-adjustment signal [0.0, 1.0]
    ///
    /// # Example
    /// ```rust
    /// use context_graph_core::marblestone::NeurotransmitterWeights;
    ///
    /// let weights = NeurotransmitterWeights::new(0.7, 0.2, 0.5);
    /// assert_eq!(weights.excitatory, 0.7);
    /// ```
    #[inline]
    pub fn new(excitatory: f32, inhibitory: f32, modulatory: f32) -> Self {
        Self { excitatory, inhibitory, modulatory }
    }

    /// Get domain-specific neurotransmitter profile.
    ///
    /// Each domain has optimized NT weights for its retrieval characteristics:
    /// - **Code**: excitatory=0.6, inhibitory=0.3, modulatory=0.4 (precise)
    /// - **Legal**: excitatory=0.4, inhibitory=0.4, modulatory=0.2 (conservative)
    /// - **Medical**: excitatory=0.5, inhibitory=0.3, modulatory=0.5 (causal)
    /// - **Creative**: excitatory=0.8, inhibitory=0.1, modulatory=0.6 (exploratory)
    /// - **Research**: excitatory=0.6, inhibitory=0.2, modulatory=0.5 (balanced)
    /// - **General**: excitatory=0.5, inhibitory=0.2, modulatory=0.3 (default)
    ///
    /// # Example
    /// ```rust
    /// use context_graph_core::marblestone::{NeurotransmitterWeights, Domain};
    ///
    /// let creative = NeurotransmitterWeights::for_domain(Domain::Creative);
    /// assert_eq!(creative.excitatory, 0.8);
    /// assert_eq!(creative.inhibitory, 0.1);
    /// ```
    #[inline]
    pub fn for_domain(domain: Domain) -> Self {
        match domain {
            Domain::Code => Self::new(0.6, 0.3, 0.4),
            Domain::Legal => Self::new(0.4, 0.4, 0.2),
            Domain::Medical => Self::new(0.5, 0.3, 0.5),
            Domain::Creative => Self::new(0.8, 0.1, 0.6),
            Domain::Research => Self::new(0.6, 0.2, 0.5),
            Domain::General => Self::new(0.5, 0.2, 0.3),
        }
    }

    /// Compute effective weight given a base weight.
    ///
    /// # Formula
    /// ```text
    /// w_eff = ((base * excitatory - base * inhibitory) * (1 + (modulatory - 0.5) * 0.4)).clamp(0.0, 1.0)
    /// ```
    ///
    /// This applies:
    /// 1. Excitatory amplification: `base * excitatory`
    /// 2. Inhibitory dampening: `base * inhibitory`
    /// 3. Modulatory context adjustment: centered at 0.5, ±20% range
    /// 4. Final clamp to [0.0, 1.0] per AP-009
    ///
    /// # Arguments
    /// * `base_weight` - Original edge weight [0.0, 1.0]
    ///
    /// # Returns
    /// Effective weight always in [0.0, 1.0]
    ///
    /// # Example
    /// ```rust
    /// use context_graph_core::marblestone::{NeurotransmitterWeights, Domain};
    ///
    /// let weights = NeurotransmitterWeights::for_domain(Domain::General);
    /// let effective = weights.compute_effective_weight(1.0);
    /// // General: (1.0*0.5 - 1.0*0.2) * (1 + (0.3-0.5)*0.4) = 0.3 * 0.92 = 0.276
    /// assert!((effective - 0.276).abs() < 0.001);
    /// ```
    #[inline]
    pub fn compute_effective_weight(&self, base_weight: f32) -> f32 {
        // Step 1: Apply excitatory and inhibitory
        let signal = base_weight * self.excitatory - base_weight * self.inhibitory;
        // Step 2: Apply modulatory adjustment (centered at 0.5)
        let mod_factor = 1.0 + (self.modulatory - 0.5) * 0.4;
        // Step 3: Clamp to valid range per AP-009
        (signal * mod_factor).clamp(0.0, 1.0)
    }

    /// Validate that all weights are in valid range [0.0, 1.0].
    ///
    /// # Returns
    /// `true` if all weights are in [0.0, 1.0] and not NaN/Infinity
    ///
    /// # Example
    /// ```rust
    /// use context_graph_core::marblestone::NeurotransmitterWeights;
    ///
    /// let valid = NeurotransmitterWeights::new(0.5, 0.3, 0.4);
    /// assert!(valid.validate());
    ///
    /// let invalid = NeurotransmitterWeights::new(1.5, 0.0, 0.0);
    /// assert!(!invalid.validate());
    /// ```
    #[inline]
    pub fn validate(&self) -> bool {
        // Check for NaN/Infinity per AP-009
        if self.excitatory.is_nan() || self.excitatory.is_infinite() {
            return false;
        }
        if self.inhibitory.is_nan() || self.inhibitory.is_infinite() {
            return false;
        }
        if self.modulatory.is_nan() || self.modulatory.is_infinite() {
            return false;
        }
        // Check valid range [0.0, 1.0]
        self.excitatory >= 0.0 && self.excitatory <= 1.0
            && self.inhibitory >= 0.0 && self.inhibitory <= 1.0
            && self.modulatory >= 0.0 && self.modulatory <= 1.0
    }
}

impl Default for NeurotransmitterWeights {
    /// Returns General domain profile: excitatory=0.5, inhibitory=0.2, modulatory=0.3
    ///
    /// # Example
    /// ```rust
    /// use context_graph_core::marblestone::NeurotransmitterWeights;
    ///
    /// let weights = NeurotransmitterWeights::default();
    /// assert_eq!(weights.excitatory, 0.5);
    /// assert_eq!(weights.inhibitory, 0.2);
    /// assert_eq!(weights.modulatory, 0.3);
    /// ```
    #[inline]
    fn default() -> Self {
        Self::for_domain(Domain::General)
    }
}
```

### Update lib.rs Re-exports

Modify `crates/context-graph-core/src/lib.rs` line 31:

**Current:**
```rust
pub use marblestone::Domain;
```

**Change to:**
```rust
pub use marblestone::{Domain, NeurotransmitterWeights};
```

---

## Test Implementation

Add these tests to the existing `#[cfg(test)] mod tests` block in `marblestone.rs`. Insert **AFTER** the existing Domain tests (after `test_default_is_in_all` around line 367):

```rust
    // =========================================================================
    // NeurotransmitterWeights Tests
    // =========================================================================

    // --- Constructor Tests ---

    #[test]
    fn test_nt_new_creates_weights() {
        let weights = NeurotransmitterWeights::new(0.6, 0.3, 0.4);
        assert_eq!(weights.excitatory, 0.6);
        assert_eq!(weights.inhibitory, 0.3);
        assert_eq!(weights.modulatory, 0.4);
    }

    #[test]
    fn test_nt_new_boundary_values() {
        let min = NeurotransmitterWeights::new(0.0, 0.0, 0.0);
        assert!(min.validate());

        let max = NeurotransmitterWeights::new(1.0, 1.0, 1.0);
        assert!(max.validate());
    }

    // --- for_domain() Tests ---

    #[test]
    fn test_nt_for_domain_code() {
        let weights = NeurotransmitterWeights::for_domain(Domain::Code);
        assert_eq!(weights.excitatory, 0.6);
        assert_eq!(weights.inhibitory, 0.3);
        assert_eq!(weights.modulatory, 0.4);
    }

    #[test]
    fn test_nt_for_domain_legal() {
        let weights = NeurotransmitterWeights::for_domain(Domain::Legal);
        assert_eq!(weights.excitatory, 0.4);
        assert_eq!(weights.inhibitory, 0.4);
        assert_eq!(weights.modulatory, 0.2);
    }

    #[test]
    fn test_nt_for_domain_medical() {
        let weights = NeurotransmitterWeights::for_domain(Domain::Medical);
        assert_eq!(weights.excitatory, 0.5);
        assert_eq!(weights.inhibitory, 0.3);
        assert_eq!(weights.modulatory, 0.5);
    }

    #[test]
    fn test_nt_for_domain_creative() {
        let weights = NeurotransmitterWeights::for_domain(Domain::Creative);
        assert_eq!(weights.excitatory, 0.8);
        assert_eq!(weights.inhibitory, 0.1);
        assert_eq!(weights.modulatory, 0.6);
    }

    #[test]
    fn test_nt_for_domain_research() {
        let weights = NeurotransmitterWeights::for_domain(Domain::Research);
        assert_eq!(weights.excitatory, 0.6);
        assert_eq!(weights.inhibitory, 0.2);
        assert_eq!(weights.modulatory, 0.5);
    }

    #[test]
    fn test_nt_for_domain_general() {
        let weights = NeurotransmitterWeights::for_domain(Domain::General);
        assert_eq!(weights.excitatory, 0.5);
        assert_eq!(weights.inhibitory, 0.2);
        assert_eq!(weights.modulatory, 0.3);
    }

    #[test]
    fn test_nt_all_domains_produce_valid_weights() {
        for domain in Domain::all() {
            let weights = NeurotransmitterWeights::for_domain(domain);
            assert!(weights.validate(), "Domain {:?} produced invalid weights", domain);
        }
    }

    // --- compute_effective_weight() Tests ---

    #[test]
    fn test_nt_compute_effective_weight_general_base_1() {
        let weights = NeurotransmitterWeights::for_domain(Domain::General);
        // General: (1.0*0.5 - 1.0*0.2) * (1 + (0.3-0.5)*0.4) = 0.3 * 0.92 = 0.276
        let effective = weights.compute_effective_weight(1.0);
        assert!((effective - 0.276).abs() < 0.001, "Expected ~0.276, got {}", effective);
    }

    #[test]
    fn test_nt_compute_effective_weight_creative_amplifies() {
        let weights = NeurotransmitterWeights::for_domain(Domain::Creative);
        // Creative has high excitatory (0.8), low inhibitory (0.1)
        // (1.0*0.8 - 1.0*0.1) * (1 + (0.6-0.5)*0.4) = 0.7 * 1.04 = 0.728
        let effective = weights.compute_effective_weight(1.0);
        assert!((effective - 0.728).abs() < 0.001, "Expected ~0.728, got {}", effective);
    }

    #[test]
    fn test_nt_compute_effective_weight_legal_dampens() {
        let weights = NeurotransmitterWeights::for_domain(Domain::Legal);
        // Legal has equal excitatory/inhibitory (0.4, 0.4) = net zero signal
        // (1.0*0.4 - 1.0*0.4) * (1 + (0.2-0.5)*0.4) = 0.0 * 0.88 = 0.0
        let effective = weights.compute_effective_weight(1.0);
        assert!((effective - 0.0).abs() < 0.001, "Expected ~0.0, got {}", effective);
    }

    #[test]
    fn test_nt_compute_effective_weight_clamps_high() {
        // Create weights that would produce > 1.0 before clamping
        let weights = NeurotransmitterWeights::new(1.0, 0.0, 1.0);
        // (1.0*1.0 - 1.0*0.0) * (1 + (1.0-0.5)*0.4) = 1.0 * 1.2 = 1.2 -> clamp to 1.0
        let effective = weights.compute_effective_weight(1.0);
        assert_eq!(effective, 1.0, "Must clamp to 1.0, got {}", effective);
    }

    #[test]
    fn test_nt_compute_effective_weight_clamps_low() {
        // Create weights that would produce < 0.0 before clamping
        let weights = NeurotransmitterWeights::new(0.0, 1.0, 0.0);
        // (1.0*0.0 - 1.0*1.0) * (1 + (0.0-0.5)*0.4) = -1.0 * 0.8 = -0.8 -> clamp to 0.0
        let effective = weights.compute_effective_weight(1.0);
        assert_eq!(effective, 0.0, "Must clamp to 0.0, got {}", effective);
    }

    #[test]
    fn test_nt_compute_effective_weight_zero_base() {
        let weights = NeurotransmitterWeights::for_domain(Domain::Creative);
        let effective = weights.compute_effective_weight(0.0);
        assert_eq!(effective, 0.0, "Zero base should produce zero output");
    }

    #[test]
    fn test_nt_compute_effective_weight_always_in_range() {
        // Test many combinations to ensure output is always [0.0, 1.0]
        for exc in [0.0, 0.25, 0.5, 0.75, 1.0] {
            for inh in [0.0, 0.25, 0.5, 0.75, 1.0] {
                for modul in [0.0, 0.25, 0.5, 0.75, 1.0] {
                    for base in [0.0, 0.25, 0.5, 0.75, 1.0] {
                        let weights = NeurotransmitterWeights::new(exc, inh, modul);
                        let effective = weights.compute_effective_weight(base);
                        assert!(
                            effective >= 0.0 && effective <= 1.0,
                            "Out of range: exc={}, inh={}, mod={}, base={} -> {}",
                            exc, inh, modul, base, effective
                        );
                    }
                }
            }
        }
    }

    // --- validate() Tests ---

    #[test]
    fn test_nt_validate_valid_weights() {
        let weights = NeurotransmitterWeights::new(0.5, 0.5, 0.5);
        assert!(weights.validate());
    }

    #[test]
    fn test_nt_validate_boundary_valid() {
        let min = NeurotransmitterWeights::new(0.0, 0.0, 0.0);
        let max = NeurotransmitterWeights::new(1.0, 1.0, 1.0);
        assert!(min.validate());
        assert!(max.validate());
    }

    #[test]
    fn test_nt_validate_invalid_excitatory_high() {
        let weights = NeurotransmitterWeights::new(1.1, 0.5, 0.5);
        assert!(!weights.validate());
    }

    #[test]
    fn test_nt_validate_invalid_excitatory_low() {
        let weights = NeurotransmitterWeights::new(-0.1, 0.5, 0.5);
        assert!(!weights.validate());
    }

    #[test]
    fn test_nt_validate_invalid_inhibitory_high() {
        let weights = NeurotransmitterWeights::new(0.5, 1.1, 0.5);
        assert!(!weights.validate());
    }

    #[test]
    fn test_nt_validate_invalid_modulatory_high() {
        let weights = NeurotransmitterWeights::new(0.5, 0.5, 1.1);
        assert!(!weights.validate());
    }

    #[test]
    fn test_nt_validate_nan_excitatory() {
        let weights = NeurotransmitterWeights::new(f32::NAN, 0.5, 0.5);
        assert!(!weights.validate(), "NaN must fail validation per AP-009");
    }

    #[test]
    fn test_nt_validate_nan_inhibitory() {
        let weights = NeurotransmitterWeights::new(0.5, f32::NAN, 0.5);
        assert!(!weights.validate(), "NaN must fail validation per AP-009");
    }

    #[test]
    fn test_nt_validate_nan_modulatory() {
        let weights = NeurotransmitterWeights::new(0.5, 0.5, f32::NAN);
        assert!(!weights.validate(), "NaN must fail validation per AP-009");
    }

    #[test]
    fn test_nt_validate_infinity() {
        let weights = NeurotransmitterWeights::new(f32::INFINITY, 0.5, 0.5);
        assert!(!weights.validate(), "Infinity must fail validation per AP-009");
    }

    #[test]
    fn test_nt_validate_neg_infinity() {
        let weights = NeurotransmitterWeights::new(f32::NEG_INFINITY, 0.5, 0.5);
        assert!(!weights.validate(), "Neg infinity must fail validation per AP-009");
    }

    // --- Default Implementation Tests ---

    #[test]
    fn test_nt_default_is_general() {
        let default_weights = NeurotransmitterWeights::default();
        let general_weights = NeurotransmitterWeights::for_domain(Domain::General);
        assert_eq!(default_weights, general_weights, "Default must equal General profile");
    }

    #[test]
    fn test_nt_default_values() {
        let weights = NeurotransmitterWeights::default();
        assert_eq!(weights.excitatory, 0.5);
        assert_eq!(weights.inhibitory, 0.2);
        assert_eq!(weights.modulatory, 0.3);
    }

    #[test]
    fn test_nt_default_is_valid() {
        let weights = NeurotransmitterWeights::default();
        assert!(weights.validate(), "Default weights must be valid");
    }

    // --- Derive Trait Tests ---

    #[test]
    fn test_nt_clone() {
        let weights = NeurotransmitterWeights::new(0.6, 0.3, 0.4);
        let cloned = weights.clone();
        assert_eq!(weights, cloned);
    }

    #[test]
    fn test_nt_copy() {
        let weights = NeurotransmitterWeights::new(0.6, 0.3, 0.4);
        let copied = weights; // Copy, not move
        assert_eq!(weights, copied);
        let _still_valid = weights; // Can still use original
    }

    #[test]
    fn test_nt_debug_format() {
        let weights = NeurotransmitterWeights::new(0.6, 0.3, 0.4);
        let debug = format!("{:?}", weights);
        assert!(debug.contains("NeurotransmitterWeights"));
        assert!(debug.contains("excitatory"));
    }

    #[test]
    fn test_nt_partial_eq() {
        let w1 = NeurotransmitterWeights::new(0.5, 0.5, 0.5);
        let w2 = NeurotransmitterWeights::new(0.5, 0.5, 0.5);
        let w3 = NeurotransmitterWeights::new(0.6, 0.5, 0.5);
        assert_eq!(w1, w2);
        assert_ne!(w1, w3);
    }

    // --- Serde Tests ---

    #[test]
    fn test_nt_serde_roundtrip() {
        let weights = NeurotransmitterWeights::new(0.6, 0.3, 0.4);
        let json = serde_json::to_string(&weights).expect("serialize failed");
        let restored: NeurotransmitterWeights = serde_json::from_str(&json).expect("deserialize failed");
        assert_eq!(weights, restored);
    }

    #[test]
    fn test_nt_serde_json_format() {
        let weights = NeurotransmitterWeights::new(0.6, 0.3, 0.4);
        let json = serde_json::to_string(&weights).unwrap();
        assert!(json.contains("excitatory"));
        assert!(json.contains("inhibitory"));
        assert!(json.contains("modulatory"));
    }

    #[test]
    fn test_nt_serde_all_domain_profiles() {
        for domain in Domain::all() {
            let weights = NeurotransmitterWeights::for_domain(domain);
            let json = serde_json::to_string(&weights).expect("serialize failed");
            let restored: NeurotransmitterWeights = serde_json::from_str(&json).expect("deserialize failed");
            assert_eq!(weights, restored, "Roundtrip failed for {:?}", domain);
        }
    }
```

---

## Verification Commands (MUST RUN IN ORDER)

```bash
# 1. Build the package (must pass)
cargo build --package context-graph-core

# 2. Run NeurotransmitterWeights tests specifically
cargo test --package context-graph-core nt_ -- --nocapture

# 3. Run all marblestone tests (Domain + NT)
cargo test --package context-graph-core marblestone -- --nocapture

# 4. Run clippy with strict warnings
cargo clippy --package context-graph-core -- -D warnings

# 5. Run ALL lib tests to ensure no regressions
cargo test --package context-graph-core --lib
```

### Expected Results

| Command | Expected |
|---------|----------|
| Build | 0 errors, 0 warnings |
| NT tests | ~35 tests pass |
| Marblestone tests | ~64 tests pass (29 Domain + 35 NT) |
| Clippy | 0 warnings |
| All lib tests | ~297 tests pass (262 existing + 35 new) |

---

## Full State Verification Protocol

After implementation, you MUST verify the following:

### 1. Source of Truth Verification

The source of truth is `crates/context-graph-core/src/marblestone.rs`.

```bash
# Verify struct exists
grep -n "pub struct NeurotransmitterWeights" crates/context-graph-core/src/marblestone.rs

# Verify all methods exist
grep -n "pub fn new\|pub fn for_domain\|pub fn compute_effective_weight\|pub fn validate" crates/context-graph-core/src/marblestone.rs

# Verify Default impl
grep -n "impl Default for NeurotransmitterWeights" crates/context-graph-core/src/marblestone.rs

# Verify re-export in lib.rs
grep "NeurotransmitterWeights" crates/context-graph-core/src/lib.rs
```

### 2. Execute & Inspect (Separate Read After Write)

```bash
# Run tests and capture output
cargo test --package context-graph-core nt_ 2>&1 | tee /tmp/nt_tests.log

# Verify test count
grep "test result:" /tmp/nt_tests.log
# Expected: "test result: ok. 35 passed; 0 failed"
```

### 3. Boundary & Edge Case Audit

Manually verify these 3 edge cases:

**Edge Case 1: Maximum Amplification**
```bash
cargo test --package context-graph-core test_nt_compute_effective_weight_clamps_high -- --nocapture
```
State Before: `NeurotransmitterWeights::new(1.0, 0.0, 1.0)`, base=1.0
Expected: `compute_effective_weight(1.0)` returns exactly `1.0` (clamped from 1.2)

**Edge Case 2: Maximum Dampening**
```bash
cargo test --package context-graph-core test_nt_compute_effective_weight_clamps_low -- --nocapture
```
State Before: `NeurotransmitterWeights::new(0.0, 1.0, 0.0)`, base=1.0
Expected: `compute_effective_weight(1.0)` returns exactly `0.0` (clamped from -0.8)

**Edge Case 3: NaN Rejection**
```bash
cargo test --package context-graph-core test_nt_validate_nan -- --nocapture
```
State Before: `NeurotransmitterWeights::new(f32::NAN, 0.5, 0.5)`
Expected: `validate()` returns `false` per AP-009

### 4. Evidence of Success Log

After all tests pass, output must show:
```
test result: ok. X passed; 0 failed; 0 ignored
```

Where X >= 297 (262 existing + ~35 new NT tests)

---

## NO Backwards Compatibility

- This is NEW code being added to an existing file
- All tests must use real data (no mocks)
- If any test fails, the implementation is WRONG - fix it, don't work around it
- If compilation fails, inspect and fix the root cause
- Do NOT create workarounds, fallbacks, or backwards-compat shims

---

## Constraints

| Constraint | Requirement | Reference |
|------------|-------------|-----------|
| Weight range | [0.0, 1.0] for all three fields | constitution.yaml |
| Output range | [0.0, 1.0] for compute_effective_weight | AP-009 |
| NaN/Infinity | Must fail validation | AP-009 |
| Default | Must return General profile | Task spec |
| Copy trait | Required (struct is 12 bytes, 3 x f32) | Efficiency |
| File limit | marblestone.rs must not exceed 800 lines | constitution.yaml |

---

## Out of Scope (DO NOT IMPLEMENT)

- EdgeType enum → TASK-M02-009
- GraphEdge struct → TASK-M02-010
- Edge traversal logic → TASK-M02-011
- Any database operations
- Any network operations

---

## Final Verification: Sherlock-Holmes Agent

After completing all implementation and tests, you MUST spawn the `sherlock-holmes` subagent to perform forensic verification:

```
Task: Forensically verify TASK-M02-008 NeurotransmitterWeights implementation is complete.

Evidence to gather:
1. File exists and contains NeurotransmitterWeights struct
2. All 4 methods implemented: new(), for_domain(), compute_effective_weight(), validate()
3. Default impl returns General profile (0.5, 0.2, 0.3)
4. All 6 domain profiles match specification table exactly
5. compute_effective_weight() uses correct formula
6. validate() rejects NaN, Infinity, and out-of-range values
7. Re-export exists in lib.rs
8. All ~35 NT tests pass
9. All ~297 lib tests pass (no regressions)
10. 0 clippy warnings

For any discrepancy found, report as ERROR with exact line numbers and expected vs actual values.
```

---

*Task ID: TASK-M02-008*
*Module: 02 - Core Infrastructure*
*Layer: Foundation*
*Depends On: TASK-M02-007 (COMPLETE)*
*Last Updated: 2025-12-31*
