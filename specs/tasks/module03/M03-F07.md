# Task Specification: M03-F07 - InputType Enum

## Task Metadata
| Field | Value |
|-------|-------|
| **Task ID** | M03-F07 |
| **Title** | Define InputType Enum for Model Compatibility |
| **Status** | ready |
| **Layer** | Foundation |
| **Sequence** | 7 |
| **Implements** | `constitution.yaml: embeddings.model_compatibility` |
| **Dependencies** | **NONE** (standalone enum, but must be designed to work with M03-F06 ModelInput) |
| **Estimated Hours** | 0.5 |
| **Updated** | 2026-01-01 |

---

## Critical Context

### What This Task IS
`InputType` is a **SIMPLE enum** used to describe input **capabilities** (what types of input a model supports). It does NOT carry data.

### What This Task IS NOT
- NOT the same as `ModelInput` (M03-F06) which carries actual data payloads
- NOT a complex type - it's 4 simple variants with no data

### Why This Task Exists
The 12-model embedding pipeline has models that support different input types:
- Some models handle Text+Code but not Image/Audio
- E10 (Multimodal/CLIP) handles Text+Image but not Code
- This enum enables:
  1. Routing inputs to compatible models
  2. Early rejection of unsupported input types
  3. Querying model capabilities via `HashSet<InputType>`

---

## Current Codebase State (VERIFIED 2026-01-01)

### Existing Files
```
crates/context-graph-embeddings/src/
├── lib.rs              # Crate root (exports types::ModelId, etc.)
├── error.rs            # EmbeddingError enum (InvalidInput, ModelLoadError, etc.)
├── provider.rs         # EmbeddingProvider trait
├── stub.rs             # StubEmbedder for Phase 0
└── types/
    ├── mod.rs          # Re-exports (ModelId, ModelInput, ImageFormat, etc.)
    ├── model_id.rs     # M03-F01: ModelId enum (12 models + TokenizerFamily)
    ├── dimensions.rs   # M03-F02: Dimension constants
    ├── embedding.rs    # M03-F03: ModelEmbedding struct
    ├── concatenated.rs # M03-F04: ConcatenatedEmbedding struct
    ├── fused.rs        # M03-F05: FusedEmbedding struct
    └── input.rs        # M03-F06: ModelInput enum + ImageFormat (EXISTS, needs InputType added)
```

### What `input.rs` Currently Contains (M03-F06)
- `ImageFormat` enum: `Png`, `Jpeg`, `WebP`, `Gif` (with magic byte detection)
- `ModelInput` enum: `Text`, `Code`, `Image`, `Audio` (with data payloads)
- Does NOT contain `InputType` - **this task creates it**

### mod.rs Current State
```rust
pub use input::{ImageFormat, ModelInput};
```
**After this task:**
```rust
pub use input::{ImageFormat, InputType, ModelInput};
```

---

## Exact Implementation Required

### File: `crates/context-graph-embeddings/src/types/input.rs`

Add the following code **AFTER** the `ModelInput` implementation (around line 611, before `#[cfg(test)]`):

```rust
/// Input type capability descriptor for model compatibility checking.
///
/// Unlike `ModelInput` which carries actual data, `InputType` is a simple
/// discriminator used to:
/// - Query what input types a model supports
/// - Route inputs to compatible models
/// - Reject unsupported inputs early (fail-fast)
///
/// # Model Compatibility Matrix
///
/// | Model | Text | Code | Image | Audio |
/// |-------|------|------|-------|-------|
/// | Semantic (E1) | ✓ | ✓* | ✗ | ✗ |
/// | TemporalRecent (E2) | ✓ | ✓ | ✗ | ✗ |
/// | TemporalPeriodic (E3) | ✓ | ✓ | ✗ | ✗ |
/// | TemporalPositional (E4) | ✓ | ✓ | ✗ | ✗ |
/// | Causal (E5) | ✓ | ✓ | ✗ | ✗ |
/// | Sparse (E6) | ✓ | ✓* | ✗ | ✗ |
/// | Code (E7) | ✓* | ✓ | ✗ | ✗ |
/// | Graph (E8) | ✓ | ✓* | ✗ | ✗ |
/// | HDC (E9) | ✓ | ✓ | ✗ | ✗ |
/// | Multimodal (E10) | ✓ | ✗ | ✓ | ✗ |
/// | Entity (E11) | ✓ | ✓* | ✗ | ✗ |
/// | LateInteraction (E12) | ✓ | ✓* | ✗ | ✗ |
///
/// *Model can process but is not optimized for this type
///
/// # Example
///
/// ```rust
/// use context_graph_embeddings::types::{InputType, ModelInput};
/// use std::collections::HashSet;
///
/// // Query input type from ModelInput
/// let input = ModelInput::text("Hello").unwrap();
/// let input_type = InputType::from(&input);
/// assert_eq!(input_type, InputType::Text);
///
/// // Use in HashSet for model capability checking
/// let mut supported: HashSet<InputType> = HashSet::new();
/// supported.insert(InputType::Text);
/// supported.insert(InputType::Code);
/// assert!(supported.contains(&InputType::Text));
/// assert!(!supported.contains(&InputType::Image));
///
/// // Check all variants
/// for input_type in InputType::all() {
///     println!("Type: {}", input_type);
/// }
/// ```
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[repr(u8)]
pub enum InputType {
    /// Text content (natural language, documents, queries)
    Text = 0,
    /// Source code with language metadata
    Code = 1,
    /// Image data (PNG, JPEG, WebP, GIF)
    Image = 2,
    /// Audio data (PCM, encoded)
    Audio = 3,
}

impl InputType {
    /// Returns a static slice containing all InputType variants.
    ///
    /// Useful for iteration when checking model compatibility across all types.
    ///
    /// # Returns
    /// Static slice with all 4 variants in discriminant order.
    ///
    /// # Example
    ///
    /// ```rust
    /// use context_graph_embeddings::types::InputType;
    ///
    /// let all_types = InputType::all();
    /// assert_eq!(all_types.len(), 4);
    /// assert_eq!(all_types[0], InputType::Text);
    /// ```
    #[must_use]
    pub const fn all() -> &'static [InputType] {
        &[
            InputType::Text,
            InputType::Code,
            InputType::Image,
            InputType::Audio,
        ]
    }

    /// Returns the discriminant value (0-3).
    ///
    /// Matches the `#[repr(u8)]` values for binary serialization.
    #[must_use]
    pub const fn discriminant(&self) -> u8 {
        *self as u8
    }
}

impl std::fmt::Display for InputType {
    /// Displays lowercase type name: "text", "code", "image", "audio".
    ///
    /// This format is used in error messages, logging, and configuration.
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let name = match self {
            Self::Text => "text",
            Self::Code => "code",
            Self::Image => "image",
            Self::Audio => "audio",
        };
        write!(f, "{}", name)
    }
}

impl From<&ModelInput> for InputType {
    /// Converts a ModelInput reference to its corresponding InputType.
    ///
    /// This is the primary bridge between the data-carrying `ModelInput`
    /// and the capability-describing `InputType`.
    ///
    /// # Example
    ///
    /// ```rust
    /// use context_graph_embeddings::types::{InputType, ModelInput, ImageFormat};
    ///
    /// let text = ModelInput::text("Hello").unwrap();
    /// assert_eq!(InputType::from(&text), InputType::Text);
    ///
    /// let code = ModelInput::code("fn main() {}", "rust").unwrap();
    /// assert_eq!(InputType::from(&code), InputType::Code);
    ///
    /// let image = ModelInput::image(vec![1,2,3], ImageFormat::Png).unwrap();
    /// assert_eq!(InputType::from(&image), InputType::Image);
    ///
    /// let audio = ModelInput::audio(vec![1,2,3], 16000, 1).unwrap();
    /// assert_eq!(InputType::from(&audio), InputType::Audio);
    /// ```
    fn from(input: &ModelInput) -> Self {
        match input {
            ModelInput::Text { .. } => InputType::Text,
            ModelInput::Code { .. } => InputType::Code,
            ModelInput::Image { .. } => InputType::Image,
            ModelInput::Audio { .. } => InputType::Audio,
        }
    }
}
```

### File: `crates/context-graph-embeddings/src/types/mod.rs`

**UPDATE** the re-export line to include `InputType`:

**Before:**
```rust
pub use input::{ImageFormat, ModelInput};
```

**After:**
```rust
pub use input::{ImageFormat, InputType, ModelInput};
```

---

## Tests Required

Add these tests inside the `#[cfg(test)] mod tests` block in `input.rs`:

```rust
    // ============================================================
    // INPUT TYPE TESTS (M03-F07)
    // ============================================================

    #[test]
    fn test_input_type_from_model_input_text() {
        println!("BEFORE: Creating ModelInput::Text");
        let input = ModelInput::text("Hello").unwrap();
        println!("AFTER: Created input = {:?}", input);

        let input_type = InputType::from(&input);
        println!("RESULT: InputType = {:?}", input_type);

        assert_eq!(input_type, InputType::Text);
    }

    #[test]
    fn test_input_type_from_model_input_code() {
        println!("BEFORE: Creating ModelInput::Code");
        let input = ModelInput::code("fn main() {}", "rust").unwrap();
        println!("AFTER: Created input = {:?}", input);

        let input_type = InputType::from(&input);
        println!("RESULT: InputType = {:?}", input_type);

        assert_eq!(input_type, InputType::Code);
    }

    #[test]
    fn test_input_type_from_model_input_image() {
        println!("BEFORE: Creating ModelInput::Image");
        let input = ModelInput::image(vec![1, 2, 3, 4], ImageFormat::Png).unwrap();
        println!("AFTER: Created input = {:?}", input);

        let input_type = InputType::from(&input);
        println!("RESULT: InputType = {:?}", input_type);

        assert_eq!(input_type, InputType::Image);
    }

    #[test]
    fn test_input_type_from_model_input_audio() {
        println!("BEFORE: Creating ModelInput::Audio");
        let input = ModelInput::audio(vec![1, 2, 3, 4], 16000, 1).unwrap();
        println!("AFTER: Created input = {:?}", input);

        let input_type = InputType::from(&input);
        println!("RESULT: InputType = {:?}", input_type);

        assert_eq!(input_type, InputType::Audio);
    }

    #[test]
    fn test_input_type_display_lowercase() {
        assert_eq!(format!("{}", InputType::Text), "text");
        assert_eq!(format!("{}", InputType::Code), "code");
        assert_eq!(format!("{}", InputType::Image), "image");
        assert_eq!(format!("{}", InputType::Audio), "audio");
    }

    #[test]
    fn test_input_type_all_returns_4_variants() {
        let all = InputType::all();
        assert_eq!(all.len(), 4);
        assert_eq!(all[0], InputType::Text);
        assert_eq!(all[1], InputType::Code);
        assert_eq!(all[2], InputType::Image);
        assert_eq!(all[3], InputType::Audio);
    }

    #[test]
    fn test_input_type_can_be_used_as_hashmap_key() {
        use std::collections::HashMap;

        let mut map: HashMap<InputType, &str> = HashMap::new();
        map.insert(InputType::Text, "text_value");
        map.insert(InputType::Code, "code_value");
        map.insert(InputType::Image, "image_value");
        map.insert(InputType::Audio, "audio_value");

        assert_eq!(map.get(&InputType::Text), Some(&"text_value"));
        assert_eq!(map.get(&InputType::Code), Some(&"code_value"));
        assert_eq!(map.get(&InputType::Image), Some(&"image_value"));
        assert_eq!(map.get(&InputType::Audio), Some(&"audio_value"));
    }

    #[test]
    fn test_input_type_can_be_used_in_hashset() {
        use std::collections::HashSet;

        let mut set: HashSet<InputType> = HashSet::new();
        set.insert(InputType::Text);
        set.insert(InputType::Code);

        assert!(set.contains(&InputType::Text));
        assert!(set.contains(&InputType::Code));
        assert!(!set.contains(&InputType::Image));
        assert!(!set.contains(&InputType::Audio));
    }

    #[test]
    fn test_input_type_copy_semantics() {
        let original = InputType::Text;
        let copied = original; // Copy, not move
        assert_eq!(original, copied); // Both still valid
    }

    #[test]
    fn test_input_type_serde_roundtrip() {
        for input_type in InputType::all() {
            let json = serde_json::to_string(input_type).unwrap();
            let recovered: InputType = serde_json::from_str(&json).unwrap();
            assert_eq!(*input_type, recovered);
            println!("Serialized {:?} as {} and recovered successfully", input_type, json);
        }
    }

    #[test]
    fn test_input_type_discriminant_values() {
        assert_eq!(InputType::Text.discriminant(), 0);
        assert_eq!(InputType::Code.discriminant(), 1);
        assert_eq!(InputType::Image.discriminant(), 2);
        assert_eq!(InputType::Audio.discriminant(), 3);
    }

    #[test]
    fn test_input_type_debug_formatting() {
        // Debug should show variant name
        assert_eq!(format!("{:?}", InputType::Text), "Text");
        assert_eq!(format!("{:?}", InputType::Code), "Code");
        assert_eq!(format!("{:?}", InputType::Image), "Image");
        assert_eq!(format!("{:?}", InputType::Audio), "Audio");
    }
```

---

## Validation Commands

### Build Check
```bash
cd /home/cabdru/contextgraph
cargo check -p context-graph-embeddings
```
**Expected:** No errors, clean compilation

### Run Tests
```bash
cd /home/cabdru/contextgraph
cargo test -p context-graph-embeddings input_type -- --nocapture
```
**Expected:** All 13 `input_type_*` tests pass with BEFORE/AFTER logging visible

### Full Module Tests
```bash
cargo test -p context-graph-embeddings
```
**Expected:** All existing tests + new tests pass (previous: 120 tests, after: 133 tests)

---

## Full State Verification Protocol

### Source of Truth
- **Type Definition:** `crates/context-graph-embeddings/src/types/input.rs`
- **Re-export:** `crates/context-graph-embeddings/src/types/mod.rs`
- **Test Results:** `cargo test` output

### Verification Steps

1. **Compile Check:**
   ```bash
   cargo check -p context-graph-embeddings 2>&1 | head -20
   ```
   Must show: `Finished` with no errors

2. **Type Existence Verification:**
   ```bash
   grep -n "pub enum InputType" crates/context-graph-embeddings/src/types/input.rs
   ```
   Must show line number where `InputType` is defined

3. **Re-export Verification:**
   ```bash
   grep "InputType" crates/context-graph-embeddings/src/types/mod.rs
   ```
   Must show `InputType` in the `pub use` statement

4. **Test Execution with Evidence:**
   ```bash
   cargo test -p context-graph-embeddings input_type -- --nocapture 2>&1 | tee /tmp/input_type_tests.log
   ```
   Must show all tests pass + BEFORE/AFTER logs

5. **Hash/Set Functionality Proof:**
   The tests `test_input_type_can_be_used_as_hashmap_key` and `test_input_type_can_be_used_in_hashset` prove HashMap/HashSet compatibility

6. **From Conversion Proof:**
   The tests `test_input_type_from_model_input_*` prove all 4 `From<&ModelInput>` conversions work

### Edge Cases to Verify

| Edge Case | Test | Expected Behavior |
|-----------|------|-------------------|
| Empty input | N/A | InputType has no empty state |
| Maximum variants | `test_input_type_all_returns_4_variants` | Exactly 4 variants |
| Copy semantics | `test_input_type_copy_semantics` | Copy works, original still valid |
| Serde round-trip | `test_input_type_serde_roundtrip` | JSON serialize/deserialize preserves value |

---

## Constraints (MUST Follow)

1. **NO FALLBACKS:** If `From<&ModelInput>` fails to match a variant, it's a compile error (exhaustive match)
2. **NO MOCK DATA:** Tests use real `ModelInput` instances, not mocked data
3. **NO BACKWARDS COMPATIBILITY HACKS:** The enum is new, no legacy concerns
4. **Copy Required:** Must derive `Copy` for efficient passing
5. **Hash Required:** Must derive `Hash` for use in `HashSet`/`HashMap`
6. **Display Lowercase:** `Display` must produce `"text"`, `"code"`, `"image"`, `"audio"`

---

## Anti-Patterns (FORBIDDEN)

- ❌ Using `Default` derive (no sensible default input type)
- ❌ Adding data fields to variants (this is a discriminator, not a carrier)
- ❌ Using `unwrap()` in production code
- ❌ Allowing `InputType` construction from arbitrary u8 values (only via `From<&ModelInput>`)

---

## Definition of Done Checklist

- [ ] `InputType` enum added to `input.rs` with 4 variants
- [ ] `From<&ModelInput>` implemented with exhaustive match
- [ ] `Display` implemented producing lowercase names
- [ ] `all()` static method returns all 4 variants
- [ ] `discriminant()` method returns u8 value
- [ ] Re-export added to `types/mod.rs`
- [ ] 13 unit tests pass
- [ ] `cargo check` passes
- [ ] `cargo test` passes (all existing + new)
- [ ] BEFORE/AFTER logs visible in test output

---

## Final Verification: Sherlock-Holmes Protocol

After implementation, invoke the `sherlock-holmes` subagent with:
```
Task: Verify M03-F07 InputType implementation is complete and correct.

Evidence Required:
1. Grep for "pub enum InputType" in input.rs - show line number
2. Grep for "impl From<&ModelInput> for InputType" - show the match arms
3. Grep for "InputType" in mod.rs - confirm re-export
4. Run cargo test -p context-graph-embeddings input_type -- --nocapture
5. Show the test output with pass/fail counts
6. Verify Display produces lowercase: run a test that prints format!("{}", InputType::Text)
7. Confirm NO compilation warnings related to InputType
```

The Sherlock-Holmes agent must confirm:
- Type exists and compiles
- All 4 From conversions work
- Display produces lowercase
- HashSet/HashMap usage works
- All 13 tests pass
