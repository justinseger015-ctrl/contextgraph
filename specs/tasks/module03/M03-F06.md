# Task Specification: M03-F06

```xml
<task_spec id="M03-F06" version="2.1">
<metadata>
  <title>Define ModelInput Enum for Multi-Modal Inputs</title>
  <status>COMPLETE</status>
  <layer>foundation</layer>
  <sequence>6</sequence>
  <implements>constitution.yaml: embeddings.input_types (L1_Sensing layer)</implements>
  <depends_on>
    <dep id="M03-F01" status="COMPLETE">ModelId enum - crates/context-graph-embeddings/src/types/model_id.rs</dep>
    <dep id="M03-F08" status="REQUIRED">EmbeddingError enum - crates/context-graph-embeddings/src/error.rs (EXISTS)</dep>
  </depends_on>
  <estimated_hours>2</estimated_hours>
</metadata>

<codebase_state>
  CRITICAL CONTEXT FOR IMPLEMENTATION:

  1. EXISTING FILES - DO NOT RECREATE:
     - crates/context-graph-embeddings/src/error.rs (EmbeddingError enum EXISTS)
     - crates/context-graph-embeddings/src/types/model_id.rs (ModelId enum EXISTS)
     - crates/context-graph-embeddings/src/types/dimensions.rs (dimension constants EXIST)
     - crates/context-graph-embeddings/src/types/mod.rs (module exports)
     - crates/context-graph-embeddings/src/lib.rs (crate root)

  2. EXISTING ERROR VARIANTS (from error.rs):
     - EmbeddingError::InvalidInput(String) - use for empty content, invalid format
     - EmbeddingError::InvalidVector(String) - use for NaN/Inf if applicable
     - EmbeddingError::SerializationError(String) - use for hash/binary issues

  3. EXISTING MODEL IDS (from model_id.rs):
     - ModelId::Semantic (E1) - text only
     - ModelId::TemporalRecent (E2) - timestamp metadata
     - ModelId::TemporalPeriodic (E3) - timestamp metadata
     - ModelId::TemporalPositional (E4) - sequence position
     - ModelId::Causal (E5) - text only
     - ModelId::Sparse (E6) - text only
     - ModelId::Code (E7) - code with language
     - ModelId::Graph (E8) - text only
     - ModelId::Hdc (E9) - text only
     - ModelId::Multimodal (E10) - text OR image
     - ModelId::Entity (E11) - text only
     - ModelId::LateInteraction (E12) - text only

  4. GIT HISTORY (recent):
     - 9a55897 feat(embeddings): implement M03-F04 ConcatenatedEmbedding
     - 972e36a feat(embeddings): implement M03-F03 ModelEmbedding
     - ad821df feat(embeddings): implement M03-F02 dimensions
     - e1805de feat(embeddings): implement M03-F01 ModelId

  5. ALL TESTS PASSING: 153 total tests in context-graph-embeddings
</codebase_state>

<context>
ModelInput is an enum representing different input modalities for the embedding pipeline.
It wraps raw content (text, code, image, audio) with metadata needed for processing.

This is part of the L1_Sensing layer (constitution.yaml) which handles:
- Input normalization and validation
- Content hashing for cache keys
- Multi-modal support for the 12-model pipeline

Key design decisions:
- Text: plain content + optional instruction prefix (for e5-style models)
- Code: source code + language identifier (for CodeBERT/CodeT5p)
- Image: raw bytes + format (for CLIP multimodal)
- Audio: raw bytes + sample_rate + channels (for future audio models)

The content_hash() method provides deterministic hashing for cache lookups.
The byte_size() method enables memory tracking for the MemoryTracker (M03-L02).
</context>

<design_principles>
  NO BACKWARDS COMPATIBILITY - fail fast, no fallbacks
  NO MOCK DATA - all tests use real computed values
  EMPTY CONTENT = ERROR - validation failures are fatal
  USE EXISTING ERRORS - EmbeddingError from error.rs
  USE XXHASH - xxhash_rust::xxh64 for content_hash()
</design_principles>

<definition_of_done>
  <signatures>
```rust
//! Multi-modal input types for the embedding pipeline.
//!
//! ModelInput provides a unified interface for passing different types of content
//! to the embedding models, allowing each model to handle inputs it supports.

use crate::error::{EmbeddingError, EmbeddingResult};
use serde::{Deserialize, Serialize};
use xxhash_rust::xxh64::xxh64;

/// Image format for binary image inputs.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum ImageFormat {
    Png,
    Jpeg,
    WebP,
    Gif,
}

/// Multi-modal input for embedding models.
///
/// Each variant carries the data needed for that input type:
/// - Text: content string with optional instruction prefix (for e5-style models)
/// - Code: source code with language identifier
/// - Image: raw bytes with format information
/// - Audio: raw bytes with sample rate and channel count
///
/// # Example
/// ```rust
/// use context_graph_embeddings::types::ModelInput;
///
/// let text_input = ModelInput::text("Hello, world!");
/// let code_input = ModelInput::code("fn main() {}", "rust");
/// ```
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum ModelInput {
    /// Text content with optional instruction prefix.
    /// Instruction is prepended for e5-style models (e.g., "query: " or "passage: ").
    Text {
        content: String,
        instruction: Option<String>,
    },
    /// Source code with programming language identifier.
    /// Language should be lowercase (e.g., "rust", "python", "javascript").
    Code {
        content: String,
        language: String,
    },
    /// Image bytes with format information.
    /// Bytes must be valid encoded image data (not raw pixels).
    Image {
        bytes: Vec<u8>,
        format: ImageFormat,
    },
    /// Audio bytes with sample metadata.
    /// sample_rate in Hz (e.g., 16000, 44100).
    /// channels: 1 = mono, 2 = stereo.
    Audio {
        bytes: Vec<u8>,
        sample_rate: u32,
        channels: u8,
    },
}

impl ModelInput {
    /// Create a text input.
    ///
    /// # Errors
    /// Returns `EmbeddingError::InvalidInput` if content is empty.
    pub fn text(content: impl Into<String>) -> EmbeddingResult<Self>;

    /// Create a text input with instruction prefix.
    ///
    /// # Errors
    /// Returns `EmbeddingError::InvalidInput` if content is empty.
    pub fn text_with_instruction(
        content: impl Into<String>,
        instruction: impl Into<String>,
    ) -> EmbeddingResult<Self>;

    /// Create a code input.
    ///
    /// # Errors
    /// Returns `EmbeddingError::InvalidInput` if content or language is empty.
    pub fn code(content: impl Into<String>, language: impl Into<String>) -> EmbeddingResult<Self>;

    /// Create an image input.
    ///
    /// # Errors
    /// Returns `EmbeddingError::InvalidInput` if bytes is empty.
    pub fn image(bytes: Vec<u8>, format: ImageFormat) -> EmbeddingResult<Self>;

    /// Create an audio input.
    ///
    /// # Errors
    /// Returns `EmbeddingError::InvalidInput` if:
    /// - bytes is empty
    /// - sample_rate is 0
    /// - channels is not 1 or 2
    pub fn audio(bytes: Vec<u8>, sample_rate: u32, channels: u8) -> EmbeddingResult<Self>;

    /// Compute xxHash64 of the content for cache keying.
    ///
    /// Hash includes all content bytes:
    /// - Text: UTF-8 bytes of content + instruction if present
    /// - Code: UTF-8 bytes of content + language
    /// - Image: raw bytes + format discriminant
    /// - Audio: raw bytes + sample_rate + channels
    pub fn content_hash(&self) -> u64;

    /// Calculate total memory size in bytes.
    ///
    /// Includes heap allocations for strings and byte vectors.
    pub fn byte_size(&self) -> usize;

    /// Returns true if this is a Text variant.
    pub fn is_text(&self) -> bool;

    /// Returns true if this is a Code variant.
    pub fn is_code(&self) -> bool;

    /// Returns true if this is an Image variant.
    pub fn is_image(&self) -> bool;

    /// Returns true if this is an Audio variant.
    pub fn is_audio(&self) -> bool;

    /// Get text content if this is a Text variant.
    pub fn as_text(&self) -> Option<(&str, Option<&str>)>;

    /// Get code content if this is a Code variant.
    pub fn as_code(&self) -> Option<(&str, &str)>;

    /// Get image bytes if this is an Image variant.
    pub fn as_image(&self) -> Option<(&[u8], ImageFormat)>;

    /// Get audio bytes if this is an Audio variant.
    pub fn as_audio(&self) -> Option<(&[u8], u32, u8)>;
}

impl ImageFormat {
    /// Get MIME type for this image format.
    pub fn mime_type(&self) -> &'static str;

    /// Get file extension for this image format.
    pub fn extension(&self) -> &'static str;

    /// Try to detect format from magic bytes.
    /// Returns None if format cannot be detected.
    pub fn detect(bytes: &[u8]) -> Option<Self>;
}
```
  </signatures>

  <constraints>
    <constraint>text() MUST reject empty content with EmbeddingError::InvalidInput</constraint>
    <constraint>code() MUST reject empty content OR empty language with EmbeddingError::InvalidInput</constraint>
    <constraint>image() MUST reject empty bytes with EmbeddingError::InvalidInput</constraint>
    <constraint>audio() MUST reject empty bytes, sample_rate=0, channels not in [1,2]</constraint>
    <constraint>content_hash() MUST be deterministic for identical inputs</constraint>
    <constraint>content_hash() MUST differ for different inputs</constraint>
    <constraint>byte_size() MUST include heap allocation for Vec<u8> and String</constraint>
    <constraint>Use xxhash_rust::xxh64 crate (add to Cargo.toml if needed)</constraint>
    <constraint>ImageFormat::detect() MUST use magic bytes, not file extension</constraint>
    <constraint>NO fallbacks - validation failures return Err immediately</constraint>
  </constraints>
</definition_of_done>

<files_to_create>
  <file path="crates/context-graph-embeddings/src/types/input.rs">
    Main implementation file for ModelInput enum and ImageFormat
  </file>
</files_to_create>

<files_to_modify>
  <file path="crates/context-graph-embeddings/src/types/mod.rs">
    Add: mod input;
    Add: pub use input::{ModelInput, ImageFormat};
  </file>
  <file path="crates/context-graph-embeddings/Cargo.toml">
    Add xxhash-rust dependency if not present:
    xxhash-rust = { version = "0.8", features = ["xxh64"] }
  </file>
</files_to_modify>

<supported_languages>
The language field in Code variant should accept these common identifiers:
- rust, python, javascript, typescript
- java, kotlin, scala
- go, c, cpp, csharp
- ruby, php, swift
- sql, html, css, json, yaml, toml
- bash, powershell
- markdown, plaintext

Language validation is NOT required - any string is accepted.
The list above is for documentation only.
</supported_languages>

<hash_implementation>
Use xxhash_rust::xxh64 for all content hashing:

```rust
use xxhash_rust::xxh64::xxh64;

fn content_hash(&self) -> u64 {
    match self {
        Self::Text { content, instruction } => {
            let mut data = content.as_bytes().to_vec();
            if let Some(inst) = instruction {
                data.extend_from_slice(inst.as_bytes());
            }
            xxh64(&data, 0)
        }
        Self::Code { content, language } => {
            let mut data = content.as_bytes().to_vec();
            data.extend_from_slice(language.as_bytes());
            xxh64(&data, 0)
        }
        Self::Image { bytes, format } => {
            let mut data = bytes.clone();
            data.push(*format as u8);
            xxh64(&data, 0)
        }
        Self::Audio { bytes, sample_rate, channels } => {
            let mut data = bytes.clone();
            data.extend_from_slice(&sample_rate.to_le_bytes());
            data.push(*channels);
            xxh64(&data, 0)
        }
    }
}
```
</hash_implementation>

<magic_bytes_detection>
ImageFormat::detect() implementation:

```rust
impl ImageFormat {
    pub fn detect(bytes: &[u8]) -> Option<Self> {
        if bytes.len() < 4 {
            return None;
        }
        match &bytes[0..4] {
            [0x89, 0x50, 0x4E, 0x47] => Some(Self::Png),  // PNG magic: \x89PNG
            [0xFF, 0xD8, 0xFF, ..] => Some(Self::Jpeg),   // JPEG magic: \xFF\xD8\xFF
            [0x47, 0x49, 0x46, 0x38] => Some(Self::Gif),  // GIF magic: GIF8
            _ if bytes.len() >= 12 && &bytes[0..4] == b"RIFF" && &bytes[8..12] == b"WEBP" => {
                Some(Self::WebP)
            }
            _ => None,
        }
    }
}
```
</magic_bytes_detection>

<test_requirements>
  <test_count minimum="28">At least 28 tests required</test_count>
  <no_mocks>All tests use real data, no mock/stub values</no_mocks>

  <test_categories>
    <category name="text_construction" count="5">
      <test>text() with valid content succeeds</test>
      <test>text() with empty content returns InvalidInput error</test>
      <test>text_with_instruction() with valid inputs succeeds</test>
      <test>text_with_instruction() stores instruction correctly</test>
      <test>text_with_instruction() with empty content returns InvalidInput error</test>
    </category>

    <category name="code_construction" count="4">
      <test>code() with valid content and language succeeds</test>
      <test>code() with empty content returns InvalidInput error</test>
      <test>code() with empty language returns InvalidInput error</test>
      <test>code() stores language lowercase or as-is</test>
    </category>

    <category name="image_construction" count="3">
      <test>image() with valid bytes succeeds</test>
      <test>image() with empty bytes returns InvalidInput error</test>
      <test>image() stores format correctly</test>
    </category>

    <category name="audio_construction" count="5">
      <test>audio() with valid parameters succeeds</test>
      <test>audio() with empty bytes returns InvalidInput error</test>
      <test>audio() with sample_rate=0 returns InvalidInput error</test>
      <test>audio() with channels=0 returns InvalidInput error</test>
      <test>audio() with channels=3 returns InvalidInput error</test>
    </category>

    <category name="content_hash" count="4">
      <test>content_hash() same for identical text inputs</test>
      <test>content_hash() different for different content</test>
      <test>content_hash() includes instruction in hash</test>
      <test>content_hash() includes all fields for each variant</test>
    </category>

    <category name="byte_size" count="3">
      <test>byte_size() returns correct size for text</test>
      <test>byte_size() returns correct size for image bytes</test>
      <test>byte_size() includes string heap allocation</test>
    </category>

    <category name="type_predicates" count="4">
      <test>is_text() returns true only for Text variant</test>
      <test>is_code() returns true only for Code variant</test>
      <test>is_image() returns true only for Image variant</test>
      <test>is_audio() returns true only for Audio variant</test>
    </category>
  </test_categories>
</test_requirements>

<full_state_verification>
  <source_of_truth>
    1. error.rs: EmbeddingError enum with InvalidInput variant
    2. Cargo.toml: xxhash-rust dependency
    3. types/mod.rs: module exports
    4. This specification document
  </source_of_truth>

  <execute_and_inspect>
    After implementation, run these exact commands:

    ```bash
    # 1. Verify cargo check passes (no compilation errors)
    cd /home/cabdru/contextgraph && cargo check -p context-graph-embeddings

    # 2. Run all tests with output
    cargo test -p context-graph-embeddings -- --nocapture

    # 3. Verify test count (should be 153 + 28 = 181+)
    cargo test -p context-graph-embeddings 2>&1 | grep -E "^test result:"

    # 4. Verify ModelInput is exported
    cargo doc -p context-graph-embeddings --no-deps 2>&1 | grep ModelInput
    ```
  </execute_and_inspect>

  <edge_case_audit>
    <edge_case id="1" name="empty_text_content">
      <description>Text with empty string must fail</description>
      <before_state>
        ```rust
        println!("BEFORE: Attempting to create ModelInput::text(\"\")");
        ```
      </before_state>
      <after_state>
        ```rust
        let result = ModelInput::text("");
        println!("AFTER: Result = {:?}", result);
        assert!(result.is_err());
        ```
      </after_state>
      <expected>Err(EmbeddingError::InvalidInput("Text content cannot be empty"))</expected>
    </edge_case>

    <edge_case id="2" name="audio_invalid_channels">
      <description>Audio with channels=0 or channels=3 must fail</description>
      <before_state>
        ```rust
        println!("BEFORE: audio bytes=[1,2,3], sample_rate=16000, channels=0");
        ```
      </before_state>
      <after_state>
        ```rust
        let result = ModelInput::audio(vec![1,2,3], 16000, 0);
        println!("AFTER: channels=0 result = {:?}", result);
        let result2 = ModelInput::audio(vec![1,2,3], 16000, 3);
        println!("AFTER: channels=3 result = {:?}", result2);
        ```
      </after_state>
      <expected>Both return Err(EmbeddingError::InvalidInput)</expected>
    </edge_case>

    <edge_case id="3" name="hash_determinism">
      <description>Same content produces same hash across calls</description>
      <before_state>
        ```rust
        let input1 = ModelInput::text("test content").unwrap();
        let hash1 = input1.content_hash();
        println!("BEFORE: First hash = {}", hash1);
        ```
      </before_state>
      <after_state>
        ```rust
        let input2 = ModelInput::text("test content").unwrap();
        let hash2 = input2.content_hash();
        println!("AFTER: Second hash = {}", hash2);
        assert_eq!(hash1, hash2);
        ```
      </after_state>
      <expected>hash1 == hash2</expected>
    </edge_case>
  </edge_case_audit>

  <evidence_of_success>
    Implementation is complete when:

    1. cargo check passes:
       ```
       Finished `dev` profile [unoptimized + debuginfo] target(s) in X.XXs
       ```

    2. All tests pass:
       ```
       test result: ok. X passed; 0 failed; 0 ignored
       ```
       Where X >= 181 (153 existing + 28 new)

    3. New types are exported:
       ```rust
       use context_graph_embeddings::types::{ModelInput, ImageFormat};
       ```
  </evidence_of_success>
</full_state_verification>

<validation_criteria>
  <criterion>cargo check -p context-graph-embeddings passes with no warnings</criterion>
  <criterion>cargo test -p context-graph-embeddings passes with 0 failures</criterion>
  <criterion>At least 28 new tests in input.rs</criterion>
  <criterion>All edge case tests print before/after state</criterion>
  <criterion>No mock data in any test</criterion>
  <criterion>ModelInput and ImageFormat exported from types module</criterion>
</validation_criteria>

<sherlock_verification>
  MANDATORY FINAL STEP: After implementation, spawn sherlock-holmes agent with this prompt:

  ```
  FORENSIC VERIFICATION M03-F06 ModelInput:

  1. CHECK file exists: crates/context-graph-embeddings/src/types/input.rs
  2. CHECK mod.rs exports: ModelInput, ImageFormat
  3. CHECK Cargo.toml has: xxhash-rust dependency
  4. CHECK text() rejects empty content (EmbeddingError::InvalidInput)
  5. CHECK code() rejects empty content OR empty language
  6. CHECK image() rejects empty bytes
  7. CHECK audio() rejects: empty bytes, sample_rate=0, channels not in [1,2]
  8. CHECK content_hash() uses xxh64
  9. CHECK ImageFormat::detect() uses magic bytes
  10. RUN: cargo test -p context-graph-embeddings input -- --nocapture
  11. VERIFY: >= 28 tests pass in input.rs
  12. VERIFY: Total test count >= 181 (153 + 28)
  13. VERIFY: No mock data in tests
  14. VERIFY: Edge cases print before/after state

  SOURCE OF TRUTH VERIFICATION:
  - Inspect types/mod.rs to confirm export
  - Inspect error.rs to confirm InvalidInput variant used
  - Run cargo test and capture EXACT output

  FAIL FAST if any check fails. Report exact discrepancy with file:line.
  ```
</sherlock_verification>

<implementation_complete date="2026-01-01">
  <verification_results>
    <sherlock_verdict>INNOCENT - IMPLEMENTATION COMPLETE</sherlock_verdict>
    <test_count>46 tests (requirement: >= 28)</test_count>
    <test_result>50 passed; 0 failed; 0 ignored</test_result>
    <compilation>cargo check -p context-graph-embeddings: SUCCESS</compilation>

    <files_created>
      <file path="crates/context-graph-embeddings/src/types/input.rs" lines="1204">
        Full implementation of ModelInput enum and ImageFormat enum
      </file>
    </files_created>

    <files_modified>
      <file path="crates/context-graph-embeddings/src/types/mod.rs">
        Added: mod input;
        Added: pub use input::{ImageFormat, ModelInput};
      </file>
    </files_modified>

    <validation_matrix>
      <check name="text() empty content validation" status="PASS" />
      <check name="code() empty content validation" status="PASS" />
      <check name="code() empty language validation" status="PASS" />
      <check name="image() empty bytes validation" status="PASS" />
      <check name="audio() empty bytes validation" status="PASS" />
      <check name="audio() sample_rate=0 validation" status="PASS" />
      <check name="audio() channels validation" status="PASS" />
      <check name="content_hash() uses xxh64" status="PASS" />
      <check name="ImageFormat::detect() magic bytes" status="PASS" />
      <check name="error.rs InvalidInput variant" status="PASS" />
      <check name="No mock data in tests" status="PASS" />
      <check name="Edge cases print before/after" status="PASS" />
    </validation_matrix>

    <edge_case_verification>
      <case name="empty_text_content">
        BEFORE: Attempting to create ModelInput::text("")
        AFTER: Result = Err(InvalidInput("Text content cannot be empty"))
        STATUS: VERIFIED
      </case>
      <case name="audio_invalid_channels">
        BEFORE: audio bytes=[1,2,3], sample_rate=16000, channels=0
        AFTER: Result = Err(InvalidInput("Audio channels must be 1 (mono) or 2 (stereo), got 0"))
        STATUS: VERIFIED
      </case>
      <case name="hash_determinism">
        First hash = 15460981205236195414
        Second hash = 15460981205236195414
        STATUS: VERIFIED (identical across multiple calls)
      </case>
    </edge_case_verification>
  </verification_results>
</implementation_complete>
</task_spec>
```
