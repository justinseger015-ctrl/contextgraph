# Task Specification: M03-F05

```xml
<task_spec id="M03-F05" version="2.1">
<metadata>
  <title>Define FusedEmbedding Struct (1536D Output)</title>
  <status>COMPLETE</status>
  <layer>foundation</layer>
  <sequence>5</sequence>
  <implements>constitution.yaml: embeddings.fused_output</implements>
  <completed_date>2026-01-01</completed_date>
  <depends_on>
    <dep id="M03-F01" status="COMPLETE">ModelId enum - crates/context-graph-embeddings/src/types/model_id.rs</dep>
    <dep id="M03-F02" status="COMPLETE">Dimension constants - crates/context-graph-embeddings/src/types/dimensions.rs</dep>
  </depends_on>
</metadata>

<implementation_status>
  <file path="crates/context-graph-embeddings/src/types/fused.rs" lines="1428" status="COMPLETE"/>
  <file path="crates/context-graph-embeddings/src/types/mod.rs" status="UPDATED">exports FusedEmbedding, AuxiliaryEmbeddingData</file>
  <file path="crates/context-graph-embeddings/src/error.rs" status="UPDATED">added FusedEmbedding-specific errors</file>
  <tests passed="46" required="38" status="PASSING"/>
  <sherlock_audit status="INNOCENT" checks_passed="66/66"/>
</implementation_status>

<source_of_truth>
  <constitution>specs/constitution.yaml</constitution>
  <existing_types>crates/context-graph-embeddings/src/types/</existing_types>
  <error_types>crates/context-graph-embeddings/src/error.rs</error_types>
  <lib_exports>crates/context-graph-embeddings/src/lib.rs - exports EmbeddingError, EmbeddingResult</lib_exports>
  <dimension_constants>
    <const name="FUSED_OUTPUT" value="1536" file="dimensions.rs" exists="true"/>
    <const name="NUM_EXPERTS" value="8" file="dimensions.rs" exists="true"/>
    <const name="TOP_K_EXPERTS" value="2" file="dimensions.rs" exists="true"/>
    <const name="COLBERT_V3_DIM" value="128" file="dimensions.rs" exists="true"/>
  </dimension_constants>
  <model_ids>ModelId enum with 12 variants in model_id.rs</model_ids>
</source_of_truth>

<context>
Implement FusedEmbedding struct - the final 1536D output from FuseMoE fusion.
This is the primary embedding representation used throughout the system for
similarity search, clustering, and downstream tasks.

The struct captures:
- The 1536D fused vector (FUSED_OUTPUT from dimensions.rs)
- Expert routing information (which 2 of 8 experts were selected)
- Expert weights (contribution of each expert, sum to 1.0)
- Pipeline timing for performance monitoring (microseconds)
- Content hash for caching (xxHash64)
- Optional auxiliary data for ColBERT per-token vectors (128D each)
</context>

<design_principles>
  <principle>NO BACKWARDS COMPATIBILITY - fail fast, no fallbacks</principle>
  <principle>NO MOCK DATA - all tests use real computed values</principle>
  <principle>DIMENSION MISMATCH = ERROR - wrong dimensions return EmbeddingError</principle>
  <principle>USE EXISTING CONSTANTS - import from dimensions.rs</principle>
  <principle>USE EXISTING ERRORS - EmbeddingError from error.rs</principle>
</design_principles>

<implemented_signatures>
```rust
use crate::error::{EmbeddingError, EmbeddingResult};
use crate::types::ModelId;
use crate::types::dimensions::{FUSED_OUTPUT, COLBERT_V3_DIM, NUM_EXPERTS, TOP_K_EXPERTS};
use serde::{Serialize, Deserialize};

/// Final 1536D fused embedding from FuseMoE expert fusion.
/// This is the primary embedding representation for similarity search.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct FusedEmbedding {
    pub vector: Vec<f32>,           // 1536D fused vector
    pub expert_weights: [f32; 8],   // all 8 experts (sum to 1.0)
    pub selected_experts: [u8; 2],  // top-2 indices (0-7)
    pub pipeline_latency_us: u64,   // microseconds
    pub content_hash: u64,          // xxHash64
    pub aux_data: Option<AuxiliaryEmbeddingData>,
}

/// Auxiliary embedding data for ColBERT token-level storage.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct AuxiliaryEmbeddingData {
    pub source_model: ModelId,      // ColBertV3/LateInteraction
    pub token_vectors: Vec<Vec<f32>>, // 128D each
    pub num_tokens: usize,
    pub blob: Option<Vec<u8>>,      // compressed storage
}

impl FusedEmbedding {
    pub const DIMENSION: usize = FUSED_OUTPUT;  // 1536
    pub const NUM_EXPERTS: usize = NUM_EXPERTS; // 8
    pub const TOP_K: usize = TOP_K_EXPERTS;     // 2

    pub fn new(...) -> EmbeddingResult<Self>;   // validates dimension, expert indices
    pub fn with_aux_data(self, aux_data: AuxiliaryEmbeddingData) -> Self;
    pub fn validate(&self) -> EmbeddingResult<()>;  // NaN, Inf, weights sum
    pub fn normalize(&mut self);                    // unit vector
    pub fn cosine_similarity(&self, other: &FusedEmbedding) -> f32;
    pub fn to_bytes(&self) -> Vec<u8>;             // 6198 bytes (core)
    pub fn from_bytes(bytes: &[u8]) -> EmbeddingResult<Self>;
    pub fn has_aux_data(&self) -> bool;
    pub fn get_token_vectors(&self) -> Option<&Vec<Vec<f32>>>;
    pub fn compress_aux_data(&mut self) -> EmbeddingResult<()>;
    pub fn decompress_aux_data(&mut self) -> EmbeddingResult<()>;
    pub fn magnitude(&self) -> f32;
    pub fn is_normalized(&self) -> bool;
}

impl AuxiliaryEmbeddingData {
    pub const TOKEN_DIM: usize = COLBERT_V3_DIM; // 128
    pub fn new(source_model: ModelId, token_vectors: Vec<Vec<f32>>) -> Self;
    pub fn try_new(...) -> EmbeddingResult<Self>;  // non-panicking
    pub fn to_blob(&self) -> Vec<u8>;
    pub fn from_blob(blob: &[u8]) -> EmbeddingResult<Self>;
    pub fn memory_size(&self) -> usize;
    pub fn validate(&self) -> EmbeddingResult<()>;
}
```
</implemented_signatures>

<binary_format>
Exact byte layout for to_bytes()/from_bytes():

**Core embedding (fixed 6198 bytes):**
| Offset | Size | Field | Type |
|--------|------|-------|------|
| 0 | 6144 | vector | 1536 × f32 (little-endian) |
| 6144 | 32 | expert_weights | 8 × f32 (little-endian) |
| 6176 | 2 | selected_experts | 2 × u8 |
| 6178 | 8 | pipeline_latency_us | u64 (little-endian) |
| 6186 | 8 | content_hash | u64 (little-endian) |
| 6194 | 4 | aux_data_len | u32 (little-endian, 0 if None) |

**Optional auxiliary data (variable):**
| Offset | Size | Field |
|--------|------|-------|
| 6198+ | aux_data_len | compressed blob |

Total core size: 6198 bytes
</binary_format>

<validation_complete>
  <check id="1" status="PASSED">File exists: crates/context-graph-embeddings/src/types/fused.rs (1428 lines)</check>
  <check id="2" status="PASSED">mod.rs exports: FusedEmbedding, AuxiliaryEmbeddingData</check>
  <check id="3" status="PASSED">Constants imported from dimensions.rs (not hardcoded)</check>
  <check id="4" status="PASSED">new() validates dimension == 1536, returns EmbeddingError::DimensionMismatch</check>
  <check id="5" status="PASSED">new() validates expert indices &lt; 8, returns EmbeddingError::InvalidExpertIndex</check>
  <check id="6" status="PASSED">validate() catches NaN/Inf (EmbeddingError::InvalidVector)</check>
  <check id="7" status="PASSED">validate() catches weight sum outside [0.99, 1.01] (EmbeddingError::ExpertWeightsInvalid)</check>
  <check id="8" status="PASSED">to_bytes() produces exactly 6198 bytes (verified by test)</check>
  <check id="9" status="PASSED">from_bytes() round-trips correctly</check>
  <check id="10" status="PASSED">46 tests pass (exceeds 38 minimum)</check>
  <check id="11" status="PASSED">No mock data in tests</check>
  <check id="12" status="PASSED">Edge cases print before/after state</check>
</validation_complete>

<test_summary>
  <total>46 tests</total>
  <passed>46</passed>
  <failed>0</failed>
  <categories>
    <category name="construction" count="7">new(), with_aux_data(), dimension validation</category>
    <category name="validation" count="8">NaN, Inf, weight sum, expert indices</category>
    <category name="normalization" count="5">normalize(), magnitude(), is_normalized()</category>
    <category name="similarity" count="5">cosine_similarity() edge cases</category>
    <category name="serialization" count="8">to_bytes(), from_bytes(), serde JSON</category>
    <category name="auxiliary_data" count="7">AuxiliaryEmbeddingData methods</category>
    <category name="edge_cases" count="6">boundary conditions with before/after logging</category>
  </categories>
</test_summary>

<error_types_added>
```rust
// Added to crates/context-graph-embeddings/src/error.rs:

#[error("Invalid vector: {0}")]
InvalidVector(String),

#[error("Expert weights invalid: {0}")]
ExpertWeightsInvalid(String),

#[error("Invalid expert index: {index}, must be < {max}")]
InvalidExpertIndex { index: u8, max: usize },

#[error("Serialization error: {0}")]
SerializationError(String),

#[error("Compression error: {0}")]
CompressionError(String),

#[error("Invalid auxiliary data: {0}")]
InvalidAuxData(String),
```
</error_types_added>

<verification_commands>
```bash
# Verify cargo check passes
cargo check -p context-graph-embeddings

# Run all tests
cargo test -p context-graph-embeddings fused -- --nocapture

# Verify test count (should show 46)
cargo test -p context-graph-embeddings fused 2>&1 | grep "test result:"

# Output: test result: ok. 46 passed; 0 failed; 0 ignored
```
</verification_commands>

<notes>
- Implementation exceeds minimum test count (46 vs 38)
- Additional test for duplicate expert selection adds robustness
- Uses COLBERT_V3_DIM for token dimension (semantically accurate for ColBERT)
- CompressionError defined but reserved for future lz4 compression
- Zero vector normalization handled safely (no NaN)
- All constants imported from dimensions.rs for single source of truth
</notes>
</task_spec>
```
