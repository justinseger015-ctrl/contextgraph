//! Stub embedding provider for testing.
//!
//! Provides deterministic embeddings without requiring GPU or model files.
//! Useful for unit tests and development environments.

use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::sync::RwLock;
use std::time::{Duration, Instant};

use async_trait::async_trait;

use crate::error::CoreResult;
use crate::traits::{EmbeddingOutput, EmbeddingProvider};

/// Stub embedding provider for testing.
///
/// Generates deterministic embeddings based on content hash.
/// Does not require GPU or model files.
///
/// # Health Tracking
///
/// This provider tracks its initialization state and any errors that occur.
/// The `is_ready()` method returns the actual health status based on:
/// - Whether the provider has been properly initialized
/// - Whether any fatal errors have occurred
///
/// # Example
///
/// ```ignore
/// use context_graph_core::stubs::StubEmbeddingProvider;
/// use context_graph_core::traits::EmbeddingProvider;
///
/// # async fn example() {
/// let provider = StubEmbeddingProvider::new();
/// assert!(provider.is_ready()); // Should be true after proper initialization
/// let output = provider.embed("test content").await.unwrap();
/// assert_eq!(output.dimensions, 1536);
/// # }
/// ```
pub struct StubEmbeddingProvider {
    dimensions: usize,
    model_id: String,
    /// Tracks whether the provider has been properly initialized.
    initialized: AtomicBool,
    /// Tracks the total number of embeddings generated (for diagnostics).
    embedding_count: AtomicU64,
    /// Stores the last error message if any fatal error occurred.
    last_error: RwLock<Option<String>>,
}

impl Default for StubEmbeddingProvider {
    fn default() -> Self {
        Self::new()
    }
}

impl StubEmbeddingProvider {
    /// Create a new stub embedding provider with default 1536 dimensions.
    ///
    /// The provider is marked as initialized upon creation.
    pub fn new() -> Self {
        tracing::debug!("StubEmbeddingProvider: initializing with 1536 dimensions");
        Self {
            dimensions: 1536,
            model_id: "stub-embedding-v1".to_string(),
            initialized: AtomicBool::new(true),
            embedding_count: AtomicU64::new(0),
            last_error: RwLock::new(None),
        }
    }

    /// Create a stub provider with custom dimensions.
    ///
    /// # Arguments
    ///
    /// * `dimensions` - The dimensionality of embeddings to generate
    ///
    /// # Panics
    ///
    /// Will mark the provider as unhealthy if dimensions is 0.
    pub fn with_dimensions(dimensions: usize) -> Self {
        tracing::debug!(
            "StubEmbeddingProvider: initializing with {} dimensions",
            dimensions
        );

        let provider = Self {
            dimensions,
            model_id: "stub-embedding-v1".to_string(),
            initialized: AtomicBool::new(dimensions > 0),
            embedding_count: AtomicU64::new(0),
            last_error: RwLock::new(None),
        };

        if dimensions == 0 {
            if let Ok(mut error) = provider.last_error.write() {
                *error = Some("Invalid dimensions: 0".to_string());
            }
            tracing::error!(
                "StubEmbeddingProvider: initialized with invalid dimensions (0)"
            );
        }

        provider
    }

    /// Get the total number of embeddings generated by this provider.
    pub fn embedding_count(&self) -> u64 {
        self.embedding_count.load(Ordering::Relaxed)
    }

    /// Get the last error message, if any.
    pub fn last_error(&self) -> Option<String> {
        self.last_error.read().ok().and_then(|e| e.clone())
    }

    /// Mark the provider as having encountered a fatal error.
    ///
    /// After calling this, `is_ready()` will return false.
    pub fn set_error(&self, error: String) {
        tracing::error!("StubEmbeddingProvider: setting error state: {}", error);
        if let Ok(mut last_error) = self.last_error.write() {
            *last_error = Some(error);
        }
    }

    /// Clear any error state.
    ///
    /// After calling this, `is_ready()` will return true (if initialized).
    pub fn clear_error(&self) {
        tracing::debug!("StubEmbeddingProvider: clearing error state");
        if let Ok(mut last_error) = self.last_error.write() {
            *last_error = None;
        }
    }

    /// Generate a deterministic embedding from content.
    ///
    /// Uses a simple hash-based approach to generate reproducible embeddings.
    fn generate_embedding(&self, content: &str) -> Vec<f32> {
        let mut embedding = vec![0.0f32; self.dimensions];

        // Generate deterministic values based on content
        let bytes = content.as_bytes();
        for (i, chunk) in embedding.chunks_mut(1).enumerate() {
            // Use a simple hash combining index and content bytes
            let byte_idx = i % bytes.len().max(1);
            let byte_val = bytes.get(byte_idx).copied().unwrap_or(0) as f32;
            let idx_contribution = (i as f32 / self.dimensions as f32) * 0.5;
            let byte_contribution = (byte_val / 255.0) * 0.3;
            let base = 0.1 + idx_contribution + byte_contribution;

            // Normalize to [-1, 1] range
            chunk[0] = (base * 2.0) - 1.0;
        }

        // L2 normalize the embedding
        let norm: f32 = embedding.iter().map(|x| x * x).sum::<f32>().sqrt();
        if norm > 0.0 {
            for val in &mut embedding {
                *val /= norm;
            }
        }

        embedding
    }
}

#[async_trait]
impl EmbeddingProvider for StubEmbeddingProvider {
    async fn embed(&self, content: &str) -> CoreResult<EmbeddingOutput> {
        // Check readiness before processing
        if !self.is_ready() {
            tracing::error!(
                "StubEmbeddingProvider: embed called but provider is not ready"
            );
            return Err(crate::error::CoreError::Internal(
                "StubEmbeddingProvider is not ready".into(),
            ));
        }

        let start = Instant::now();
        let vector = self.generate_embedding(content);
        let latency = start.elapsed();

        // Track successful embedding
        self.embedding_count.fetch_add(1, Ordering::Relaxed);

        tracing::trace!(
            "StubEmbeddingProvider: generated embedding #{} in {:?}",
            self.embedding_count.load(Ordering::Relaxed),
            latency
        );

        Ok(EmbeddingOutput::new(
            vector,
            self.model_id.clone(),
            latency,
        ))
    }

    async fn embed_batch(&self, contents: &[String]) -> CoreResult<Vec<EmbeddingOutput>> {
        // Check readiness before processing
        if !self.is_ready() {
            tracing::error!(
                "StubEmbeddingProvider: embed_batch called but provider is not ready"
            );
            return Err(crate::error::CoreError::Internal(
                "StubEmbeddingProvider is not ready".into(),
            ));
        }

        let start = Instant::now();

        let outputs: Vec<EmbeddingOutput> = contents
            .iter()
            .map(|content| {
                let vector = self.generate_embedding(content);
                EmbeddingOutput::new(vector, self.model_id.clone(), Duration::from_micros(100))
            })
            .collect();

        // Track successful embeddings
        self.embedding_count
            .fetch_add(contents.len() as u64, Ordering::Relaxed);

        let total_latency = start.elapsed();
        tracing::debug!(
            "StubEmbeddingProvider: batch embed of {} items took {:?}",
            contents.len(),
            total_latency
        );

        Ok(outputs)
    }

    fn dimensions(&self) -> usize {
        self.dimensions
    }

    fn model_id(&self) -> &str {
        &self.model_id
    }

    /// Check if the provider is ready to generate embeddings.
    ///
    /// This performs REAL health checks:
    /// 1. Verifies the provider was properly initialized
    /// 2. Checks for any fatal errors in the error state
    /// 3. Validates internal configuration (dimensions > 0)
    ///
    /// # Returns
    ///
    /// `true` if all health checks pass, `false` otherwise.
    fn is_ready(&self) -> bool {
        // Check 1: Was the provider properly initialized?
        let is_initialized = self.initialized.load(Ordering::SeqCst);
        if !is_initialized {
            tracing::warn!(
                "StubEmbeddingProvider health check failed: not initialized"
            );
            return false;
        }

        // Check 2: Are there any fatal errors?
        let has_error = self
            .last_error
            .read()
            .map(|e| e.is_some())
            .unwrap_or(true); // If lock is poisoned, treat as error

        if has_error {
            if let Ok(error) = self.last_error.read() {
                if let Some(ref err_msg) = *error {
                    tracing::warn!(
                        "StubEmbeddingProvider health check failed: error state: {}",
                        err_msg
                    );
                }
            }
            return false;
        }

        // Check 3: Is configuration valid?
        if self.dimensions == 0 {
            tracing::warn!(
                "StubEmbeddingProvider health check failed: invalid dimensions (0)"
            );
            return false;
        }

        true
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_stub_embed_dimensions() {
        let provider = StubEmbeddingProvider::new();
        let output = provider.embed("test content").await.unwrap();

        assert_eq!(output.dimensions, 1536);
        assert_eq!(output.vector.len(), 1536);
    }

    #[tokio::test]
    async fn test_stub_embed_deterministic() {
        let provider = StubEmbeddingProvider::new();
        let output1 = provider.embed("same content").await.unwrap();
        let output2 = provider.embed("same content").await.unwrap();

        assert_eq!(output1.vector, output2.vector);
    }

    #[tokio::test]
    async fn test_stub_embed_different_content() {
        let provider = StubEmbeddingProvider::new();
        let output1 = provider.embed("content A").await.unwrap();
        let output2 = provider.embed("content B").await.unwrap();

        // Different content should produce different embeddings
        assert_ne!(output1.vector, output2.vector);
    }

    #[tokio::test]
    async fn test_stub_embed_batch() {
        let provider = StubEmbeddingProvider::new();
        let contents = vec![
            "first".to_string(),
            "second".to_string(),
            "third".to_string(),
        ];

        let outputs = provider.embed_batch(&contents).await.unwrap();

        assert_eq!(outputs.len(), 3);
        for output in &outputs {
            assert_eq!(output.dimensions, 1536);
        }
    }

    #[tokio::test]
    async fn test_stub_is_ready() {
        let provider = StubEmbeddingProvider::new();
        assert!(provider.is_ready());
    }

    #[tokio::test]
    async fn test_stub_custom_dimensions() {
        let provider = StubEmbeddingProvider::with_dimensions(768);
        let output = provider.embed("test").await.unwrap();

        assert_eq!(output.dimensions, 768);
        assert_eq!(output.vector.len(), 768);
    }

    #[tokio::test]
    async fn test_embedding_is_normalized() {
        let provider = StubEmbeddingProvider::new();
        let output = provider.embed("test content").await.unwrap();

        // Check L2 norm is approximately 1.0
        let norm: f32 = output.vector.iter().map(|x| x * x).sum::<f32>().sqrt();
        assert!((norm - 1.0).abs() < 0.001, "Embedding should be L2 normalized");
    }

    // New tests for real health checks

    #[test]
    fn test_health_check_with_zero_dimensions() {
        let provider = StubEmbeddingProvider::with_dimensions(0);
        // Provider with 0 dimensions should NOT be ready
        assert!(!provider.is_ready());
    }

    #[test]
    fn test_health_check_with_error_state() {
        let provider = StubEmbeddingProvider::new();
        assert!(provider.is_ready());

        // Set an error
        provider.set_error("Simulated fatal error".to_string());
        assert!(!provider.is_ready());
        assert_eq!(
            provider.last_error(),
            Some("Simulated fatal error".to_string())
        );

        // Clear error
        provider.clear_error();
        assert!(provider.is_ready());
        assert!(provider.last_error().is_none());
    }

    #[tokio::test]
    async fn test_embed_fails_when_not_ready() {
        let provider = StubEmbeddingProvider::with_dimensions(0);
        let result = provider.embed("test").await;
        assert!(result.is_err());
    }

    #[tokio::test]
    async fn test_embed_batch_fails_when_not_ready() {
        let provider = StubEmbeddingProvider::new();
        provider.set_error("Fatal error".to_string());

        let contents = vec!["test".to_string()];
        let result = provider.embed_batch(&contents).await;
        assert!(result.is_err());
    }

    #[tokio::test]
    async fn test_embedding_count_tracking() {
        let provider = StubEmbeddingProvider::new();
        assert_eq!(provider.embedding_count(), 0);

        provider.embed("test1").await.unwrap();
        assert_eq!(provider.embedding_count(), 1);

        provider.embed("test2").await.unwrap();
        assert_eq!(provider.embedding_count(), 2);

        let contents = vec!["a".to_string(), "b".to_string(), "c".to_string()];
        provider.embed_batch(&contents).await.unwrap();
        assert_eq!(provider.embedding_count(), 5);
    }
}
